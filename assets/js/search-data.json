{
  
    
        "post0": {
            "title": "(4주차) 3월23일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 파이썬이 어려웠던 이유 . - (2/8) 1세대 프로그래머 . - (3/8) 1세대 프로그래머의 삶 with python . - (4/8) 1세대 프로그래머의 삶 with ipython . - (5/8) 2세대 프로그래머, 3세대 프로그래머 (1) . - (6/8) 3세대 프로그래머(2), 4세대 프로그래머 . - (7/8) 5세대 프로그래머 . - (8/8) 다양한 개발환경 구축방법 다시 리뷰, 숙제설명 . &#54028;&#51060;&#50028;&#51060; &#50612;&#47140;&#50912;&#45912; &#51060;&#50976; . - 파이썬 배우는 초보자에게 가장 어려운것! . 선생님마다 설치하는 방법이 모두 다름 | . - 왜 저렇게 설치방법이 다른가? 왜 다른 방법으로 각각 파이썬을 실행하는가? 이런것이 너무 어려움 . 방법1: 파이썬프로그램 다운로드 -&gt; 시작버튼 눌러서 설치 | 방법2: 아나콘다 설치 (그럼 자동으로 파이썬이 설치됨) | 방법3: 아나콘다 설치 + 가상환경 | ... | . - 심지어 실행하는것도 다름 . 방법1: 파이썬 프롬프트 | 방법2: .py를 이용하여 실행? | 방법3: IDLE | 방법4: 파이참 | 방법5: 스파이더 | 방법6: Visual Studio Code | 방법7: 주피터노트북, 주피터랩 가상환경을 만들어서 해라.. | 아나콘다 네비게이터에 주피터가 있다.. | . | ... | . - 머리아프니까 collab을 쓰라는 사람도 있음. 아니면 도커이미지를 줄테니까 그걸 쓰라는 사람도 있음. AWS를 쓰라는 사람도 있음.. $ to$ 이게 더 머리아픔 . - 핵심: 그냥 (1) 컴퓨터에 (2) 파이썬을 깔아서 (3) 실행하는 것임 . - 의문: 그런데 방법이 왜이렇게 많은가? 엑셀처럼 프로그램 설치하고 아이콘 더블클릭하면 끝나는 식으로 만들어야 하는것 아닌가? . &#44060;&#48156;&#54872;&#44221; &#44396;&#52629;&#48169;&#48277;&#51060; &#47566;&#51008; &#51060;&#50976;? . - 파이썬 개발환경 구축은 수많은 방법이 있다. . - 이는 마치 라면의 레시피를 검색하면 수많은 방법이 나오는것과 유사함. . 방법1: 스프를 먼저 넣고 끓인다음 라면을 넣어야 합니다. | 방법2: 양은냄비에 물넣고 물이 끊으면 라면과 스프를 같이 넣고 마지막에 계란을 넣는다. | 방법3: 먹다남은 삼겹살을 후라이팬에 볶은다음에 물을 붓고 라면을 넣는다. | 방법4: 용기에 라면+스프+뜨거운물 랩을 씌운뒤에 젓가락으로 구멍을 뚫고 전자렌지에 돌린다. | ... | . - 우리는 모든 방법을 나열할 순 없지만 모든 방법을 이해할 수 있다. 왜냐하면 라면을 끓이는 공통적인 맥락을 우리는 알고 있으니까 . - 파이썬을 설치하는 다양한 방법 역시 공통맥락을 파악하면 이해하기 쉽다. . - 제목적: 파이썬을 설치하고 실행하는 공통맥락을 설명하고 싶음 . - 설치하는 방법이 다양한 이유? 파이썬이 인기있음 + 다양한 방법을 설치를 하면 각자의 장점이 뚜렷해서 . 1&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672; . python . - 윈도우에서 anaconda prompt 실행 -&gt; python . (base) C: Users python&gt;python Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; [1,2,3]+[4] [1, 2, 3, 4] &gt;&gt;&gt; a=[1,2,3]+[4] &gt;&gt;&gt; a [1, 2, 3, 4] . - 2개를 실행할 수도 있음. (두 환경은 각각 서로 독립적인 파이썬, 변수가 공유되지 않음) $ star$ . - 아쉬운점: `?list&#39;와 같이 도움말 기능이 동작하지 않음 . &gt; &gt;&gt; ?list File &quot;&lt;stdin&gt;&quot;, line 1 ?list ^ SyntaxError:invalid syntax&gt;&gt;&gt; . ipython . - 윈도우에서 anaconda prompt 실행 -&gt; ipython . (base) C: Users python&gt;ipython Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] Type &#39;copyright&#39;, &#39;credits&#39; or &#39;license&#39; for more information IPython 7.29.0 -- An enhanced Interactive Python. Type &#39;?&#39; for help. In [1]: a=[1,2,3] In [2]: a Out[2]: [1, 2, 3] In [3]: a+[4] Out[3]: [1, 2, 3, 4] . - ?list가 가능 . In [4]: ?list Init signature: list(iterable=(), /) Docstring: Built-in mutable sequence. If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified. Type: type Subclasses: _HashedSeq, StackSummary, DeferredConfigList, SList, _ImmutableLineList, FormattedText, NodeList, _ExplodedList, Stack, _Accumulator, ... . - 색깔이 알록달록해서 문법을 보기 편하다. (구문강조) . 1&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;&#51032; &#49334; with python . - 1부터 10까지 합을 구하는 프로그램을 만들고 싶음 . - 시도1: python을 키고 아래와 같이 실행 . (base) C: Users python&gt;python Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt; &gt;&gt; total = 0 &gt;&gt;&gt; for i in range(10):... total=total+i... &gt;&gt;&gt; total 45 &gt;&gt;&gt; . - 반성: 정답은 55인데 45가 출력되었다! $ to$ range(10)을 range(1,11)으로 바꿔야겠다! . - 시도2: range(1,11)을 바꿔야겠다고 생각하고 다시 입력하다가 오타가 발생 . &gt; &gt;&gt; total =0 &gt;&gt;&gt; for i in range(1,11):... total = totla +i... . 앗 totla이라고 잘못쳤다. | . - 반성: 다음에는 정신을 똑바로 차려야겠다. . - 불편한점: ... 다.. . 1&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;&#51032; &#49334; with ipython . - ipython을 사용한 프로그래머는 좀더 상황이 낫다 . (base) C: Users python&gt;ipython Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] Type &#39;copyright&#39;, &#39;credits&#39; or &#39;license&#39; for more information IPython 7.29.0 -- An enhanced Interactive Python. Type &#39;?&#39; for help. In [1]: total = 0 In [2]: for i in range(1,11): ...: total = total + i ...: In [3]: total Out[3]: 55 . 편한점1: 자동으로 들여쓰기가 되어서 편함 | 편한점2: 화살표를 이용해서 for문을 쓰는 도중에 위아래로 이동가능 | 불편한점1: 화살표로 이동할수는 있는데 마우스로는 이동할 수 없다. | 불편한점2: 내가 작성한 코드를 관리하기 어렵다. | . 2&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;: &#47700;&#47784;&#51109; + anconda prompt&#47484; &#51060;&#50857; (.py&#47484; &#51060;&#50857;&#54620; python&#54876;&#50857;) . - 메모장을 키고 아래의 내용을 적는다. . total = 0 for i in range(1,11): total = total + i print(total) . - 파일이름을 mysum.py로 저장한다. . - anaconda prompt에서 mysum.py파일이 저장된 폴더로 이동 -&gt; 실행 . (base) C: Users python&gt;cd Desktop (base) C: Users python Desktop&gt;dir C 드라이브의 볼륨에는 이름이 없습니다. 볼륨 일련 번호: 9AFD-A05F C: Users python Desktop 디렉터리 2022-03-27 오전 11:32 &lt;DIR&gt; . 2022-03-27 오전 11:32 &lt;DIR&gt; .. 2022-03-27 오전 12:01 2,306 Chrome.lnk 2022-03-26 오후 08:32 2,332 Microsoft Edge.lnk 2022-03-27 오전 11:33 71 mysum.py 3개 파일 4,709 바이트 2개 디렉터리 743,643,467,776 바이트 남음 (base) C: Users python Desktop&gt;python mysum.py 55 (base) C: Users python Desktop&gt; . - 소감 . 편한점1: 마우스를 이용하여 이동가능 | 편한점2: 내가 작업한 내용은 바탕화면의 메모장에 저장이 되어있음 | 아쉬운점: ipython의 장점은 활용못함 (구문강조, 도움말기능) | . 3&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;: &#47700;&#47784;&#51109; + ipython . - 전체적인 개발방식 . 메모장: 코드를 편집, 저장 | ipython: anaconda prompt처럼 메모장의 코드를 실행하고 결과를 확인 + 구문강조, 도움말확인기능 등을 이용하여 짧은 코드를 빠르게 작성 | . - 기능 . ipython에서 !python mysum.py를 입력하면 anaconda prompt에서 python mysum.py를 입력한 것과 같은 효과 | ipython에서 %run mysum을 입력하면 메모장에서 mysum.py에 입력된 내용을 복사해서 ipython에 붙여넣어 실행한것과 같은 효과 | . 4&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;: IDE(&#53685;&#54633;&#44060;&#48156;&#54872;&#44221;)&#47484; &#49324;&#50857; . - 메모장과 ipython을 하나로 통합한 프로그램이 등장! . jupyter notebook, jupyter lab | spyder | idle | VScode | ... | . - 주피터의 트릭 (실제로 주피터는 ipython에 기생할 뿐 아무런 역할도 안해요) . (1) 주피터를 실행 . (2) 새노트북을 생성 (파이썬으로 선택) . 컴퓨터는 내부적으로 ipython을 실행하고 그 ipython이랑 여러분이 방금만든 그 노트북과 연결 | . (3) 처음보이는 cell에 1+1을 입력 -&gt; 쉬프트엔터 -&gt; 결과2가 출력 . 처음보이는 cell하나 = 자동으로 열린 하나의 메모장 | cell 1+1을 입력 = 메모장에 1+1을 적음 | 쉬프트+엔터후 결과2를 출력 = cell의 내용을 복사 -&gt; ipython에 붙여넣음 -&gt; ipython 계산된 결과를 복사 -&gt; cell로 돌아와 붙여넣기 | . (4) 새로운 cell을 추가하고 2+2을 입력 -&gt; 쉬프트엔터 -&gt; 결과4가 출력 . 새로운 cell을 추가 = 새로운 메모장 추가 | cell 2+2을 입력 = 새로운 메모장에 2+2를 적음 | 쉬프트+엔터후 결과4를 출력 = cell의 내용을 복사 -&gt; ipython에 붙여넣음 -&gt; ipython 계산된 결과를 복사 -&gt; cell로 돌아와 붙여넣기 | . - 중요한 사실들 . IDE는 내부적으로 연산을 수행하는 능력이 없다. (생각해볼것: 왜 R을 꼭 설치하고 Rstudio를 설치해야 했을까?) | 주피터에서 커널을 재시작한다는 의미는 메모장이 열린채로 ipython을 껐다가 다시 실행한다는 의미 | 주피터는 단순히 &#39;메모장의 내용을 복사하여 붙여넣는 기계&#39;라고 볼 수 있다. 이렇게 생각하면 주피터는 꼭 ipython에 연결할 이유는 없다. 실제로 주피터에 R을 연결해서 쓸 수 있다. 즉 하나의 IDE가 여러개의 언어와 연결될 수 있다. | Jupyterlab이라는 프로그램은 크롬에 있는 내용과 ipython간의 통신을 제어하는 프로그램일 뿐이다. | . 5&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;: &#44032;&#49345;&#52980;&#54504;&#53552;(anaconda), &#50896;&#44201;&#52980;&#54504;&#53552;(server), &#53364;&#46972;&#50864;&#46300;&#52980;&#54504;&#53552;(colab)&#51032; &#44060;&#45392; &#46321;&#51109; . - 지금까지는 ipython이 실행되는 컴퓨터와 크롬이 실행되는 컴퓨터가 동일하다는 전제였음. . - 생각해보니까 어차피 ipython이 실행된 컴퓨터에서 내가 크롬에 입력한 명령 &quot;전달&quot;되기만 하면 되므로 꼭 같은 컴퓨터일 필요는 없다. . &#47784;&#45944;1: &#50896;&#44201;&#52980;&#54504;&#53552; . - 준비상태 . 전북대컴퓨터: ipython을 실행 + 이 컴퓨터는 인터넷 연결이 되어있어야함 | 우리집노트북: 크롬실행 + 이 컴퓨터도 인터넷이 연결되어 있어야함 | . - 명령입력 . 우리집노트북 크롬에서 1+1을 입력하고 쉬프트 엔터를 누름 | . - 우리집노트북 -&gt; 전북대컴퓨터 . 우리집 노트북의 내부의 어떤프로그램은 1+1이라는 명령을 복사하여 카카오톡으로 전북대 컴퓨터에 전달 | 전북대 컴퓨터의 내부의 어떤프로그램은 1+1이라는 명령을 카톡으로 받아서 그것을 ipython에게 전달 | . - 전북대컴퓨터 -&gt; 우리집노트북 . 전북대컴퓨터 내부의 ipython은 2라는 출력결과를 계산함 | 전북대컴퓨터 내부의 어떤프로그램은 계산결과를 카톡으로 우리집 노트북에 알려줌 | 나는 우리집 노트북에서 계산결과를 받아볼 수 있다. | . &#47784;&#45944;2: &#50896;&#44201;&#52980;&#54504;&#53552; + &#44032;&#49345;&#52980;&#54504;&#53552; . - 준비상태 . 성능좋은 전북대 컴퓨터 1개 | 내 노트북 1개 (그냥 싸고 가벼운거) | 대학원생 아이패드 1개 (그냥 싸고 가벼운거) | . - 아이디어 . 성능좋은 전북대 컴퓨터를 논리적으로 3개로 분리 $ to$ 이를 각각 (base) (py39jl17) (py38r40) 컴퓨터라고 하자. | 나는 (py39jl17)에 접속하여 파이썬 3.9와 줄리아 1.7을 설치한뒤 실습한다. | 대학원생은 (py38r40)에 접속하여 파이썬 3.8과 R 4.0을 설치하고 실습한다. | (base)는 예비용으로 아무것도 설치안한 깨끗한 상태 유지 | 내가 뭘 실수해서 (py39jl17)컴퓨터가 망가졌으나 (py38r40)은 아무 타격없다. | 나는 (py39jl17)를 삭제하고 (base)로 부터 다시 새로운 컴퓨터를 복사하여 (py39jl17)을 다시 만든다. | . &#47784;&#45944;3: &#44032;&#49345;&#52980;&#54504;&#53552; . - 여러분들 사례 . 여러분들의 컴퓨터는 (base), (py39) 2개의 컴퓨터로 나누어져 있음 | 여러분들이 (py39)에만 주피터랩을 설치 | (py39)에 있는 ipython과 여러분의 크롬창이 서로 통신하면서 실습 | 장점: 서로 다른 환경에 서로다른 파이썬과 R등을 설치할 수 있다. $ to$ 패키지간의 충돌이 최소화 (파이썬 입문 수업을 듣고, 이후에 파이썬을 이용하는 어떤수업을 들음) | . &#47784;&#45944;4: &#53364;&#46972;&#50864;&#46300; . - 사례1 . 성능이 그저그런 컴퓨터 27개 | 대학원생을 포함하여 쓸 사람은 5명 | 한사람당 27/5(=5.4)대의 컴퓨터식 할당 | . - 사례2: 구글코랩 . 구글에 여러가지 성능을 가진 컴퓨터가 $n$대 있음 | $m$명의 사람이 $n$대의 컴퓨터에 접속 | 적당히 컴퓨터 자언을 분배하여 사용 | . &#50836;&#50557; &#48143; &#51221;&#47532; . - 결국 (1) 컴퓨터에 (2) 파이썬을 설치하고 (3) 실행하는 과정은 생각보다 다양한 선택의 조합이 가능하다. . (1) 그냥 내 노트북에 파이썬을 설치할지? 내 노트북안에 가상컴퓨터를 만들고 거기에 파이썬을 설치할지? 학교의 데스크탑에 파이썬을 설치하고 쓸지? 설치를 안하고 구글컴퓨터에 설치된 파이썬을 난 쓰기만 할지? . (2) python설치할지? ipython를 설치할지? 어차피 가상환경을 쓸꺼니가 anaconda를 설치할지? 아니면 코랩쓸꺼니까 설치안할지? . (3) 어떤 IDE를 쓸지? IDE를 쓰지 않을지? 내가 IDE를 직접구성해서 만들지? . 하지만 공통적으로 관통하는 원리가 있다 . &#49689;&#51228; . - 주피터랩에서 &#39;myprod.py&#39;파일을 만들고 1부터 5까지의 곱을 계산하는 코드를 작성후 %run myprod를 실행하여 출력결과를 확인 .",
            "url": "https://guebin.github.io/IP2022/2022/03/28/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9428%EC%9D%BC.html",
            "relUrl": "/2022/03/28/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9428%EC%9D%BC.html",
            "date": " • Mar 28, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "(4주차) 3월23일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) 딕셔너리 연산, 메소드 . - (2/4) 딕셔너리 연산, 메소드 (2) . - (3/4) 딕셔너리 고급 . - (4/4) 집합 . &#46357;&#49492;&#45320;&#47532; . &#50672;&#49328; . - 하나있어요.. . score = {&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . &#39;guebin&#39; in score . True . &#39;iu&#39; in score . True . &#39;hynn&#39; in score . False . - in은 사실 다른자료형도 가능했음 . (관찰1) . &#39;a&#39; in &#39;guebin&#39; . False . &#39;b&#39; in &#39;guebin&#39; . True . &#39;c&#39; in &#39;guebin&#39; . False . (관찰2) . tpl = 1,2,3 tpl . (1, 2, 3) . 1 in tpl . True . 4 in tpl . False . (관찰3) . score = [[&#39;guebin&#39;,49],[&#39;iu&#39;,80],[&#39;hynn&#39;,99]] score . [[&#39;guebin&#39;, 49], [&#39;iu&#39;, 80], [&#39;hynn&#39;, 99]] . [&#39;guebin&#39;,49] in score . True . - in연산자가 dict형에 사용되면 key를 기준으로 True, False를 판단한다. . &#47700;&#49548;&#46300; . (get) . score = {&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . score.get(&#39;guebin&#39;) . 49 . 아래와 같은 기능 . score[&#39;guebin&#39;] . 49 . 미묘한 차이점이 존재함 . score[&#39;hynn&#39;] # hynn이 없어서 키에러 출력, 그런 key는 없다.. . KeyError Traceback (most recent call last) Input In [17], in &lt;cell line: 1&gt;() -&gt; 1 score[&#39;hynn&#39;] KeyError: &#39;hynn&#39; . score.get(&#39;hynn&#39;) # hynn이 없으면 아무것도 출력안함 . (keys,values,items) . - .keys()는 딕셔너리의 키를 리턴한다. . score = {&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . _keys=score.keys() _keys . dict_keys([&#39;guebin&#39;, &#39;iu&#39;]) . type(_keys) # 리턴된 자료형은 이상한것임 . dict_keys . list(_keys) # 아무튼 그 이상한 자료형도 리스트화 가능 . [&#39;guebin&#39;, &#39;iu&#39;] . - .values()는 딕셔너리의 값들을 리턴한다. . _values =score.values() _values . dict_values([49, 80]) . type(_values) . dict_values . list(_values) . [49, 80] . - .items()는 딕셔너리의 (키,값)을 리턴한다. . _items = score.items() _items . dict_items([(&#39;guebin&#39;, 49), (&#39;iu&#39;, 80)]) . type(_items) . dict_items . list(_items) . [(&#39;guebin&#39;, 49), (&#39;iu&#39;, 80)] . - for문에서의 dict . (예시1) . for i in score.keys(): print(i) . guebin iu . for i in score: print(i) . guebin iu . 딕셔너리 그자체도 for문에 넣을 수 있다. | i에는 value가 삭제되어 들어간다. (즉 key만) | 결과를 보면 score대신에 score.keys()와 list(score)를 넣었을때와 결과가 같다. | . . Note: list(score) 하면 key만 리턴된다. . (예시2) . for i in score.values(): print(i) . 49 80 . (예시3) . for k in score.items(): print(k) . (&#39;guebin&#39;, 49) (&#39;iu&#39;, 80) . (예시4) . for i,j in score.items(): print(i,j) . guebin 49 iu 80 . (예시5) . for i,j in score.items(): print(i + &#39;의 중간고사 점수는 %s점 입니다.&#39; % j) . guebin의 중간고사 점수는 49점 입니다. iu의 중간고사 점수는 80점 입니다. . [보충학습] 문자열 새치기 . &#39;제 이름은 %s입니다&#39; % &#39;최규빈&#39; . &#39;제 이름은 최규빈입니다&#39; . %는 새치기연산자임. %s는 새치기하는 자리라고 생각 | . 보충학습끝 . &#46357;&#49492;&#45320;&#47532; &#44256;&#44553; . &#53412;&#45716; &#47928;&#51088;&#50676;&#47564; &#44032;&#45733;&#54620; &#44163;&#51060; &#50500;&#45768;&#45796;. . - 정수키 . score = {0:49, 1:80, 2:99} # key를 0,1,2로 score . {0: 49, 1: 80, 2: 99} . - 인덱싱은? . score[0] # 키로 인덱싱을 하고 있는데 마치 원소의 위치로 인덱싱을 하는 기분 . 49 . - 그럼 혹시 이것도? . score[:2] . TypeError Traceback (most recent call last) Input In [79], in &lt;cell line: 1&gt;() -&gt; 1 score[:2] TypeError: unhashable type: &#39;slice&#39; . score[-1] # 이것도 될리가 없죠.. . KeyError Traceback (most recent call last) Input In [81], in &lt;cell line: 1&gt;() -&gt; 1 score[-1] KeyError: -1 . &#53412;&#47196;&#44032;&#45733;&#54620;&#44163;? &#47928;&#51088;&#50676;, &#49707;&#51088;&#44050;, &#53916;&#54540; . score = {(&#39;guebin&#39;,0): 10, (&#39;guebin&#39;,1): 20, (&#39;guebin&#39;,2):49} # 0은 출석점수, 1은 레포트 점수, 2는 중간고사 점수 score . {(&#39;guebin&#39;, 0): 10, (&#39;guebin&#39;, 1): 20, (&#39;guebin&#39;, 2): 49} . score[(&#39;guebin&#39;,0)] . 10 . score[&#39;guebin&#39;,2] . 49 . score[(&#39;guebin&#39;,3)] = 99 # 규빈의 기말고사 점수를 추가 . score . {(&#39;guebin&#39;, 0): 10, (&#39;guebin&#39;, 1): 20, (&#39;guebin&#39;, 2): 49, (&#39;guebin&#39;, 3): 99} . 문자열, 숫자값, 튜플의 공통점? 불변객체 | . &#52280;&#44256; (&#48520;&#48320;&#54805;&#44284; &#44032;&#48320;&#54805;) . (인트형은 불변) . a=1 a,id(a) . (1, 140554269835504) . a=2 a,id(a) . (2, 140554269835536) . (문자열도 불변) . a=&#39;guebin&#39; a,id(a) . (&#39;guebin&#39;, 140553659148336) . a=&#39;Guebin&#39; a,id(a) . (&#39;Guebin&#39;, 140553649883440) . (리스트는 가변) . a=list(&#39;guebin&#39;) a,id(a) . ([&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;], 140553645841408) . a[0]=&#39;G&#39; . a,id(a) . ([&#39;G&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;], 140553645841408) . &#51665;&#54633; . &#49440;&#50616; . a={&#39;notebook&#39;,&#39;desktop&#39;} . &#50896;&#49548;&#52628;&#52636; . - 일단 인덱스로는 못합니다. . a={&#39;notebook&#39;,&#39;desktop&#39;} a[0] . TypeError Traceback (most recent call last) Input In [132], in &lt;cell line: 2&gt;() 1 a={&#39;notebook&#39;,&#39;desktop&#39;} -&gt; 2 a[0] TypeError: &#39;set&#39; object is not subscriptable . - 딱히 하는 방법이 없어요.. 그리고 이걸 하는 의미가 없어요.. (원소에 접근해서 뭐하려고??) . &#50896;&#49548;&#52628;&#44032; . - 이건 의미가 있죠 . a={&#39;notebook&#39;,&#39;desktop&#39;} a . {&#39;desktop&#39;, &#39;notebook&#39;} . a.add(&#39;ipad&#39;) a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . a.add(&#39;notebook&#39;) # 이미 원소로 있는건 추가되지 않음. a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . &#50896;&#49548;&#49325;&#51228; . a={&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . a.remove(&#39;notebook&#39;) . a . {&#39;desktop&#39;, &#39;ipad&#39;} . &#50672;&#49328; . - in 연산자 . a={&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . &#39;notebook&#39; in a . True . 참고로 in연산자는 집합에서만 쓰는것은 아님 | . - 합집합, 교집합, 차집합 . day1 = {&#39;notebook&#39;,&#39;desktop&#39;} day2 = {&#39;notebook&#39;,&#39;ipad&#39;} . day1 | day2 # 합집합 . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . day1 &amp; day2 # 교집합 . {&#39;notebook&#39;} . day1 - day2 # 차집합 . {&#39;desktop&#39;} . day2 - day1 # 차집합 . {&#39;ipad&#39;} . - 부분집합 . day1 = {&#39;notebook&#39;, &#39;desktop&#39;} day2 = day1 | {&#39;ipad&#39;} . day1 &lt; day2 # day1는 day2의 부분집합인가? . True . day2 &lt; day1 . False . &#47700;&#49548;&#46300; . - 합집합 . day1 = {&#39;notebook&#39;, &#39;desktop&#39;} day2 = {&#39;notebook&#39;,&#39;ipad&#39;} . day1.union(day2) . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . - 나머지 메소드는 스스로 찾아보세요 . for&#47928; . day1 = {&#39;notebook&#39;, &#39;desktop&#39;} day2 = {&#39;notebook&#39;,&#39;ipad&#39;} . for i in day1|day2: print(i) . ipad notebook desktop . &#49689;&#51228; . 길이가 4인 집합을 두개만들고 공통원소를 2개로 설정한뒤 합집합을 구하는 코드를 작성하라. .",
            "url": "https://guebin.github.io/IP2022/2022/03/23/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9423%EC%9D%BC.html",
            "relUrl": "/2022/03/23/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9423%EC%9D%BC.html",
            "date": " • Mar 23, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "(3주차) 3월21일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/7) 튜플을 쓰는 이유 . - (2/7) 인덱스고급: 스트라이딩 (1) . - (3/7) 인덱스고급: 스트라이딩 (2) . - (4/7) 컴프리헨션고급 (if문이 포함된 컴프리헨션) . - (5/7) 함수고급 (조건부리턴), len함수 . - (6/7) summary of str/list/tupel, 딕셔너리 (모티브, 선언, 원소추출, 원소추가, 원소변경, 삭제) . - (7/7) 숙제설명 . some minor comments: str, list, tuple . (&#47532;&#49828;&#53944;&#44032; &#50500;&#45768;&#44256;) &#53916;&#54540;&#51012; &#50416;&#45716; &#51060;&#50976; . - 책의 설명 (이 설명이 꼭 파이썬에 한정되는 것은 아님. 모든 언어에 존재하는 불변형 객체에 적용가능한 설명) . 실수방지 | 빠르다, 다중작업에 유리하다, 여러사람과 작업하기에 유리하다, 깊은복사/얕은복사시 원하지않는 오류(side effect이라고 함)를 방지할 수 있다, 메모리관리에도 유리함... | 느낌: 불변형은 기능제한이 있는데 가볍고 빠른, 가변형은 기능은 풍부하지만 약간 느리고 무거운 느낌임 (불변형:라면사리, 가변형:라면) | . - 내 설명 . 튜플의 장점은 소괄호의 생략에 있음 (이것은 파이썬과 줄리아만 가능) | 이것이 언패킹구문과 결합하여 어마무시한 가독성을 제공 | . def mycal(a,b): return a+b, a-b, a*b, a/b #여러개의 값을 리턴하는듯 보임. -&gt; 사실은 길이가 4인 튜플 1개를 리턴 . mycal(2,3) . (5, -1, 6, 0.6666666666666666) . _, _, mulrslt, _ = mycal(2,3) # 병렬할당 . mulrslt . 6 . - 의문: 왜 튜플만 괄호를 생략할 수 있지? . - 내망상 . 튜플을 먼저 만들고, 괄호를 생략하는 문법을 추가한것은 아닐것임 | 원래 괄호없이 컴마만 대충찍어서 선언가능한 아주간단한 타입의 벡터형을 만들고 싶었을 것임. | 왜? 괄호없는 벡터를 만들고 + 언패킹을 사용하면 여러가지 구문들이 엄청나게 간단해짐. | 컴마컴마로 선언하는 벡터는 한 두번 쓰고 버리는 경우가 많으며 대부분 이름도 필요없음 $ to$ 원소에 접근해서 sorting하여 순서를 바꾸고 싶다던가 원소를 추가할 이유가 없음 $ to$ 비싼 가변형으로 만들 이유가 없다는 것.. | 우리가 필요한것: 데이터가 벡터의 형태로 모여있기만 하면 된다! | . - 다른사람들 의견 (컴공과 인터뷰) . 튜플 + 언패킹에 충격 $ to$ 파이썬 편하더라.. | . &#51064;&#45937;&#49905;&#44256;&#44553; (&#49828;&#53944;&#46972;&#51060;&#46377;) . - 스트라이딩 [start:stop:step] . lst = list(&#39;abcdefgh&#39;) lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst[0:8:2] . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . - 생략 . lst[::2] . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . lst[0::2] . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . lst[:8:2] . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . - 예제: 짝수/홀수 원소 추출 . lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst[::2] # 1,3,5,7, ... . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . lst[1::2] # 2,4,6,8, ... . [&#39;b&#39;, &#39;d&#39;, &#39;f&#39;, &#39;h&#39;] . - step = -1 이면? . lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst[::-1] . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . reverse와 같은 기능 | . (reverse)와 비교 . 관찰1: reverse 메소드는 리스트 자체를 변화시킴 . lst = list(&#39;abcdefgh&#39;) lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst.reverse() #리버스는 lst . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . 관찰2: [::-1]는 리스트는 변화시키지 않음 . lst = list(&#39;abcdefgh&#39;) lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst[::-1] . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . - 사실 -step은 쓰는 것이 조금 까다롭다. . (예제) 처음과 끝을 생략하지 않고 아래와 동일한 효과를 주는 코드를 만들어 보자. . lst = list(&#39;abcdefgh&#39;) lst[::-1] . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . (풀이) . 결국 lst[?:?:-1]의 꼴에서 적당히 ?의 값을 채우면 된다. . lst[-1::-1] # 일단 첫 시작은 제일 마지막 원소 . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . lst[-1:0:-1] # 앗 마지막 인덱스는 포함 안되는거였지? . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;] . lst[-1:-1:-1] # 앗 마지막 인덱스는 포함 안되는거였지? . [] . 잠깐 인덱스를 생각해보자. . a b c d e f g h . 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | . -8 | -7 | -6 | -5 | -4 | -3 | -2 | -1 | . lst[-1:-9:-1] # 아.. . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . (예제) . lst[2::2] . [&#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . lst[-2::-2] . [&#39;g&#39;, &#39;e&#39;, &#39;c&#39;, &#39;a&#39;] . lst[-2:2:2] . [] . lst[2:2:2] . [] . lst[2:2:-2] . [] . 결론: -step을 자주 쓰진 말자? . &#52980;&#54532;&#47532;&#54760;&#49496; &#44256;&#44553; (if&#47928;&#51060; &#54252;&#54632;&#46108; &#52980;&#54532;&#47532;&#54760;&#49496;) . - 예제: 제곱수중에서 12로 나누어 떨어지는 수만 원소로 가지는 리스트를 만들고 싶다. . 제곱수: 1,4,9,16,25,36, ... | 12로 나누어 떨어지는 수: 36, ... | . (예비학습) . 12 % 4 # %는 나머지를 계산하는 연산자, 12를 4로 나누면 나머지가 0 . 0 . 12 % 5 # %는 나머지를 계산하는 연산자, 12를 5로 나누면 나머지가 2 . 2 . (풀이1) . lst = [] for i in range(1,101): if (i**2 % 12 == 0): lst.append(i**2) . lst . [36, 144, 324, 576, 900, 1296, 1764, 2304, 2916, 3600, 4356, 5184, 6084, 7056, 8100, 9216] . (풀이2) . [i**2 for i in range(1,101) if (i**2 % 12 == 0)] . [36, 144, 324, 576, 900, 1296, 1764, 2304, 2916, 3600, 4356, 5184, 6084, 7056, 8100, 9216] . &#54632;&#49688;&#44256;&#44553; (&#51312;&#44148;&#48512;&#47532;&#53556;) . - 홀수/짝수를 판별하는 함수 만들기 1 . def test(a): if a % 2 ==0: return &#39;even&#39; else: return &#39;odd&#39; . test(1) . &#39;odd&#39; . test(2) . &#39;even&#39; . test(3) . &#39;odd&#39; . test(4) . &#39;even&#39; . [test(a) for a in range(1,11)] . [&#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;] . - 홀수/짝수를 판별하는 함수 만들기 2 . def test(a): return &#39;even&#39; if a%2 ==0 else &#39;odd&#39; . test(3) . &#39;odd&#39; . [test(a) for a in range(1,11)] . [&#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;] . len&#54632;&#49688; . - 0차원 자료형은 len함수가 동작하지 않음 . a=1 len(a) . TypeError Traceback (most recent call last) Input In [44], in &lt;cell line: 2&gt;() 1 a=1 -&gt; 2 len(a) TypeError: object of type &#39;int&#39; has no len() . a=True len(a) . TypeError Traceback (most recent call last) Input In [45], in &lt;cell line: 2&gt;() 1 a=True -&gt; 2 len(a) TypeError: object of type &#39;bool&#39; has no len() . a=3.14 len(a) . TypeError Traceback (most recent call last) Input In [46], in &lt;cell line: 2&gt;() 1 a=3.14 -&gt; 2 len(a) TypeError: object of type &#39;float&#39; has no len() . . Note: 이것이 어떠한 수학적인 의미를 가지거나 0차원의 본질적진리를 뜻하는 것은 안미. R에서는 1,3.14,TRUE의 길이가 1로 존재함. . - 1차원 자료형은 len함수가 동작 . a=&#39;guebin&#39; len(a) . 6 . a=[1,2,3,4,5,6] len(a) . 6 . a=1,2,3,4,5,6 len(a) . 6 . a=range(10) len(a) . 10 . - 길이가 1인 1차원 자료형과 0차원 자료형은 다른것임 . a=&#39;g&#39; len(a) . 1 . a=[1] len(a) . 1 . a=(1,) len(a) . 1 . a=range(1) len(a) . 1 . - 길이가 0인 1차원 자료형도 존재함 . a=&#39;&#39; len(a) . 0 . a=[] len(a) . 0 . a=() len(a) . 0 . a=range(0) len(a) . 0 . summary: str, list, tuple . - str, list, tuple은 모두 시퀀스형이라는 공통점이 있다. $ to$ 원소의 위치번호로 인덱싱이 가능 . lst = [1,2,3,4] . lst[0] # 위치번호=0 . 1 . lst[-1] # 위치번호=-1 . 4 . - str, list, tuple은 차이점도 존재함. 잠깐 정리해보자. . 시퀀스형의 카테고리 . 컨테니어형: list, tuple | 균일형: str | 가변형: list | 불변형: tuple, str | . 표로 정리하면 . 컨테니어형 균일형 . 가변형 | list | . | . 불변형 | tuple | str | . - 시퀀스형이 아닌 1차원 자료형도 있을까? 원소의 위치번호로 인덱싱이 불가능한 자료형 . - 왜 이런게 필요할까? . 벡터에서 원소를 뽑는것은 정보의 모임에서 정보를 검색하는 것과 같다. | 정보를 순서대로 나열한뒤에 그 순서를 이용하여 검색하는 방법은 유용하다. | 하지만 경우에 따라서는 키워드를 기억해서 그 키워드를 바탕으로 정보에 접근하는 방법이 유용할 수 있다. | . 카카오톡 대화내용검색 . (상황1) 오늘아침에 와이프가 뭔가를 카톡으로 부탁했었음. 그런데 그 뭔가가 기억안남. . (상황2) 개강전에 동료교수와 함께 저녁약속을 카톡으로 잡았었음. 그런데 그게 언제인지 기억안남. . (상황3) 오늘아침 동료교수와 함께 점심약속을 카톡으로 잡았었음. 그런데 그 장소가 기억나지 않음. . - 순서대로 정리된 자료를 검색할때는 시퀀스형이 유리하다. 그런데 키워드로 검색하고 싶을 경우는 딕셔너리 타입이 유리하다. . &#46357;&#49492;&#45320;&#47532; . &#49440;&#50616; . - 방법1 . score={&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . type(score) . dict . - 방법2 . score=dict(guebin=49, iu=80) score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . type(score) . dict . - 방법3 . _lst = [[&#39;guebin&#39;,49],[&#39;iu&#39;,80]] _lst . [[&#39;guebin&#39;, 49], [&#39;iu&#39;, 80]] . dict(_lst) . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . - 방법4 . _tpl = (&#39;guebin&#39;,49), (&#39;iu&#39;,80) _tpl . ((&#39;guebin&#39;, 49), (&#39;iu&#39;, 80)) . dict(_tpl) . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . &#50896;&#49548;&#52628;&#52636; . score = {&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . guebin의 점수를 추출하고 싶다면? . score[0] # 이렇게 뽑는것이 아니고! . KeyError Traceback (most recent call last) Input In [71], in &lt;cell line: 1&gt;() -&gt; 1 score[0] KeyError: 0 . score[&#39;guebin&#39;] . 49 . - 리스트로 저장했다면? . score=[[&#39;guebin&#39;,49],[&#39;iu&#39;,80]] score . [[&#39;guebin&#39;, 49], [&#39;iu&#39;, 80]] . guebin의 점수를 추출하고 싶다면? . (방법1) . score[0][1] # guebin의 점수를 출력하란 의미 . 49 . (방법2) . _keys = [score[i][0] for i in range(len(score))] # 리스트컴프리헨션 _keys . [&#39;guebin&#39;, &#39;iu&#39;] . [score[i][1] for i in range(len(score)) if score[i][0] ==&#39;guebin&#39; ] . [49] . 어지럽죠? | . &#50896;&#49548;&#52628;&#44032;, &#48320;&#44221;, &#49325;&#51228; . score={&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . - 원소에 접근 . score[&#39;guebin&#39;] . 49 . - 추가 . score[&#39;hynn&#39;] = 99 # 추가 score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80, &#39;hynn&#39;: 99} . - 변경 . score[&#39;iu&#39;] = 99 # 변경 score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 99, &#39;hynn&#39;: 99} . - 삭제 . (방법1) . score={&#39;guebin&#39;:49, &#39;iu&#39;:80, &#39;hynn&#39;:99} del score[&#39;guebin&#39;] score . {&#39;iu&#39;: 80, &#39;hynn&#39;: 99} . (방법2) . score={&#39;guebin&#39;:49, &#39;iu&#39;:80, &#39;hynn&#39;:99} score.pop(&#39;guebin&#39;) . 49 . score . {&#39;iu&#39;: 80, &#39;hynn&#39;: 99} . - 참고로 리스트였다면 이러한 삭제작업역시 비효율적이었을 것임 . score = [[&#39;guebin&#39;,49],[&#39;iu&#39;,80],[&#39;hynn&#39;,99]] score . [[&#39;guebin&#39;, 49], [&#39;iu&#39;, 80], [&#39;hynn&#39;, 99]] . score = [[key,val] for key,val in score if key != &#39;guebin&#39;] score . [[&#39;iu&#39;, 80], [&#39;hynn&#39;, 99]] . (숙제) 길이가 4인 dictionary를 생성 . len 함수를 이용하여 길이를 측정 | key를 이용하여 각 원소에 접근하여 보기 | .",
            "url": "https://guebin.github.io/IP2022/2022/03/21/(3%EC%A3%BC%EC%B0%A8)-3%EC%9B%9421%EC%9D%BC.html",
            "relUrl": "/2022/03/21/(3%EC%A3%BC%EC%B0%A8)-3%EC%9B%9421%EC%9D%BC.html",
            "date": " • Mar 21, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "(3주차) 3월16일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2) 튜플, 슬기롭게 튜플 사용하기 (1) . - (2/2) 슬기롭게 튜플 사용하기 (2) . &#53916;&#54540; . &#47532;&#49828;&#53944; vs &#53916;&#54540; . - 컨테이너형타입이라는 점, 그리고 연산 및 인덱싱을 하는 방법은 리스트와 같음 . 차이점1: [] 대신에 ()를 사용한다. | 차이점2: 불변형이다. (원소의 값을 바꿀 수 없음) | 차이점3: 하나의 원소를 선언할 때는 (1,)와 같이 해야 한다. | 차이점4: 의미가 명확할때는 튜플의 ()를 생략가능하다. | . - 컨테이너형이라는 것이 무슨의미? . a=(4,6,&#39;pencil&#39;, 3.2+4.6j, [3,4]) . type(a[2]) . str . type(a[3]) . complex . - 불변형이라는 것은 무슨의미? . a[2] = &#39;Pencil&#39; . TypeError Traceback (most recent call last) Input In [13], in &lt;cell line: 1&gt;() -&gt; 1 a[2] = &#39;Pencil&#39; TypeError: &#39;tuple&#39; object does not support item assignment . 참고로 a를 튜플이 아니라 리스트로 선언하면 값이 잘 바뀐다. . a=[4,6,&#39;pencil&#39;, 3.2+4.6j, [3,4]] . a[2] . &#39;pencil&#39; . a[2]=&#39;Pencil&#39; . a . [4, 6, &#39;Pencil&#39;, (3.2+4.6j), [3, 4]] . - 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야 함. . [1]+[2,3,4] . [1, 2, 3, 4] . (1,)+(2,3,4) . (1, 2, 3, 4) . - 마지막차이점! 의미가 명확할때 튜플의 괄호는 생략가능하다. (이게 중요합니다) . a=1,2 a . (1, 2) . 의미가 명확할때 생략해야함 . 1,2 + 3,4,5 . (1, 5, 4, 5) . (1,2) + (3,4,5) . (1, 2, 3, 4, 5) . &#49440;&#50616; . - 소괄호를 이용 . a=(1,2,3) a . (1, 2, 3) . type(a) . tuple . - 생략가능하다는 점이 포인트 . a=1,2,3 a . (1, 2, 3) . type(a) . tuple . - 원소가 하나인 튜플을 만들고 싶다면? . a=(1,) a . (1,) . &#50672;&#49328; . - 리스트와 동일 . (1,2)+(3,4,5) . (1, 2, 3, 4, 5) . (1,2)*2 . (1, 2, 1, 2) . &#51064;&#45937;&#49905; . - 리스트와 동일 . a=(1,2,3,-4,-5) a . (1, 2, 3, -4, -5) . a[-1] . -5 . a[-3:] . (3, -4, -5) . &#53916;&#54540;&#44256;&#44553; . &#53916;&#54540;&#51012; &#50780; &#48520;&#48320;&#54805;&#51004;&#47196; &#47564;&#46308;&#50632;&#51012;&#44620;? . 책의설명: 실수로 값을 변경할 수 있도록 방지할 수 있다. | shallow copy / deep copy 를 막을 수 있는 무기 | . &#53916;&#54540;&#51012; &#49836;&#44592;&#47213;&#44172; &#49324;&#50857;&#54616;&#45716; &#48169;&#48277; ($ star star star star star$) . - 예제: 여러변수를 동시에 출력하고 싶을 경우 (다중출력?) . 변수를 아래와 같이 선언하였다고 하자. . a=1 b=2 c=3 . 선언된 값을 확인하려면? . a . 1 . b . 2 . c . 3 . 튜플을 이용하면? . a,b,c # 괄호하나 생략하는것이 이렇게 편하다.. . (1, 2, 3) . - 예제: 다중할당1 (여러개의 변수를 동시에 선언하고 싶을 경우) . name, age, sex, height, weight = &#39;Tom&#39;, 20, &#39;M&#39;, 180, 70 . name, age, sex, height, weight . (&#39;Tom&#39;, 20, &#39;M&#39;, 180, 70) . height . 180 . - 예제: 다중할당2, 위도와 경도 . coor = (37,127) # 서울 coor . (37, 127) . lat, long = coor . lat . 37 . long . 127 . - 잠깐만: 다중할당은 꼭 튜플에서만 가능한가? . 그건 아니다... . [x,y,z] = [1,2,3] x,y,z # 다중출력 . (1, 2, 3) . [x,y] = &#39;hi&#39; x,y . (&#39;h&#39;, &#39;i&#39;) . 튜플과 같이 사용하면 가독성이 극대화 (그래서 다중할당은 거의 튜플과 세트로 사용함) . x,y,z = 1,2,3 x,y,z # 다중출력 . (1, 2, 3) . x,y = &#39;hi&#39; x,y . (&#39;h&#39;, &#39;i&#39;) . - 예제: 임시변수 사용없이 두 변수의 값을 교환 . a=10 b=20 . a,b = b,a . a . 20 . b . 10 . - 예제: for문과 튜플 . lst = [[&#39;guebin&#39;, 202112345, &#39;M&#39;], [&#39;iu&#39;,202254321, &#39;F&#39;], [&#39;hodong&#39;, 202011223, &#39;M&#39;]] lst . [[&#39;guebin&#39;, 202112345, &#39;M&#39;], [&#39;iu&#39;, 202254321, &#39;F&#39;], [&#39;hodong&#39;, 202011223, &#39;M&#39;]] . for i in lst: print(i) . [&#39;guebin&#39;, 202112345, &#39;M&#39;] [&#39;iu&#39;, 202254321, &#39;F&#39;] [&#39;hodong&#39;, 202011223, &#39;M&#39;] . for name,studentid,sex in lst: print(name) . guebin iu hodong . for name,studentid,sex in lst: print(name,sex) . guebin M iu F hodong M . - 예제: for문과 튜플, dummy variable _ . for name,studentid,sex in lst: print(studentid) . 202112345 202254321 202011223 . for _,studentid,_ in lst: print(studentid) . 202112345 202254321 202011223 . for _,_,sex in lst: print(sex) . M F M . for name,_,sex in lst: print(name,sex) . guebin M iu F hodong M . for name,_ in lst: print(name) . ValueError Traceback (most recent call last) Input In [88], in &lt;cell line: 1&gt;() -&gt; 1 for name,_ in lst: 2 print(name) ValueError: too many values to unpack (expected 2) . for name,*args in lst: print(name) . guebin iu hodong . - 예제: 튜플과 언패킹연산자 * . head, body, *tail = range(1,11) head, body, tail . (1, 2, [3, 4, 5, 6, 7, 8, 9, 10]) . head1,head2, *body, tail1,tail2,tail3 = range(1,11) head1,head2, body, tail1,tail2,tail3 . (1, 2, [3, 4, 5, 6, 7], 8, 9, 10) . *head, body, tail = range(1,11) head, body, tail . ([1, 2, 3, 4, 5, 6, 7, 8], 9, 10) . (관찰) . 그러고 보니까.. . head1,head2, body, tail1,tail2,tail3 = (1, 2, [3,4,5,6,7], 8, 9, 10) head1,head2, *body, tail1,tail2,tail3 = (1, 2, 3,4,5,6,7, 8, 9, 10) . 이렇다는 거잖아? . *를 붙이면 1차원 자료구조가 풀린다..? . *[1,2,3] . Input In [103] *[1,2,3] ^ SyntaxError: can&#39;t use starred expression here . print([1,2,3]) . [1, 2, 3] . print(*[1,2,3]) ## 이런 느낌이란 말이지.. . 1 2 3 . - 예제: 함수의 입력으로 *args를 넣을때 . [예비학습] 함수 벼락치기 . def myadd(a,b): return a+b . myadd(3,-3) . 0 . 벼락치기 끝 . 예제시작: 두점 사이의 거리를 구하는 함수를 만들어 보자. . 점 $p=(p_x,p_y)$와 $q=(q_x,q_y)$의 거리는 $ sqrt{(p_x-q_x)^2+(p_y-q_y)^2}$이다. 이것을 계산하는 프로그램을 만들자. . import numpy as np def dist(px,py,qx,qy): return np.sqrt((px-qx)**2 + (py-qy)**2) . p=(0,3) q=(4,0) dist(p,q) . TypeError Traceback (most recent call last) Input In [119], in &lt;cell line: 3&gt;() 1 p=(0,3) 2 q=(4,0) -&gt; 3 dist(p,q) TypeError: dist() missing 2 required positional arguments: &#39;qx&#39; and &#39;qy&#39; . (방법1) . px,py = (0,3) qx,qy = (4,0) dist(px,py,qx,qy) . 5.0 . (방법2) . def dist2(p,q): px,py = p qx,qy = q return np.sqrt((px-qx)**2 + (py-qy)**2) ### 이건 나쁜 생각이에요.. # def dist2(p,q): # px=p[0] # py=p[1] # qx=q[0] # qy=q[1] # return np.sqrt((px-qx)**2 + (py-qy)**2) . p=(0,3) q=(4,0) dist2(p,q) . 5.0 . (방법3) . dist(*p,*q) # 입력을 *(px,py), *(qx,qy) 형태로 넣기도하고.. . 5.0 . dist(px,py,qx,qy) # 입력을 px,py,qx,qy 형태로 넣기도하고.. . 5.0 . (숙제) 원소로 자기학번을 포함하는 튜플을 만들어서 제출 (길이가 1인 튜플을 만들어서 제출) .",
            "url": "https://guebin.github.io/IP2022/2022/03/16/(3%EC%A3%BC%EC%B0%A8)-3%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2022/03/16/(3%EC%A3%BC%EC%B0%A8)-3%EC%9B%9416%EC%9D%BC.html",
            "date": " • Mar 16, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "(2주차) 3월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 리스트의 선언 및 연산 (1) . - (2/8) 리스트의 선언 및 연산 (2) ; 넘파이패키지 . - (3/8) 컨테이너형객체, 가변객체 . - (4/8) 리스트자료형의 메소드 . - (5/8) 중첩리스트; for문 (1) . - (6/8) for문 (2) . - (7/8) 리스트컴프리헨션 . - (8/8) 숙제설명 . list . &#49440;&#50616; . - 리스트의 선언 . a=[11,22] a . [11, 22] . type(a) . list . - 비어있는 리스트의 선언 . a=[] # 방법1 a . [] . a=list() # 방법2 a . [] . &#50672;&#49328; . - 더하기연산 . a=[11,12] b=[12,13] . a . [11, 12] . b . [12, 13] . a+b . [11, 12, 12, 13] . 우리의 예상과 다른 결과가 나옴 $ to$ 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있지 않음. | . - 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음. . a=[1,2,3] b=1 a+b . TypeError Traceback (most recent call last) Input In [9], in &lt;module&gt; 1 a=[1,2,3] 2 b=1 -&gt; 3 a+b TypeError: can only concatenate list (not &#34;int&#34;) to list . - 뺄셈은 정의되지 않음 . a=[1,2] b=[1,2] a-b . TypeError Traceback (most recent call last) Input In [10], in &lt;module&gt; 1 a=[1,2] 2 b=[1,2] -&gt; 3 a-b TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . - 곱하기는 정의가능 . a=[1,2] . 2*a # a+a . [1, 2, 1, 2] . - 나눗셈은 정의되지 않음 . a=[1,2,1,2] a/2 . TypeError Traceback (most recent call last) Input In [13], in &lt;module&gt; 1 a=[1,2,1,2] -&gt; 2 a/2 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . - 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄셈과 나눗셈이 원소의 삭제를 의미하는것은 아님 . a=[1,2,3] a-[3] # 이런건 없다 . TypeError Traceback (most recent call last) Input In [14], in &lt;module&gt; 1 a=[1,2,3] -&gt; 2 a-[3] TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . a=[1,2,1,2,1,2] a/3 # 이런건 없다 . TypeError Traceback (most recent call last) Input In [15], in &lt;module&gt; 1 a=[1,2,1,2,1,2] -&gt; 2 a/3 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . - 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, * 를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까? . (예제) . a=[1,2] b=[3,4] . a+b = [4,6] 이 되도록 하려면? . (풀이1) . a[0]+b[0] # a의 첫번째 원소를 추출, b의 첫번째 원소를 추출, 둘을 더함 . 4 . a[1]+b[1] # a의 두번째 원소를 추출, b의 두번째 원소를 추출, 둘을 더함 . 6 . [a[0]+b[0],a[1]+b[1]] . [4, 6] . 풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1] 은 각각 인트형임. 인트형은 + 연산이 가능했음. . (풀이2) . numpy 패키지 (파이썬의 여러 수치연산들을 담당하는 라이브러리) . 이러한 벡터연산은 누구나 필요로 하는 연산임. | 내가 아니더라도 누군가가 프로그램화 해놓았을 것임. | 그 누군가가 자신이 만든 코드를 잘 정리하여 무료로 배포했을 수도 있음. (패키지를 배포한다고 표현) | 그 패키지를 우리는 가져와서 설치한뒤 사용하기만 하면된다. | . 패키지를 설치하는 방법 . !pip install numpy # 최신버전을 설치함 | !conda install -c conda-forge numpy -y # 안전한 버전을 설치함 | . 설치된 패키지를 사용하는 방법 . import numpy 한뒤에 numpy.??로 기능을 사용 | import numpy as np 한뒤에 np.??로 기능을 사용 | . import numpy ## 설치한패키지를 쓰겠다고 선언함 . a=[1,2] b=[3,4] . aa=numpy.array(a) bb=numpy.array(b) # aa,bb는 리스트가 아니라 넘파이 어레이, # numpy.array()는 numpy패키지에서 제공하는 array함수를 쓰겠다는 의미. . aa+bb . array([4, 6]) . 이런것도 가능 . 2*aa . array([2, 4]) . 2*aa+1 . array([3, 5]) . 2*aa+1+bb . array([6, 9]) . (풀이3) . import numpy as np ## 설치한 numpy라는 패키지를 쓰겠음. 그런데 numpy말고 np라는 이름으로 쓰겠음 . a=[1,2] b=[3,4] np.array(a)+np.array(b) . array([4, 6]) . &#51064;&#45937;&#49905; . - str형과 동일한 방식 . a=[11,22,33,44,55] # 0 -4 -3 -2 -1 . a[-2:] # 끝의 2개의 원소를 뽑음 . [44, 55] . list &#44256;&#44553; . &#53080;&#53580;&#51060;&#45320;&#54805; &#44061;&#52404;, &#44032;&#48320;&#44061;&#52404; . - 리스트의 원소는 int, float 따위만 가능한 것이 아니다. (리스트는 컨테이너형 객체이므로) . lst = [1,3.14,True,&#39;a&#39;,[1,2], (1,2),{&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:27},{1,2,3}] . lst . [1, 3.14, True, &#39;a&#39;, [1, 2], (1, 2), {&#39;name&#39;: &#39;iu&#39;, &#39;age&#39;: 27}, {1, 2, 3}] . 각 원소의 타입을 알아보자. . type(lst[0]) . int . type(lst[1]) . float . type(lst[2]) . bool . type(lst[3]) . str . type(lst[4]) . list . type(lst[5]) . tuple . type(lst[6]) . dict . type(lst[7]) . set . - str은 컨테이너형이 아니다. . &#39;abcd&#39;[2] . &#39;c&#39; . str의 모든 원소는 문자임 | . - 리스트의 원소를 수정할 수 있다. (리스트는 가변객체이므로) . a=[11,22,33] a . [11, 22, 33] . a[0] . 11 . a[0]=111 . a . [111, 22, 33] . - 원소수정은 당연한 기능같은데 이것이 불가능한 경우도 있다. . (가능한경우) . a=[&#39;g&#39;,&#39;u&#39;,&#39;e&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;] a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . a[0] . &#39;g&#39; . a[0]=&#39;G&#39; . a . [&#39;G&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . (불가능한경우) . a=&#39;guebin&#39; a . &#39;guebin&#39; . a[0] . &#39;g&#39; . a[0]=&#39;G&#39; . TypeError Traceback (most recent call last) Input In [109], in &lt;module&gt; -&gt; 1 a[0]=&#39;G&#39; TypeError: &#39;str&#39; object does not support item assignment . - 리스트 원소 삭제 . (예제) . 아래와 같이 문자로 된 리스트를 선언하자. . a=[&#39;g&#39;,&#39;u&#39;,&#39;e&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;] a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 사실 더 쉽게 선언할 수 있음 . a= &#39;guebin&#39; # string으로 a를 선언 a= list(a) # list(a)를 통하여 str을 ㅣist로 변환 -&gt; 그 결과를 a에 다시 저장 a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 첫번째 원소를 삭제하고 싶다면? . del a[0] . a . [&#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 이 상태에서 다시 첫번쨰 원소를 삭제한다면? . del a[0] . a . [&#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . - 리스트의 원소 추가 . (예제) 비어있는 리스트를 만들고 원소 0,1,2를 차례로 추가하여 보자. . (풀이1) . a=[] a . [] . a= a + [0] a . [0] . a= a + [1] a . [0, 1] . a= a + [2] a . [0, 1, 2] . (풀이2) . a=[] a . [] . a += [0] a . [0] . a += [1] a . [0, 1] . a += [2] a . [0, 1, 2] . 암기법: 중복되는 변수를 지우고 연산자의 순서를 바꾼다. | . (풀이3) 리스트 특화기능(=메소드)를 이용 . a=[] a . [] . a.append(0) a . [0] . a.append(1) a . [0, 1] . a.append(2) a . [0, 1, 2] . - a+[4]와 a.append(4)의 차이점은? . (관찰1) . a=[1,2,3] a+[4] ## 리스트 a와 리스트 [4]의 연산결과를 알려줘 . [1, 2, 3, 4] . a ## a는 그대로임. 변화없음 . [1, 2, 3] . (관찰2) . a=[1,2,3] a.append(4) . a ## a자체가 변화함 . [1, 2, 3, 4] . 비슷해보이지만 굉장히 미묘한 차이가 있음 . a.append(4): a에 4를 append하라 $ to$ a가 변함 . a+[4]: a와 4를 연산하라 . &#47700;&#49548;&#46300; (&#47532;&#49828;&#53944; &#51088;&#47308;&#54805;&#50640; &#53945;&#54868;&#46108; &#53945;&#49688;&#54620; &#54632;&#49688;&#46308;) . (append) . a=[1,2,3,4] a.append? . Signature: a.append(object, /) Docstring: Append object to the end of the list. Type: builtin_function_or_method . a.append(5) a . [1, 2, 3, 4, 5] . (clear) . a=[1,2,3,4] a.clear? . Signature: a.clear() Docstring: Remove all items from list. Type: builtin_function_or_method . a.clear() a . [] . (copy) . a=[1,2,3,4] a.copy? . Signature: a.copy() Docstring: Return a shallow copy of the list. Type: builtin_function_or_method . b=a.copy() b . [1, 2, 3, 4] . (count) . a=[1,1,2,3,3,4,4,4] a.count? . Signature: a.count(value, /) Docstring: Return number of occurrences of value. Type: builtin_function_or_method . a.count(1) . 2 . a.count(2) . 1 . a.count(3) . 2 . a.count(4) . 3 . (extend) . a=[1,2,3,4] b=[-1,-2,-3,-4] . a.extend(b) a . [1, 2, 3, 4, -1, -2, -3, -4] . a=[1,2,3,4] b=[-1,-2,-3,-4] . a.append(b) . a . [1, 2, 3, 4, [-1, -2, -3, -4]] . (index) . a=[11,22,&#39;a&#39;,True, 22,&#39;a&#39;] a.index? . Signature: a.index(value, start=0, stop=9223372036854775807, /) Docstring: Return first index of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a.index(11) . 0 . a.index(22) . 1 . a.index(&#39;a&#39;) . 2 . a.index(True) . 3 . (insert) . a=[1,2,3] a.insert? . Signature: a.insert(index, object, /) Docstring: Insert object before index. Type: builtin_function_or_method . a.insert(1,88) a . [1, 88, 2, 3] . (pop) . a=[&#39;a&#39;,1,2,&#39;d&#39;] a.pop? . Signature: a.pop(index=-1, /) Docstring: Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. Type: builtin_function_or_method . a.pop() # index=-1 이므로 마지막원소가 나타남 . &#39;d&#39; . a # a는 마지막 원소가 사라진 상태 . [&#39;a&#39;, 1, 2] . a.pop(0) # index=0 이므로 첫번쨰 원소가 나타남 . &#39;a&#39; . a # a에는 첫번째 원소가 사라진 상태 . [1, 2] . (remove) . a=[&#39;a&#39;,2,3,&#39;d&#39;] a.remove? . Signature: a.remove(value, /) Docstring: Remove first occurrence of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a.remove(&#39;d&#39;) . a . [&#39;a&#39;, 2, 3] . a.remove(&#39;a&#39;) . a . [2, 3] . (reverse) . a=[1,2,3,4] a.reverse? . Signature: a.reverse() Docstring: Reverse *IN PLACE*. Type: builtin_function_or_method . a.reverse() a . [4, 3, 2, 1] . (sort) . a=[1,3,2,4] a.sort? . Signature: a.sort(*, key=None, reverse=False) Docstring: Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. Type: builtin_function_or_method . a.sort() a . [1, 2, 3, 4] . (다른예제들) . a=list(&#39;guebin&#39;) a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . a.sort() a . [&#39;b&#39;, &#39;e&#39;, &#39;g&#39;, &#39;i&#39;, &#39;n&#39;, &#39;u&#39;] . a.sort(reverse=True) a . [&#39;u&#39;, &#39;n&#39;, &#39;i&#39;, &#39;g&#39;, &#39;e&#39;, &#39;b&#39;] . &#51473;&#52393;&#47532;&#49828;&#53944; . A=[[1,2,3],[4,5,6],[7,8,9]] A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . - A는 아래와 같은 매트릭스로 이해할 수 있다 . $ bf{A}= begin{bmatrix} 1 &amp; 2 &amp; 3 4 &amp; 5 &amp; 6 7 &amp; 8 &amp; 9 end{bmatrix} $ . - A에서 (2,1)의 원소를 뽑고싶다 = 4를 뽑고싶다 . A[1,0] . TypeError Traceback (most recent call last) Input In [279], in &lt;module&gt; -&gt; 1 A[1,0] TypeError: list indices must be integers or slices, not tuple . 실패 | . A[1][0] . 4 . 성공 | . - 성공의 이유를 분석해보자. . A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . A[1] . [4, 5, 6] . A[1][0] . 4 . - 매트릭스는 아니지만 매트릭스 같음! . 1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함 | . &#47532;&#49828;&#53944;&#52980;&#54532;&#47532;&#54760;&#49496;($ star star star$) . - 리스트 컴프리헨션을 이해하기 전에 for문에 대하여 알아보자. . [예비학습] for문 벼락치기 . 프로그램안에서 반복해서 무엇인가를 하고싶다 $ to$ for . for i in [0,1,2,3]: ## 반복실행계획 print(i) ## 반복실행할내용, 탭을이용하여 들여쓰기해야한다. . 0 1 2 3 . (예제) 1,2,3,4의 합을 for문을 이용하여 구해보자. . _sum = 0 for i in [1,2,3,4]: _sum = _sum + i . _sum . 10 . _sum = 0 i=1 _sum = _sum + i ## 1 &lt;= 0+1 i=2 _sum = _sum + i ## 3 &lt;= 1+2 i=3 _sum = _sum + i ## 6 &lt;= 3+3 i=4 _sum = _sum + i ## 10 &lt;= 6+4 . _sum . 10 . 예비학습끝 . - 예제: $2^0, 2^1, 2^2, 2^3$를 원소로 가지는 리스트를 생성하라. . (풀이1) 직접입력 . x= [2**0, 2**1, 2**2, 2**3] x . [1, 2, 4, 8] . (풀이2) for문을 이용함 . x=[] for i in [0,1,2,3]: x.append(2**i) . x . [1, 2, 4, 8] . (풀이3) for문을 이용함 . x=[] for i in [0,1,2,3]: x = x+[2**i] . x . [1, 2, 4, 8] . (풀이4) for문을 이용함 . x=[] for i in [0,1,2,3]: x += [2**i] . x . [1, 2, 4, 8] . (풀이5) 리스트컴프리헨션을 이용한 풀이 . x= [2**i for i in [0,1,2,3]] x . [1, 2, 4, 8] . - 리스트컴프리헨션의 문법 암기방법 . 집합에서 조건제시법을 연상 | $ {2^0,2^1,2^2,2^3 }= {2^i: i in {0,1,2,3 } }$ | . - 리스트컴프리헨션이란? . 리스트를 매우 효율적으로 만드는 테크닉 | for문에 비하여 가지고 있는 장점: (1) 코드가 간결하다 (2) 빠르다 | . - 예제: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;SSSS&#39;,&#39;PPPP&#39;,&#39;AAAA&#39;,&#39;MMMM&#39;] . [&#39;SSSS&#39;, &#39;PPPP&#39;, &#39;AAAA&#39;, &#39;MMMM&#39;] . (풀이) . [i*4 for i in &#39;SPAM&#39;] . [&#39;SSSS&#39;, &#39;PPPP&#39;, &#39;AAAA&#39;, &#39;MMMM&#39;] . - 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;Y1&#39;,&#39;Y2&#39;,&#39;Y3&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . (풀이) . [i+j for i in &#39;XY&#39; for j in &#39;123&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . - 예제: 리스트컴프리헨션을 이용하여 통계1,...,통계5,수학1,...,수학5를 만들어라. . (풀이) . [x+y for x in [&#39;stat&#39;,&#39;math&#39;] for y in &#39;12345&#39;] . [&#39;stat1&#39;, &#39;stat2&#39;, &#39;stat3&#39;, &#39;stat4&#39;, &#39;stat5&#39;, &#39;math1&#39;, &#39;math2&#39;, &#39;math3&#39;, &#39;math4&#39;, &#39;math5&#39;] . $ {xy : x in {stat,math }, y in {1,2,3,4,5 } }$ | . (다른풀이) 참고로 for문을 쓰면 좀 복잡해진다. . _lst = [] for x in [&#39;stat&#39;,&#39;math&#39;]: for y in &#39;12345&#39;: _lst = _lst + [x+y] . _lst . [&#39;stat1&#39;, &#39;stat2&#39;, &#39;stat3&#39;, &#39;stat4&#39;, &#39;stat5&#39;, &#39;math1&#39;, &#39;math2&#39;, &#39;math3&#39;, &#39;math4&#39;, &#39;math5&#39;] . - 예제: &#39;jbnu&#39;를 이용하여 아래와 같은 리스트를 만들어라. (리스트컴프리헨션을 이용할것) . [&#39;j&#39;,&#39;b&#39;,&#39;n&#39;,&#39;u&#39;] . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . (다른풀이) 아래와 같이 풀면 된다는것은 알고 있음 . list(&#39;jbnu&#39;) . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . (풀이) . [x for x in &#39;jbnu&#39;] . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . - 예제: x에는 무엇이 있을까? . (경우1) . x=1 lst = [] for x in &#39;jbnu&#39;: lst = lst + [x] lst . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . x . &#39;u&#39; . (경우2) . x=1 lst = [x for x in &#39;jbnu&#39;] lst . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . x . 1 . 진짜 미묘하게 다르죠? | . - 예제: [X1,X2,X3,...,X100]와 같은 리스트를 만들어보라. . (풀이) . [&#39;X&#39;+str(i) for i in [1,2,3,4]] ## 이걸 4까지가 아니라 100까지 써야함 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;] . [&#39;X&#39;+str(i) for i in 1:100] . Input In [432] [&#39;X&#39;+str(i) for i in 1:100] ^ SyntaxError: invalid syntax . [예비학습] . range(0,10) . range(0, 10) . 이게뭐야? | . _tmp = range(0,10) _tmp? . Type: range String form: range(0, 10) Length: 10 Docstring: range(stop) -&gt; range object range(start, stop[, step]) -&gt; range object Return an object that produces a sequence of integers from start (inclusive) to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. These are exactly the valid indices for a list of 4 elements. When step is given, it specifies the increment (or decrement). . 우리가 아는 범위에서는 모르겠음.. 이런게 있나보다 하고 넘어가야 하겠음 | . list(range(0,10)) # 0을 포함, 10을 미포함 . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 이게 중요한것임. range(0,10)를 리스트화시키면 [0,1,2,...,9] 와 같은 리스트를 얻을 수 있음. | . list(range(10)) # 0은 생략가능 . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . list(range(2,10)) # 2는 포함, 10은 미포함 . [2, 3, 4, 5, 6, 7, 8, 9] . list(range(1,10,2)) # 2는 포함, 10은 미포함 . [1, 3, 5, 7, 9] . 예비학습 끝 . [&#39;X&#39;+str(i) for i in list(range(1,13))] ## 출력결과가 너무 기니까 101대신에 13으로 변경 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;, &#39;X5&#39;, &#39;X6&#39;, &#39;X7&#39;, &#39;X8&#39;, &#39;X9&#39;, &#39;X10&#39;, &#39;X11&#39;, &#39;X12&#39;] . (아래와 같은 풀이도 가능) . [&#39;X&#39;+str(i) for i in range(1,13)] ## 출력결과가 너무 기니까 101대신에 13으로 변경 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;, &#39;X5&#39;, &#39;X6&#39;, &#39;X7&#39;, &#39;X8&#39;, &#39;X9&#39;, &#39;X10&#39;, &#39;X11&#39;, &#39;X12&#39;] . (딴생각) 생각해보니까 for문 뒤에 올수 있는것이 무엇인지 생각하는것도 흥미로울듯 . for i in &#39;1234&#39;: print(i) . 1 2 3 4 . for i in [1,2,3,4]: print(i) . 1 2 3 4 . for i in (1,2,3,4): # (1,2,3,4)는 튜플 print(i) . 1 2 3 4 . for i in {1,2,3,4}: # {1,2,3,4}는 set print(i) . 1 2 3 4 . for i in {&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:28}: #{&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:28} 는 딕셔너리 print(i) . name age . for i in range(1,5): print(i) . 1 2 3 4 . (숙제) . 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;X1&#39;,&#39;X2X2&#39;,&#39;X3X3X3&#39;,&#39;X4X4X4X4&#39;,&#39;X5X5X5X5X5&#39;] . [&#39;X1&#39;, &#39;X2X2&#39;, &#39;X3X3X3&#39;, &#39;X4X4X4X4&#39;, &#39;X5X5X5X5X5&#39;] .",
            "url": "https://guebin.github.io/IP2022/2022/03/14/(2%EC%A3%BC%EC%B0%A8)-3%EC%9B%9414%EC%9D%BC.html",
            "relUrl": "/2022/03/14/(2%EC%A3%BC%EC%B0%A8)-3%EC%9B%9414%EC%9D%BC.html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "(1주차) 3월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 아나콘다 설치, 가상환경 생성 . - (2/8) 주피터랩 설치 및 실행 (1) . - (3/8) 주피터랩 설치 및 실행 (2) . - (4/8) 0차원자료형: int, float, bool, 명시적형변환 . - (5/8) 0차원자료형: 암묵적형변환 . - (6/8) string (1) . - (7/8) string (2) . - (8/8) 숙제설명, 코랩설명 . - appendix: 윈도우에 영어계정만들기 . &#54028;&#51060;&#50028; &#44368;&#51116; . - 전자교재 . https://docs.python.org/3.9/tutorial/index.html | https://wikidocs.net/book/1 | https://jakevdp.github.io/PythonDataScienceHandbook/ | . - 종이책 . 효율적 개발로 이끄는 파이썬 실천 기술 | Learning python: powerful object-oriented programming | 전문가를 위한 파이썬 : 파이썬3 버전 기준 | 간단하고, 명료하고, 효율적인 파이썬 프로그래밍 | . &#51452;&#54588;&#53552;&#45432;&#53944;&#48513;, &#51452;&#54588;&#53552;&#47017; . - interactive notebook이 아니다. . a=3 a . 3 . b=3 b . 3 . a+b . 5 . - 주피터랩: 주피터노트북의 확장버전 . 저는 주피터랩을 더 선호합니다. | 그런데 주피터노트북을 쓸 경우도 있음. | . - 마크다운모드(글쓰기모드), 코드모드(프로그래밍모드) . &#51088;&#47308;&#54805; . - 파이썬의 기본자료형은 int, float, bool, str, list, tuple, dict, set 등이 있다. . 0차원 자료형: int, float, bool | 1차원 자료형: str, list, tuple, dict, set | . int, float, bool . - int형 . a=100 . type(a) . int . - float형 . a=1.2*3 a . 3.5999999999999996 . type(a) . float . a? . Type: float String form: 3.5999999999999996 Docstring: Convert a string or number to a floating point number, if possible. . - bool형 . a=True ## 숫자1으로 생각할 수 있음 b=False ## 숫자0으로 생각할 수 있음 . type(a) . bool . type(b) . bool . a? . Type: bool String form: True Docstring: bool(x) -&gt; bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed. . b? . Type: bool String form: False Docstring: bool(x) -&gt; bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed. . - bool형의 연산 . a=True ## 1 b=False ## 0 . a+b . 1 . a*b . 0 . - complex형 . a=1+2j b=2-2j . type(a) . complex . type(b) . complex . a? . Type: complex String form: (1+2j) Docstring: Create a complex number from a real part and an optional imaginary part. This is equivalent to (real + imag*1j) where imag defaults to 0. . b? . Type: complex String form: (2-2j) Docstring: Create a complex number from a real part and an optional imaginary part. This is equivalent to (real + imag*1j) where imag defaults to 0. . c=a+b . c . (3+0j) . - 형태변환: float $ to$ int . (예시1) . a=3.0 type(a) . float . a=int(a) . type(a) . int . (예시2) 이경우는 정보의 손실이 발생 . a=3.14 int(a) . 3 . - 형태변환: int $ to$ float . a=3 type(a) . int . a=float(a) type(a) . float . - 형태변환: bool $ to$ int/float, int/float $ to$ bool . (예시1) . a=True type(a) . bool . int(a) . 1 . float(a) . 1.0 . (예시2) . a=1 bool(a) . True . a=0 bool(a) . False . (예시3) . a=1.0 bool(a) . True . a=0.0 bool(a) . False . - 이상한 형태변환도 가능하다. (이런것도 바꿔주나 싶은것도 바꿔줌) . bool(-3.14) . True . 저는 이런 코드를 의도적으로 사용하지 않아요.. | . int(3.14) . 3 . - 형태변환이 항상가능한것도 아님 . float(3+0j) # 사실상 3+0j=3 이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 변환불가능하다. . TypeError Traceback (most recent call last) Input In [78], in &lt;module&gt; -&gt; 1 float(3+0j) TypeError: can&#39;t convert complex to float . - 암묵적형변환 (implicit) . (예비학습) implicit의 의미 . 추운날씨 -&gt; 보일러좀 틀자! (explicit) / 오늘 날씨 좀 추운 것 같지 않아? (implicit) | 짜장면 먹을래? -&gt; 싫어! (explicit) / 난 어제 짜장면 먹었는데.. (implicit) | . (예제) . True * 1 # 1을 곱할건데 너 계속 True로 있을꺼야? . 1 . 1 * 1.0 # 1.0을 곱할건데 너 계속 int로 있을꺼야? . 1.0 . True+True # +연산을 할건데 계속 True로 있을꺼야? . 2 . str . - 선언 . a=&#39;guebin&#39; . a . &#39;guebin&#39; . &#50672;&#49328; . - 더하기(+)연산 . a=&#39;X&#39; b=&#39;2&#39; . c=a+b c . &#39;X2&#39; . - 빼기(-)연산 . a=&#39;X2&#39; b=&#39;2&#39; a-b . TypeError Traceback (most recent call last) Input In [92], in &lt;module&gt; 1 a=&#39;X2&#39; 2 b=&#39;2&#39; -&gt; 3 a-b TypeError: unsupported operand type(s) for -: &#39;str&#39; and &#39;str&#39; . 이런건 없다. | . - 곱하기(*)연산 . a=&#39;X&#39; . a+a+a . &#39;XXX&#39; . a*3 # a*3 = a+a+a = &#39;X&#39;+&#39;X+&#39;X&#39; . &#39;XXX&#39; . 아래도 가능하다. . 3*a . &#39;XXX&#39; . 그리고 아래도 가능하다. . a=&#39;X&#39; b=3 a*b . &#39;XXX&#39; . 대신에 의미상 맞지 않는 것은 수행되지 않고 에러가 난다. . a=&#39;X&#39; b=&#39;Y&#39; a+b . &#39;XY&#39; . a*b . TypeError Traceback (most recent call last) Input In [99], in &lt;module&gt; -&gt; 1 a*b TypeError: can&#39;t multiply sequence by non-int of type &#39;str&#39; . - 나눗셈(/)연산 . a=&#39;XX&#39; . a/2 . TypeError Traceback (most recent call last) Input In [101], in &lt;module&gt; -&gt; 1 a/2 TypeError: unsupported operand type(s) for /: &#39;str&#39; and &#39;int&#39; . 이런건 없다.. | . &#51064;&#45937;&#49905; . - str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하면 된다. . a=&#39;guebin&#39; . a . &#39;guebin&#39; . 6개의 칸에 글씨가 하나씩 들어가 있음. | . - 대괄호 []안에 숫자를 넣는 방식으로 벡터의 원소를 호출할 수 있다. (주의: 인덱스가 0부터 시작함) . a[0] #첫번째원소 . &#39;g&#39; . a[1] #두번째원소 . &#39;u&#39; . 마지막원소는 -1로 호출할 수도 있다. . a[-1] . &#39;n&#39; . 마지막에서 2번째 원소는 -2로 호출가능하다. . a[-2] . &#39;i&#39; . - 요약하면 아래와 같은 방식으로 호출가능함. . g u e b i n . 0 | 1 | 2 | 3 | 4 | 5 | . 0 | -5 | -4 | -3 | -2 | -1 | . a[4] . &#39;i&#39; . a[-2] . &#39;i&#39; . a[-4] . &#39;e&#39; . - :을 이용하여 여러개의 원소를 호출할 수 있음. . a=&#39;guebin&#39; . a[0:3] # a[0],a[1],a[2],a[3]이 아니라 a[0],a[1],a[2]까지만 뽑힌다. 즉 마지막의 3은 호출되지 않는다. . &#39;gue&#39; . a[1:3] # a[1], a[2] 만 호출 // start=1, stop=3 . &#39;ue&#39; . index=1부터 시작해서 마지막원소까지 호출하려면? . a[5] # guebin의 마지막원소 &#39;n&#39;이 출려 . &#39;n&#39; . a[1:5] # 5는 포함되지 않으므로 틀림 . &#39;uebi&#39; . a[1:6] # 정답 . &#39;uebin&#39; . 안 헷갈리는 방법은 없을까? . a[-1] . &#39;n&#39; . a[1:-1] # 이것은 결국 (a[1:5]와 같은 것임) . &#39;uebi&#39; . 해결책? 생략한다!! . a[1:] . &#39;uebin&#39; . - 생략의 응용1 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[2:5] . &#39;pop&#39; . a[2:] . &#39;pop&#39; . - 생략의 응용2 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[0:2] # a[0],a[1] . &#39;k-&#39; . a[:2] # a[0],a[1] . &#39;k-&#39; . - 생략의 응용3 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[0:5] # a[0],...,a[4] . &#39;k-pop&#39; . a[:] . &#39;k-pop&#39; . str &#53945;&#49688;&#44592;&#45733; . - 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다. . a=&#39;ABCD&#39; # a라는 변수는 &#39;ABCD&#39;라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다. a . &#39;ABCD&#39; . a.lower() # a.lower()를 쓰면 a의 모든 문자를 소문자로 바꾸는 기능을 제공, lower(a)라고 읽자! . &#39;abcd&#39; . 여기에서 lower()는 문자열에 특화된 기능임. 따라서 당연히 아래는 불가능 . a=3.14 a.lower() # lower(a) . AttributeError Traceback (most recent call last) Input In [194], in &lt;module&gt; 1 a=3.14 -&gt; 2 a.lower() AttributeError: &#39;float&#39; object has no attribute &#39;lower&#39; . - 자료형에 특화된 기능(=함수)을 확인하는 방법? a.+ tab 으로 목록 확인 가능 . a=&#39;guebin&#39; . a.upper? . Signature: a.upper() Docstring: Return a copy of the string converted to uppercase. Type: builtin_function_or_method . a.upper() # upper(a) . &#39;GUEBIN&#39; . a.capitalize() # capitalize(a) . &#39;Guebin&#39; . - 문자열에 대한 다른 내용들은 추후에 다루겠음. . - 마음의눈: a.f() 형태를 읽는 팁 . a.f()는 f(a)로 생각하면 편리함. | a.f(2)는 f(a,2)로 생각하면 편리함. | 이런점에서 R %&gt;% 연산자와 비슷하다고 생각할 수 있다. (약간 다르긴함) | . - 사실 .은 좀 더 다양한 상황에서 쓰일 수 있다. 변수이름.함수이름() 의 형태가 아니라 . 패지키이름.함수이름() | 패키지이름.변수이름 | 패키지이름.패키지이름.함수이름() | ... | . 와 같이 다양한 형태가 가능하다. 근본적인 공통점은 .을 기준으로 상위개념.하위개념 으로 이해하는 것이 좋다. . 0&#52264;&#50896; vs 1&#52264;&#50896; . - len함수 소개: 원소의 갯수를 알려주는 함수. . (0차원) len 함수가 동작하지 않음. . a=3.14 . len(a) . TypeError Traceback (most recent call last) Input In [197], in &lt;module&gt; -&gt; 1 len(a) TypeError: object of type &#39;float&#39; has no len() . b=True . len(b) . TypeError Traceback (most recent call last) Input In [201], in &lt;module&gt; -&gt; 1 len(b) TypeError: object of type &#39;bool&#39; has no len() . (1차원) len 함수가 잘 동작함. . a=&#39;3.14&#39; len(a) . 4 . b=[1,2,3] . len(b) . 3 . &#49689;&#51228; . 본인이름으로 str을 생성 $ to$ LMS에 스크린샷제출 . 성만 출력 | 이름만 출려 | . (예시) . a=&#39;GuebinChoi&#39; . a[:6] . &#39;Guebin&#39; . a[6:] . &#39;Choi&#39; .",
            "url": "https://guebin.github.io/IP2022/2022/03/07/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2022/03/07/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%947%EC%9D%BC.html",
            "date": " • Mar 7, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "(1주차) 3월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . .",
            "url": "https://guebin.github.io/IP2022/2022/03/02/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2022/03/02/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%942%EC%9D%BC.html",
            "date": " • Mar 2, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기",
            "content": "About this doc . - 본 포스트는 2021년 1학기 Python 입문 강의내용중 일부를 업로드 하였음. . - Github, fastpages를 사용하여 블로그를 개설하고 관리하는 방법에 대한 설명임. . .",
            "url": "https://guebin.github.io/IP2022/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "relUrl": "/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "date": " • Aug 17, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "최규빈 . guebin@jbnu.ac.kr | 자연과학대학교 본관 205호 | 카카오톡 오픈채널 1 | . 2022년 1학기 종료후 폐쇄예정 &#8617; . |",
          "url": "https://guebin.github.io/IP2022/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/IP2022/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}