{
  
    
        "post0": {
            "title": "(2주차) 3월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 리스트의 선언 및 연산 (1) . - (2/8) 리스트의 선언 및 연산 (2) ; 넘파이패키지 . - (3/8) 컨테이너형객체, 가변객체 . - (4/8) 리스트자료형의 메소드 . - (5/8) 중첩리스트; for문 (1) . - (6/8) for문 (2) . - (7/8) 리스트컴프리헨션 . - (8/8) 숙제설명 . list . &#49440;&#50616; . - 리스트의 선언 . a=[11,22] a . [11, 22] . type(a) . list . - 비어있는 리스트의 선언 . a=[] # 방법1 a . [] . a=list() # 방법2 a . [] . &#50672;&#49328; . - 더하기연산 . a=[11,12] b=[12,13] . a . [11, 12] . b . [12, 13] . a+b . [11, 12, 12, 13] . 우리의 예상과 다른 결과가 나옴 $ to$ 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있지 않음. | . - 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음. . a=[1,2,3] b=1 a+b . TypeError Traceback (most recent call last) Input In [9], in &lt;module&gt; 1 a=[1,2,3] 2 b=1 -&gt; 3 a+b TypeError: can only concatenate list (not &#34;int&#34;) to list . - 뺄셈은 정의되지 않음 . a=[1,2] b=[1,2] a-b . TypeError Traceback (most recent call last) Input In [10], in &lt;module&gt; 1 a=[1,2] 2 b=[1,2] -&gt; 3 a-b TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . - 곱하기는 정의가능 . a=[1,2] . 2*a # a+a . [1, 2, 1, 2] . - 나눗셈은 정의되지 않음 . a=[1,2,1,2] a/2 . TypeError Traceback (most recent call last) Input In [13], in &lt;module&gt; 1 a=[1,2,1,2] -&gt; 2 a/2 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . - 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄셈과 나눗셈이 원소의 삭제를 의미하는것은 아님 . a=[1,2,3] a-[3] # 이런건 없다 . TypeError Traceback (most recent call last) Input In [14], in &lt;module&gt; 1 a=[1,2,3] -&gt; 2 a-[3] TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . a=[1,2,1,2,1,2] a/3 # 이런건 없다 . TypeError Traceback (most recent call last) Input In [15], in &lt;module&gt; 1 a=[1,2,1,2,1,2] -&gt; 2 a/3 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . - 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, * 를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까? . (예제) . a=[1,2] b=[3,4] . a+b = [4,6] 이 되도록 하려면? . (풀이1) . a[0]+b[0] # a의 첫번째 원소를 추출, b의 첫번째 원소를 추출, 둘을 더함 . 4 . a[1]+b[1] # a의 두번째 원소를 추출, b의 두번째 원소를 추출, 둘을 더함 . 6 . [a[0]+b[0],a[1]+b[1]] . [4, 6] . 풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1] 은 각각 인트형임. 인트형은 + 연산이 가능했음. . (풀이2) . numpy 패키지 (파이썬의 여러 수치연산들을 담당하는 라이브러리) . 이러한 벡터연산은 누구나 필요로 하는 연산임. | 내가 아니더라도 누군가가 프로그램화 해놓았을 것임. | 그 누군가가 자신이 만든 코드를 잘 정리하여 무료로 배포했을 수도 있음. (패키지를 배포한다고 표현) | 그 패키지를 우리는 가져와서 설치한뒤 사용하기만 하면된다. | . 패키지를 설치하는 방법 . !pip install numpy # 최신버전을 설치함 | !conda install -c conda-forge numpy -y # 안전한 버전을 설치함 | . 설치된 패키지를 사용하는 방법 . import numpy 한뒤에 numpy.??로 기능을 사용 | import numpy as np 한뒤에 np.??로 기능을 사용 | . import numpy ## 설치한패키지를 쓰겠다고 선언함 . a=[1,2] b=[3,4] . aa=numpy.array(a) bb=numpy.array(b) # aa,bb는 리스트가 아니라 넘파이 어레이, # numpy.array()는 numpy패키지에서 제공하는 array함수를 쓰겠다는 의미. . aa+bb . array([4, 6]) . 이런것도 가능 . 2*aa . array([2, 4]) . 2*aa+1 . array([3, 5]) . 2*aa+1+bb . array([6, 9]) . (풀이3) . import numpy as np ## 설치한 numpy라는 패키지를 쓰겠음. 그런데 numpy말고 np라는 이름으로 쓰겠음 . a=[1,2] b=[3,4] np.array(a)+np.array(b) . array([4, 6]) . &#51064;&#45937;&#49905; . - str형과 동일한 방식 . a=[11,22,33,44,55] # 0 -4 -3 -2 -1 . a[-2:] # 끝의 2개의 원소를 뽑음 . [44, 55] . list &#44256;&#44553; . &#53080;&#53580;&#51060;&#45320;&#54805; &#44061;&#52404;, &#44032;&#48320;&#44061;&#52404; . - 리스트의 원소는 int, float 따위만 가능한 것이 아니다. (리스트는 컨테이너형 객체이므로) . lst = [1,3.14,True,&#39;a&#39;,[1,2], (1,2),{&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:27},{1,2,3}] . lst . [1, 3.14, True, &#39;a&#39;, [1, 2], (1, 2), {&#39;name&#39;: &#39;iu&#39;, &#39;age&#39;: 27}, {1, 2, 3}] . 각 원소의 타입을 알아보자. . type(lst[0]) . int . type(lst[1]) . float . type(lst[2]) . bool . type(lst[3]) . str . type(lst[4]) . list . type(lst[5]) . tuple . type(lst[6]) . dict . type(lst[7]) . set . - str은 컨테이너형이 아니다. . &#39;abcd&#39;[2] . &#39;c&#39; . str의 모든 원소는 문자임 | . - 리스트의 원소를 수정할 수 있다. (리스트는 가변객체이므로) . a=[11,22,33] a . [11, 22, 33] . a[0] . 11 . a[0]=111 . a . [111, 22, 33] . - 원소수정은 당연한 기능같은데 이것이 불가능한 경우도 있다. . (가능한경우) . a=[&#39;g&#39;,&#39;u&#39;,&#39;e&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;] a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . a[0] . &#39;g&#39; . a[0]=&#39;G&#39; . a . [&#39;G&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . (불가능한경우) . a=&#39;guebin&#39; a . &#39;guebin&#39; . a[0] . &#39;g&#39; . a[0]=&#39;G&#39; . TypeError Traceback (most recent call last) Input In [109], in &lt;module&gt; -&gt; 1 a[0]=&#39;G&#39; TypeError: &#39;str&#39; object does not support item assignment . - 리스트 원소 삭제 . (예제) . 아래와 같이 문자로 된 리스트를 선언하자. . a=[&#39;g&#39;,&#39;u&#39;,&#39;e&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;] a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 사실 더 쉽게 선언할 수 있음 . a= &#39;guebin&#39; # string으로 a를 선언 a= list(a) # list(a)를 통하여 str을 ㅣist로 변환 -&gt; 그 결과를 a에 다시 저장 a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 첫번째 원소를 삭제하고 싶다면? . del a[0] . a . [&#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 이 상태에서 다시 첫번쨰 원소를 삭제한다면? . del a[0] . a . [&#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . - 리스트의 원소 추가 . (예제) 비어있는 리스트를 만들고 원소 0,1,2를 차례로 추가하여 보자. . (풀이1) . a=[] a . [] . a= a + [0] a . [0] . a= a + [1] a . [0, 1] . a= a + [2] a . [0, 1, 2] . (풀이2) . a=[] a . [] . a += [0] a . [0] . a += [1] a . [0, 1] . a += [2] a . [0, 1, 2] . 암기법: 중복되는 변수를 지우고 연산자의 순서를 바꾼다. | . (풀이3) 리스트 특화기능(=메소드)를 이용 . a=[] a . [] . a.append(0) a . [0] . a.append(1) a . [0, 1] . a.append(2) a . [0, 1, 2] . - a+[4]와 a.append(4)의 차이점은? . (관찰1) . a=[1,2,3] a+[4] ## 리스트 a와 리스트 [4]의 연산결과를 알려줘 . [1, 2, 3, 4] . a ## a는 그대로임. 변화없음 . [1, 2, 3] . (관찰2) . a=[1,2,3] a.append(4) . a ## a자체가 변화함 . [1, 2, 3, 4] . 비슷해보이지만 굉장히 미묘한 차이가 있음 . a.append(4): a에 4를 append하라 $ to$ a가 변함 . a+[4]: a와 4를 연산하라 . &#47700;&#49548;&#46300; (&#47532;&#49828;&#53944; &#51088;&#47308;&#54805;&#50640; &#53945;&#54868;&#46108; &#53945;&#49688;&#54620; &#54632;&#49688;&#46308;) . (append) . a=[1,2,3,4] a.append? . Signature: a.append(object, /) Docstring: Append object to the end of the list. Type: builtin_function_or_method . a.append(5) a . [1, 2, 3, 4, 5] . (clear) . a=[1,2,3,4] a.clear? . Signature: a.clear() Docstring: Remove all items from list. Type: builtin_function_or_method . a.clear() a . [] . (copy) . a=[1,2,3,4] a.copy? . Signature: a.copy() Docstring: Return a shallow copy of the list. Type: builtin_function_or_method . b=a.copy() b . [1, 2, 3, 4] . (count) . a=[1,1,2,3,3,4,4,4] a.count? . Signature: a.count(value, /) Docstring: Return number of occurrences of value. Type: builtin_function_or_method . a.count(1) . 2 . a.count(2) . 1 . a.count(3) . 2 . a.count(4) . 3 . (extend) . a=[1,2,3,4] b=[-1,-2,-3,-4] . a.extend(b) a . [1, 2, 3, 4, -1, -2, -3, -4] . a=[1,2,3,4] b=[-1,-2,-3,-4] . a.append(b) . a . [1, 2, 3, 4, [-1, -2, -3, -4]] . (index) . a=[11,22,&#39;a&#39;,True, 22,&#39;a&#39;] a.index? . Signature: a.index(value, start=0, stop=9223372036854775807, /) Docstring: Return first index of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a.index(11) . 0 . a.index(22) . 1 . a.index(&#39;a&#39;) . 2 . a.index(True) . 3 . (insert) . a=[1,2,3] a.insert? . Signature: a.insert(index, object, /) Docstring: Insert object before index. Type: builtin_function_or_method . a.insert(1,88) a . [1, 88, 2, 3] . (pop) . a=[&#39;a&#39;,1,2,&#39;d&#39;] a.pop? . Signature: a.pop(index=-1, /) Docstring: Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. Type: builtin_function_or_method . a.pop() # index=-1 이므로 마지막원소가 나타남 . &#39;d&#39; . a # a는 마지막 원소가 사라진 상태 . [&#39;a&#39;, 1, 2] . a.pop(0) # index=0 이므로 첫번쨰 원소가 나타남 . &#39;a&#39; . a # a에는 첫번째 원소가 사라진 상태 . [1, 2] . (remove) . a=[&#39;a&#39;,2,3,&#39;d&#39;] a.remove? . Signature: a.remove(value, /) Docstring: Remove first occurrence of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a.remove(&#39;d&#39;) . a . [&#39;a&#39;, 2, 3] . a.remove(&#39;a&#39;) . a . [2, 3] . (reverse) . a=[1,2,3,4] a.reverse? . Signature: a.reverse() Docstring: Reverse *IN PLACE*. Type: builtin_function_or_method . a.reverse() a . [4, 3, 2, 1] . (sort) . a=[1,3,2,4] a.sort? . Signature: a.sort(*, key=None, reverse=False) Docstring: Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. Type: builtin_function_or_method . a.sort() a . [1, 2, 3, 4] . (다른예제들) . a=list(&#39;guebin&#39;) a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . a.sort() a . [&#39;b&#39;, &#39;e&#39;, &#39;g&#39;, &#39;i&#39;, &#39;n&#39;, &#39;u&#39;] . a.sort(reverse=True) a . [&#39;u&#39;, &#39;n&#39;, &#39;i&#39;, &#39;g&#39;, &#39;e&#39;, &#39;b&#39;] . &#51473;&#52393;&#47532;&#49828;&#53944; . A=[[1,2,3],[4,5,6],[7,8,9]] A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . - A는 아래와 같은 매트릭스로 이해할 수 있다 . $ bf{A}= begin{bmatrix} 1 &amp; 2 &amp; 3 4 &amp; 5 &amp; 6 7 &amp; 8 &amp; 9 end{bmatrix} $ . - A에서 (2,1)의 원소를 뽑고싶다 = 4를 뽑고싶다 . A[1,0] . TypeError Traceback (most recent call last) Input In [279], in &lt;module&gt; -&gt; 1 A[1,0] TypeError: list indices must be integers or slices, not tuple . 실패 | . A[1][0] . 4 . 성공 | . - 성공의 이유를 분석해보자. . A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . A[1] . [4, 5, 6] . A[1][0] . 4 . - 매트릭스는 아니지만 매트릭스 같음! . 1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함 | . &#47532;&#49828;&#53944;&#52980;&#54532;&#47532;&#54760;&#49496;($ star star star$) . - 리스트 컴프리헨션을 이해하기 전에 for문에 대하여 알아보자. . [예비학습] for문 벼락치기 . 프로그램안에서 반복해서 무엇인가를 하고싶다 $ to$ for . for i in [0,1,2,3]: ## 반복실행계획 print(i) ## 반복실행할내용, 탭을이용하여 들여쓰기해야한다. . 0 1 2 3 . (예제) 1,2,3,4의 합을 for문을 이용하여 구해보자. . _sum = 0 for i in [1,2,3,4]: _sum = _sum + i . _sum . 10 . _sum = 0 i=1 _sum = _sum + i ## 1 &lt;= 0+1 i=2 _sum = _sum + i ## 3 &lt;= 1+2 i=3 _sum = _sum + i ## 6 &lt;= 3+3 i=4 _sum = _sum + i ## 10 &lt;= 6+4 . _sum . 10 . 예비학습끝 . - 예제: $2^0, 2^1, 2^2, 2^3$를 원소로 가지는 리스트를 생성하라. . (풀이1) 직접입력 . x= [2**0, 2**1, 2**2, 2**3] x . [1, 2, 4, 8] . (풀이2) for문을 이용함 . x=[] for i in [0,1,2,3]: x.append(2**i) . x . [1, 2, 4, 8] . (풀이3) for문을 이용함 . x=[] for i in [0,1,2,3]: x = x+[2**i] . x . [1, 2, 4, 8] . (풀이4) for문을 이용함 . x=[] for i in [0,1,2,3]: x += [2**i] . x . [1, 2, 4, 8] . (풀이5) 리스트컴프리헨션을 이용한 풀이 . x= [2**i for i in [0,1,2,3]] x . [1, 2, 4, 8] . - 리스트컴프리헨션의 문법 암기방법 . 집합에서 조건제시법을 연상 | $ {2^0,2^1,2^2,2^3 }= {2^i: i in {0,1,2,3 } }$ | . - 리스트컴프리헨션이란? . 리스트를 매우 효율적으로 만드는 테크닉 | for문에 비하여 가지고 있는 장점: (1) 코드가 간결하다 (2) 빠르다 | . - 예제: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;SSSS&#39;,&#39;PPPP&#39;,&#39;AAAA&#39;,&#39;MMMM&#39;] . [&#39;SSSS&#39;, &#39;PPPP&#39;, &#39;AAAA&#39;, &#39;MMMM&#39;] . (풀이) . [i*4 for i in &#39;SPAM&#39;] . [&#39;SSSS&#39;, &#39;PPPP&#39;, &#39;AAAA&#39;, &#39;MMMM&#39;] . - 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;Y1&#39;,&#39;Y2&#39;,&#39;Y3&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . (풀이) . [i+j for i in &#39;XY&#39; for j in &#39;123&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . - 예제: 리스트컴프리헨션을 이용하여 통계1,...,통계5,수학1,...,수학5를 만들어라. . (풀이) . [x+y for x in [&#39;stat&#39;,&#39;math&#39;] for y in &#39;12345&#39;] . [&#39;stat1&#39;, &#39;stat2&#39;, &#39;stat3&#39;, &#39;stat4&#39;, &#39;stat5&#39;, &#39;math1&#39;, &#39;math2&#39;, &#39;math3&#39;, &#39;math4&#39;, &#39;math5&#39;] . $ {xy : x in {stat,math }, y in {1,2,3,4,5 } }$ | . (다른풀이) 참고로 for문을 쓰면 좀 복잡해진다. . _lst = [] for x in [&#39;stat&#39;,&#39;math&#39;]: for y in &#39;12345&#39;: _lst = _lst + [x+y] . _lst . [&#39;stat1&#39;, &#39;stat2&#39;, &#39;stat3&#39;, &#39;stat4&#39;, &#39;stat5&#39;, &#39;math1&#39;, &#39;math2&#39;, &#39;math3&#39;, &#39;math4&#39;, &#39;math5&#39;] . - 예제: &#39;jbnu&#39;를 이용하여 아래와 같은 리스트를 만들어라. (리스트컴프리헨션을 이용할것) . [&#39;j&#39;,&#39;b&#39;,&#39;n&#39;,&#39;u&#39;] . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . (다른풀이) 아래와 같이 풀면 된다는것은 알고 있음 . list(&#39;jbnu&#39;) . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . (풀이) . [x for x in &#39;jbnu&#39;] . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . - 예제: x에는 무엇이 있을까? . (경우1) . x=1 lst = [] for x in &#39;jbnu&#39;: lst = lst + [x] lst . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . x . &#39;u&#39; . (경우2) . x=1 lst = [x for x in &#39;jbnu&#39;] lst . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . x . 1 . 진짜 미묘하게 다르죠? | . - 예제: [X1,X2,X3,...,X100]와 같은 리스트를 만들어보라. . (풀이) . [&#39;X&#39;+str(i) for i in [1,2,3,4]] ## 이걸 4까지가 아니라 100까지 써야함 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;] . [&#39;X&#39;+str(i) for i in 1:100] . Input In [432] [&#39;X&#39;+str(i) for i in 1:100] ^ SyntaxError: invalid syntax . [예비학습] . range(0,10) . range(0, 10) . 이게뭐야? | . _tmp = range(0,10) _tmp? . Type: range String form: range(0, 10) Length: 10 Docstring: range(stop) -&gt; range object range(start, stop[, step]) -&gt; range object Return an object that produces a sequence of integers from start (inclusive) to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. These are exactly the valid indices for a list of 4 elements. When step is given, it specifies the increment (or decrement). . 우리가 아는 범위에서는 모르겠음.. 이런게 있나보다 하고 넘어가야 하겠음 | . list(range(0,10)) # 0을 포함, 10을 미포함 . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 이게 중요한것임. range(0,10)를 리스트화시키면 [0,1,2,...,9] 와 같은 리스트를 얻을 수 있음. | . list(range(10)) # 0은 생략가능 . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . list(range(2,10)) # 2는 포함, 10은 미포함 . [2, 3, 4, 5, 6, 7, 8, 9] . list(range(1,10,2)) # 2는 포함, 10은 미포함 . [1, 3, 5, 7, 9] . 예비학습 끝 . [&#39;X&#39;+str(i) for i in list(range(1,13))] ## 출력결과가 너무 기니까 101대신에 13으로 변경 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;, &#39;X5&#39;, &#39;X6&#39;, &#39;X7&#39;, &#39;X8&#39;, &#39;X9&#39;, &#39;X10&#39;, &#39;X11&#39;, &#39;X12&#39;] . (아래와 같은 풀이도 가능) . [&#39;X&#39;+str(i) for i in range(1,13)] ## 출력결과가 너무 기니까 101대신에 13으로 변경 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;, &#39;X5&#39;, &#39;X6&#39;, &#39;X7&#39;, &#39;X8&#39;, &#39;X9&#39;, &#39;X10&#39;, &#39;X11&#39;, &#39;X12&#39;] . (딴생각) 생각해보니까 for문 뒤에 올수 있는것이 무엇인지 생각하는것도 흥미로울듯 . for i in &#39;1234&#39;: print(i) . 1 2 3 4 . for i in [1,2,3,4]: print(i) . 1 2 3 4 . for i in (1,2,3,4): # (1,2,3,4)는 튜플 print(i) . 1 2 3 4 . for i in {1,2,3,4}: # {1,2,3,4}는 set print(i) . 1 2 3 4 . for i in {&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:28}: #{&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:28} 는 딕셔너리 print(i) . name age . for i in range(1,5): print(i) . 1 2 3 4 . (숙제) . 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;X1&#39;,&#39;X2X2&#39;,&#39;X3X3X3&#39;,&#39;X4X4X4X4&#39;,&#39;X5X5X5X5X5&#39;] . [&#39;X1&#39;, &#39;X2X2&#39;, &#39;X3X3X3&#39;, &#39;X4X4X4X4&#39;, &#39;X5X5X5X5X5&#39;] .",
            "url": "https://guebin.github.io/IP2022/2022/03/14/(2%EC%A3%BC%EC%B0%A8)-3%EC%9B%9414%EC%9D%BC.html",
            "relUrl": "/2022/03/14/(2%EC%A3%BC%EC%B0%A8)-3%EC%9B%9414%EC%9D%BC.html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "(1주차) 3월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 아나콘다 설치, 가상환경 생성 . - (2/8) 주피터랩 설치 및 실행 (1) . - (3/8) 주피터랩 설치 및 실행 (2) . - (4/8) 0차원자료형: int, float, bool, 명시적형변환 . - (5/8) 0차원자료형: 암묵적형변환 . - (6/8) string (1) . - (7/8) string (2) . - (8/8) 숙제설명, 코랩설명 . - appendix: 윈도우에 영어계정만들기 . &#54028;&#51060;&#50028; &#44368;&#51116; . - 전자교재 . https://docs.python.org/3.9/tutorial/index.html | https://wikidocs.net/book/1 | https://jakevdp.github.io/PythonDataScienceHandbook/ | . - 종이책 . 효율적 개발로 이끄는 파이썬 실천 기술 | Learning python: powerful object-oriented programming | 전문가를 위한 파이썬 : 파이썬3 버전 기준 | 간단하고, 명료하고, 효율적인 파이썬 프로그래밍 | . &#51452;&#54588;&#53552;&#45432;&#53944;&#48513;, &#51452;&#54588;&#53552;&#47017; . - interactive notebook이 아니다. . a=3 a . 3 . b=3 b . 3 . a+b . 5 . - 주피터랩: 주피터노트북의 확장버전 . 저는 주피터랩을 더 선호합니다. | 그런데 주피터노트북을 쓸 경우도 있음. | . - 마크다운모드(글쓰기모드), 코드모드(프로그래밍모드) . &#51088;&#47308;&#54805; . - 파이썬의 기본자료형은 int, float, bool, str, list, tuple, dict, set 등이 있다. . 0차원 자료형: int, float, bool | 1차원 자료형: str, list, tuple, dict, set | . int, float, bool . - int형 . a=100 . type(a) . int . - float형 . a=1.2*3 a . 3.5999999999999996 . type(a) . float . a? . Type: float String form: 3.5999999999999996 Docstring: Convert a string or number to a floating point number, if possible. . - bool형 . a=True ## 숫자1으로 생각할 수 있음 b=False ## 숫자0으로 생각할 수 있음 . type(a) . bool . type(b) . bool . a? . Type: bool String form: True Docstring: bool(x) -&gt; bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed. . b? . Type: bool String form: False Docstring: bool(x) -&gt; bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed. . - bool형의 연산 . a=True ## 1 b=False ## 0 . a+b . 1 . a*b . 0 . - complex형 . a=1+2j b=2-2j . type(a) . complex . type(b) . complex . a? . Type: complex String form: (1+2j) Docstring: Create a complex number from a real part and an optional imaginary part. This is equivalent to (real + imag*1j) where imag defaults to 0. . b? . Type: complex String form: (2-2j) Docstring: Create a complex number from a real part and an optional imaginary part. This is equivalent to (real + imag*1j) where imag defaults to 0. . c=a+b . c . (3+0j) . - 형태변환: float $ to$ int . (예시1) . a=3.0 type(a) . float . a=int(a) . type(a) . int . (예시2) 이경우는 정보의 손실이 발생 . a=3.14 int(a) . 3 . - 형태변환: int $ to$ float . a=3 type(a) . int . a=float(a) type(a) . float . - 형태변환: bool $ to$ int/float, int/float $ to$ bool . (예시1) . a=True type(a) . bool . int(a) . 1 . float(a) . 1.0 . (예시2) . a=1 bool(a) . True . a=0 bool(a) . False . (예시3) . a=1.0 bool(a) . True . a=0.0 bool(a) . False . - 이상한 형태변환도 가능하다. (이런것도 바꿔주나 싶은것도 바꿔줌) . bool(-3.14) . True . 저는 이런 코드를 의도적으로 사용하지 않아요.. | . int(3.14) . 3 . - 형태변환이 항상가능한것도 아님 . float(3+0j) # 사실상 3+0j=3 이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 변환불가능하다. . TypeError Traceback (most recent call last) Input In [78], in &lt;module&gt; -&gt; 1 float(3+0j) TypeError: can&#39;t convert complex to float . - 암묵적형변환 (implicit) . (예비학습) implicit의 의미 . 추운날씨 -&gt; 보일러좀 틀자! (explicit) / 오늘 날씨 좀 추운 것 같지 않아? (implicit) | 짜장면 먹을래? -&gt; 싫어! (explicit) / 난 어제 짜장면 먹었는데.. (implicit) | . (예제) . True * 1 # 1을 곱할건데 너 계속 True로 있을꺼야? . 1 . 1 * 1.0 # 1.0을 곱할건데 너 계속 int로 있을꺼야? . 1.0 . True+True # +연산을 할건데 계속 True로 있을꺼야? . 2 . str . - 선언 . a=&#39;guebin&#39; . a . &#39;guebin&#39; . &#50672;&#49328; . - 더하기(+)연산 . a=&#39;X&#39; b=&#39;2&#39; . c=a+b c . &#39;X2&#39; . - 빼기(-)연산 . a=&#39;X2&#39; b=&#39;2&#39; a-b . TypeError Traceback (most recent call last) Input In [92], in &lt;module&gt; 1 a=&#39;X2&#39; 2 b=&#39;2&#39; -&gt; 3 a-b TypeError: unsupported operand type(s) for -: &#39;str&#39; and &#39;str&#39; . 이런건 없다. | . - 곱하기(*)연산 . a=&#39;X&#39; . a+a+a . &#39;XXX&#39; . a*3 # a*3 = a+a+a = &#39;X&#39;+&#39;X+&#39;X&#39; . &#39;XXX&#39; . 아래도 가능하다. . 3*a . &#39;XXX&#39; . 그리고 아래도 가능하다. . a=&#39;X&#39; b=3 a*b . &#39;XXX&#39; . 대신에 의미상 맞지 않는 것은 수행되지 않고 에러가 난다. . a=&#39;X&#39; b=&#39;Y&#39; a+b . &#39;XY&#39; . a*b . TypeError Traceback (most recent call last) Input In [99], in &lt;module&gt; -&gt; 1 a*b TypeError: can&#39;t multiply sequence by non-int of type &#39;str&#39; . - 나눗셈(/)연산 . a=&#39;XX&#39; . a/2 . TypeError Traceback (most recent call last) Input In [101], in &lt;module&gt; -&gt; 1 a/2 TypeError: unsupported operand type(s) for /: &#39;str&#39; and &#39;int&#39; . 이런건 없다.. | . &#51064;&#45937;&#49905; . - str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하면 된다. . a=&#39;guebin&#39; . a . &#39;guebin&#39; . 6개의 칸에 글씨가 하나씩 들어가 있음. | . - 대괄호 []안에 숫자를 넣는 방식으로 벡터의 원소를 호출할 수 있다. (주의: 인덱스가 0부터 시작함) . a[0] #첫번째원소 . &#39;g&#39; . a[1] #두번째원소 . &#39;u&#39; . 마지막원소는 -1로 호출할 수도 있다. . a[-1] . &#39;n&#39; . 마지막에서 2번째 원소는 -2로 호출가능하다. . a[-2] . &#39;i&#39; . - 요약하면 아래와 같은 방식으로 호출가능함. . g u e b i n . 0 | 1 | 2 | 3 | 4 | 5 | . 0 | -5 | -4 | -3 | -2 | -1 | . a[4] . &#39;i&#39; . a[-2] . &#39;i&#39; . a[-4] . &#39;e&#39; . - :을 이용하여 여러개의 원소를 호출할 수 있음. . a=&#39;guebin&#39; . a[0:3] # a[0],a[1],a[2],a[3]이 아니라 a[0],a[1],a[2]까지만 뽑힌다. 즉 마지막의 3은 호출되지 않는다. . &#39;gue&#39; . a[1:3] # a[1], a[2] 만 호출 // start=1, stop=3 . &#39;ue&#39; . index=1부터 시작해서 마지막원소까지 호출하려면? . a[5] # guebin의 마지막원소 &#39;n&#39;이 출려 . &#39;n&#39; . a[1:5] # 5는 포함되지 않으므로 틀림 . &#39;uebi&#39; . a[1:6] # 정답 . &#39;uebin&#39; . 안 헷갈리는 방법은 없을까? . a[-1] . &#39;n&#39; . a[1:-1] # 이것은 결국 (a[1:5]와 같은 것임) . &#39;uebi&#39; . 해결책? 생략한다!! . a[1:] . &#39;uebin&#39; . - 생략의 응용1 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[2:5] . &#39;pop&#39; . a[2:] . &#39;pop&#39; . - 생략의 응용2 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[0:2] # a[0],a[1] . &#39;k-&#39; . a[:2] # a[0],a[1] . &#39;k-&#39; . - 생략의 응용3 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[0:5] # a[0],...,a[4] . &#39;k-pop&#39; . a[:] . &#39;k-pop&#39; . str &#53945;&#49688;&#44592;&#45733; . - 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다. . a=&#39;ABCD&#39; # a라는 변수는 &#39;ABCD&#39;라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다. a . &#39;ABCD&#39; . a.lower() # a.lower()를 쓰면 a의 모든 문자를 소문자로 바꾸는 기능을 제공, lower(a)라고 읽자! . &#39;abcd&#39; . 여기에서 lower()는 문자열에 특화된 기능임. 따라서 당연히 아래는 불가능 . a=3.14 a.lower() # lower(a) . AttributeError Traceback (most recent call last) Input In [194], in &lt;module&gt; 1 a=3.14 -&gt; 2 a.lower() AttributeError: &#39;float&#39; object has no attribute &#39;lower&#39; . - 자료형에 특화된 기능(=함수)을 확인하는 방법? a.+ tab 으로 목록 확인 가능 . a=&#39;guebin&#39; . a.upper? . Signature: a.upper() Docstring: Return a copy of the string converted to uppercase. Type: builtin_function_or_method . a.upper() # upper(a) . &#39;GUEBIN&#39; . a.capitalize() # capitalize(a) . &#39;Guebin&#39; . - 문자열에 대한 다른 내용들은 추후에 다루겠음. . - 마음의눈: a.f() 형태를 읽는 팁 . a.f()는 f(a)로 생각하면 편리함. | a.f(2)는 f(a,2)로 생각하면 편리함. | 이런점에서 R %&gt;% 연산자와 비슷하다고 생각할 수 있다. (약간 다르긴함) | . - 사실 .은 좀 더 다양한 상황에서 쓰일 수 있다. 변수이름.함수이름() 의 형태가 아니라 . 패지키이름.함수이름() | 패키지이름.변수이름 | 패키지이름.패키지이름.함수이름() | ... | . 와 같이 다양한 형태가 가능하다. 근본적인 공통점은 .을 기준으로 상위개념.하위개념 으로 이해하는 것이 좋다. . 0&#52264;&#50896; vs 1&#52264;&#50896; . - len함수 소개: 원소의 갯수를 알려주는 함수. . (0차원) len 함수가 동작하지 않음. . a=3.14 . len(a) . TypeError Traceback (most recent call last) Input In [197], in &lt;module&gt; -&gt; 1 len(a) TypeError: object of type &#39;float&#39; has no len() . b=True . len(b) . TypeError Traceback (most recent call last) Input In [201], in &lt;module&gt; -&gt; 1 len(b) TypeError: object of type &#39;bool&#39; has no len() . (1차원) len 함수가 잘 동작함. . a=&#39;3.14&#39; len(a) . 4 . b=[1,2,3] . len(b) . 3 . &#49689;&#51228; . 본인이름으로 str을 생성 $ to$ LMS에 스크린샷제출 . 성만 출력 | 이름만 출려 | . (예시) . a=&#39;GuebinChoi&#39; . a[:6] . &#39;Guebin&#39; . a[6:] . &#39;Choi&#39; .",
            "url": "https://guebin.github.io/IP2022/2022/03/07/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2022/03/07/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%947%EC%9D%BC.html",
            "date": " • Mar 7, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "(1주차) 3월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . .",
            "url": "https://guebin.github.io/IP2022/2022/03/02/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2022/03/02/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%942%EC%9D%BC.html",
            "date": " • Mar 2, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기",
            "content": "About this doc . - 본 포스트는 2021년 1학기 Python 입문 강의내용중 일부를 업로드 하였음. . - Github, fastpages를 사용하여 블로그를 개설하고 관리하는 방법에 대한 설명임. . .",
            "url": "https://guebin.github.io/IP2022/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "relUrl": "/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "date": " • Aug 17, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "최규빈 . guebin@jbnu.ac.kr | 자연과학대학교 본관 205호 | 카카오톡 오픈채널 1 | . 2022년 1학기 종료후 폐쇄예정 &#8617; . |",
          "url": "https://guebin.github.io/IP2022/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/IP2022/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}