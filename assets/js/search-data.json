{
  
    
        "post0": {
            "title": "2022년 파이썬 입문 기말고사 풀이",
            "content": "0. imports . 아래코드를 이용하여 numpy, matplotlib, pandas를 import하라. . import numpy as np import matplotlib.pyplot as plt import pandas as pd from IPython.display import HTML . 1. &#44592;&#48376;&#47928;&#51228; (50&#51216;) . (1) 도함수를 구하는 함수 derivate를 선언하라. 이 함수를 이용하여 $f(x)=x^2$의 그래프와 $f&#39;(x)=2x$의 그래프를 $x in (-1,1)$의 범위에서 그려라. . (풀이) . def f(x): return x**2 . def derivate(f): def df(x): h=0.000000000001 return (f(x+h)-f(x))/h return df . x = np.linspace(-1,1,100) plt.plot(x,f(x)) plt.plot(x,derivate(f)(x)) . [&lt;matplotlib.lines.Line2D at 0x7fd22c893a00&gt;] . (2) 적당한 클래스 정의하여 인스턴스 a를 만들고 print(a)의 출력결과가 본인의 학번이 나오도록 하라. . (풀이) . class Klass: def __str__(self): return(&#39;2022-43052&#39;) . a=Klass() print(a) . 2022-43052 . (3) for문이 실행될때마다 [묵,찌,빠] 중에 하나를 내며 빠를 누적 3회 낼경우 for문이 멈추는 이터레이터를 생성하라. . (풀이) . class Klass: # 찌를 내는순간 for문이 멈추도록 하는 이터레이터를 만들자 def __init__(self): self.candidate = [&quot;묵&quot;,&quot;찌&quot;,&quot;빠&quot;] self.dic = {&#39;묵&#39;:0,&#39;찌&#39;:0,&#39;빠&#39;:0} def __iter__(self): return self def __next__(self): action = np.random.choice(self.candidate) self.dic[action] += 1 if self.dic[&#39;빠&#39;]==3: print(&quot;빠가 3번 누적되어 for문을 멈춥니다&quot;) raise StopIteration else: return action . a=Klass() for i in a: print(i) . 빠 묵 빠 빠가 3번 누적되어 for문을 멈춥니다 . (4)-(6) . class GS25: n=0 total_number_of_guests = 0 def __init__(self): self.number_of_guests = 0 . (4) 위의 클래스를 수정하여 아래와 같이 GS25에서 새로운 인스턴스가 생성될때마다 . GS25의 점포수가 ?개로 늘었습니다. . 라는 메시지가 출력되도록 하라. . (5) 함수 come를 인스턴스 메소드로 정의하라. 이 메소드가 실행될때마다 각 점포의 손님 인스턴스 변수 number_of_guests와 클래스변수 total_number_of_guests를 1씩 증가시키고 아래의 메시지를 출력하라. . 새로운 손님이 오셨습니다! GS25를 방문한 총 손님수는 n명입니다. 현재 GS25 점포를 방문한 손님수는 m명입니다. . (6) 새로운 클래스메서드 show를 만들고 아래와 같은 메시지를 출력하도록 하라. . GS25의 점포수: ?? GS25를 방문한 총 손님수: ?? . (풀이) . class GS25: n=0 total_number_of_guests = 0 def __init__(self): self.number_of_guests = 0 GS25.n += 1 print(&quot;GS25의 점포수가 {}개로 늘었습니다.&quot;.format(GS25.n)) def come(self): GS25.total_number_of_guests += 1 self.number_of_guests += 1 print(&quot;새로운 손님이 오셨습니다!&quot;) print(&quot;GS25를 방문한 총 손님수는 {}명입니다.&quot;.format(GS25.total_number_of_guests)) print(&quot;현재 GS25 점포를 방문한 손님수는 {}명입니다.&quot;.format(self.number_of_guests)) @classmethod def show(cls): print(&quot;GS25의 점포수: {}&quot;.format(cls.n)) print(&quot;GS25를 방문한 총 손님수: {}&quot;.format(cls.total_number_of_guests)) . a=GS25() ## (4)의 사용예시 . GS25의 점포수가 1개로 늘었습니다. . b=GS25() ## (4)의 사용예시 . GS25의 점포수가 2개로 늘었습니다. . a.come() ## (5)의 사용예시 . 새로운 손님이 오셨습니다! GS25를 방문한 총 손님수는 1명입니다. 현재 GS25 점포를 방문한 손님수는 1명입니다. . a.come() ## (5)의 사용예시 . 새로운 손님이 오셨습니다! GS25를 방문한 총 손님수는 2명입니다. 현재 GS25 점포를 방문한 손님수는 2명입니다. . b.come() ## (5)의 사용예시 . 새로운 손님이 오셨습니다! GS25를 방문한 총 손님수는 3명입니다. 현재 GS25 점포를 방문한 손님수는 1명입니다. . GS25.show() ## (6)의 사용예시 . GS25의 점포수: 2 GS25를 방문한 총 손님수: 3 . (7) __eq__는 연산 == 를 재정의하는 메소드이다. 클래스 RPC_BASE를 상속하여 새로운 클래스 RPC5를 만들라. 연산 ==를 재정의하여 RPC7의 두 인스턴스의 action이 같은 경우 true를 리턴하는 기능을 구현하라. . class RPC_BASE: def __init__(self): self.action = np.random.choice([&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]) . (풀이) . class RPC7(RPC_BASE): def __eq__(self,other): return self.action == other.action . a=RPC7() a.action . &#39;바위&#39; . b=RPC7() b.action . &#39;가위&#39; . a==b . False . (8) __gt__는 연산 &gt; 를 재정의하는 메소드이다. 클래스 RPC_BASE를 상속하여 새로운 클래스 RPC6를 만들라. 연산 &gt;를 재정의하여 RPC6의 두 인스턴스 a,b의 action이 각각 (&#39;가위&#39;,&#39;보&#39;), (&#39;바위&#39;,&#39;가위&#39;), (&#39;보&#39;,&#39;바위&#39;) 인 경우 true를 리턴하는 기능을 구현하라. . (풀이) . class RPC8(RPC_BASE): def __gt__(self,other): # 연산 &gt; 를 재정의 pair = self.action, other.action return pair == (&#39;가위&#39;,&#39;보&#39;) or pair == (&#39;바위&#39;,&#39;가위&#39;) or pair == (&#39;보&#39;,&#39;바위&#39;) . a=RPC8() a.action . &#39;보&#39; . b=RPC8() b.action . &#39;가위&#39; . a&gt;b, a&lt;b . (False, True) . (9)-(10) . 아래와 같은 데이터프레임을 선언하고 물음에 답하라. . np.random.seed(43052) df=pd.DataFrame({&#39;type&#39;:np.random.choice([&#39;A&#39;,&#39;B&#39;],100), &#39;score&#39;:np.random.randint(40,95,100)}) df . type score . 0 B | 45 | . 1 A | 40 | . 2 B | 79 | . 3 B | 46 | . 4 B | 57 | . ... ... | ... | . 95 B | 69 | . 96 A | 71 | . 97 A | 93 | . 98 A | 63 | . 99 A | 82 | . 100 rows × 2 columns . (9) type==&#39;A&#39;의 평균score를 구하는 코드를 작성하라. . (풀이) . m = df.query(&quot;type==&#39;A&#39;&quot;).score.mean() m . 68.4 . (10) type==&#39;A&#39;의 평균score보다 같거나 큰 값을 가지는 행을 출력하라. . (풀이) . # 아래모두 정답으로 인정 (문제설명이 불충분) # df.query(&quot;type==&#39;A&#39; and score &gt;= @m&quot;) # df.query(&quot;score &gt;= @m&quot;) . 2. &#44032;&#50948;, &#48148;&#50948;, &#48372; &#54616;&#45208;&#48764;&#44592; (150&#51216;) . class RPC: def __init__(self,candidate): self.candidate = candidate self.actions = list() self.rewards = list() self.prob = [0.5,0.5] def __eq__(self,other): # 연산 == 를 재정의 return self.actions[-1] == other.actions[-1] #note: 둘의 액션이 같으면 무승부 def __gt__(self,other): # 연산 &gt; 를 재정의 pair = self.actions[-1], other.actions[-1] return pair == (&#39;가위&#39;,&#39;보&#39;) or pair == (&#39;바위&#39;,&#39;가위&#39;) or pair == (&#39;보&#39;,&#39;바위&#39;) #note: 가위&gt;보, 바위&gt;가위, 보&gt;가위 def __mul__(self,other): # step1: 각자의 패를 선택 self.choose() other.choose() # step2: 승패 판단 + upate reward if self == other: # 무승부일경우 self.rewards.append(1) other.rewards.append(1) elif self &gt; other: # self의 승리 self.rewards.append(2) other.rewards.append(0) else: # other의 승리 self.rewards.append(0) other.rewards.append(2) # step3: update data self.update_data() other.update_data() def update_data(self): self.data = pd.DataFrame({&#39;actions&#39;:self.actions, &#39;rewards&#39;:self.rewards}) def _repr_html_(self): html_str = &quot;&quot;&quot; 낼 수 있는 패: {} &lt;br/&gt; 데이터: &lt;br/&gt; {} &quot;&quot;&quot; return html_str.format(self.candidate,self.data._repr_html_()) def choose(self): self.actions.append(np.random.choice(self.candidate,p=self.prob)) . (1) 플레이어A는 (가위,가위) 중 하나를 선택할 수 있고 플레이어B는 (가위,바위) 중 하나를 선택할 수 있다. 각 플레이어는 각 패 중 하나를 랜덤으로 선택하는 액션을 한다고 가정하자. 아래에 해당하는 확률을 시뮬레이션을 이용하여 추정하라. . 플레이어A가 승리할 확률: | 플레이어B가 승리할 확률: | 플레이어A와 플레이어B가 비길 확률: | . hint: 50% 확률로 b가 승리하고 50% 확률로 비긴다. . (풀이) . PlayerA = RPC([&#39;가위&#39;,&#39;가위&#39;]) PlayerB = RPC([&#39;가위&#39;,&#39;바위&#39;]) for _ in range(100): PlayerA * PlayerB . print(&#39;플레이어A가 승리할 확률: {}&#39;.format(sum(PlayerA.data.rewards==2)/100)) print(&#39;플레이어B가 승리할 확률: {}&#39;.format(sum(PlayerA.data.rewards==0)/100)) print(&#39;플레이어A와 플레이어B가 비길 확률: {}&#39;.format(sum(PlayerA.data.rewards==1)/100)) . 플레이어A가 승리할 확률: 0.0 플레이어B가 승리할 확률: 0.57 플레이어A와 플레이어B가 비길 확률: 0.43 . (2) 문제 (1)과 같이 아래의 상황을 가정하자. . 플레이어A 플레이어B . 각 플레이어가 낼 수 있는 패 (candidate) | (가위,가위) | (가위,바위) | . 각 패를 선택할 확률 (prob) | (0.5,0.5) | (0.5,0.5) | . 각 플레이어는 아래와 같은 규칙으로 가위바위보 결과에 따른 보상점수를 적립한다고 하자. . 승리: 보상점수 2점 적립 | 무승부: 보상점수 1점 적립 | 패배: 보상점수 0점 적립 | . 100번째 대결까지 시뮬레이션을 시행하고 플레이어B가 가위를 낼 경우 얻은 보상점수의 총합과 바위를 낼 경우 얻은 보상점수의 총합을 각각 구하라. 플레이어B는 가위를 내는것이 유리한가? 바위를 내는것이 유리한가? . hint: 플레이어B는 바위를 내는 것이 유리하다. . hint: 플레이어B가 100번중에 49번 가위를 내고 51번 바위를 낸다면 플레이어B가 적립할 보상점수는 각각 아래와 같다. . 가위를 내었을 경우: 49 * 1 = 49점 | 바위를 내었을 경우: 51 * 2 = 102점 | 총 보상점수 = 49점 + 102점 = 151점 | . (풀이) . print(&#39;플레이어B가 가위를 낼 경우 얻은 보상점수의 총합: {}&#39;.format(PlayerB.data.query(&quot; actions==&#39;가위&#39;&quot;).rewards.sum())) print(&#39;플레이어B가 바위를 낼 경우 얻은 보상점수의 총합: {}&#39;.format(PlayerB.data.query(&quot; actions==&#39;바위&#39;&quot;).rewards.sum())) . 플레이어B가 가위를 낼 경우 얻은 보상점수의 총합: 43 플레이어B가 바위를 낼 경우 얻은 보상점수의 총합: 114 . (3) (2)에서 얻은 데이터를 학습하여 플레이어B가 &quot;가위&quot; 혹은 &quot;바위&quot; 를 선택할 확률을 매시점 조금씩 조정한다고 가정하자. 구체적으로는 현재시점까지 얻은 보상점수의 비율로 확률을 결정한다. 예를들어 플레이어B가 100회의 대결동안 누적한 보상점수의 총합이 아래와 같다고 하자. . 가위를 내었을 경우 보상점수 총합 = 50점 | 바위를 내었을 경우 보상점수 총합 = 100점 | . 그렇다면 플레이어B는 각각 (50/150,100/150) 의 확률로 (가위,바위) 중 하나를 선택한다. 101번째 대결에 플레이어B가 가위를 내서 비겼다면 이후에는 (51/151,100/151) 의 확률로 (가위,바위) 중 하나를 선택한다. 102번째 대결에 플레이어B가 바위를 내서 이겼다면 이후에는 각각 (51/153,102/153) 의 확률로 (가위,바위) 중 하나를 선택한다. 이러한 상황을 요약하여 표로 정리하면 아래와 같다. . 시점 플레이어B가 가위를 냈을 경우 얻은 점수 총합 플레이어B가 바위를 냈을 경우 얻은 점수 총합 t+1시점에서 플레이어B가 (가위,바위)를 낼 확률 . t=100 | 50 | 100 | (50/150, 100/150) | . t=101 | 51 | 100 | (51/151, 100/151) | . t=102 | 51 | 102 | (51/153, 102/153) | . 이러한 방식으로 500회까지 게임을 진행하며 확률을 수정하였을 경우 501번째 대결에서 플레이어B가 (가위,바위)를 낼 확률은 각각 얼마인가? . hint: 시간이 지날수록 플레이어B는 (가위,바위)중 바위를 내는 쪽이 유리하다는 것을 알게 될 것이다. . (풀이) . class RPC2(RPC): def __init__(self,candidate): # 기존내용 self.candidate = candidate self.actions = list() self.rewards = list() self.prob = [0.5,0.5] # 새롭게 정의하는 내용 self.data = dict() self.trainable=False # 학습모드 설정 def update_data(self): a = self.actions[-1] r = self.rewards[-1] self.data[a] = self.data.get(a,0)+r def _repr_html_(self): html_str = &quot;&quot;&quot; 낼 수 있는 패: {} &lt;br/&gt; 확률: {} &lt;br/&gt; 데이터: {} &quot;&quot;&quot; return html_str.format(self.candidate,self.prob,self.data) def choose(self): if self.trainable: # if self.trainalbe==True: a1 = self.candidate[0] # action1 a2 = self.candidate[1] # action2 r1 = self.data[a1] # reward from action1 r2 = self.data[a2] # reward from action2 self.prob = [r1/(r1+r2), r2/(r1+r2)] self.actions.append(np.random.choice(self.candidate,p=self.prob)) . PlayerA=RPC2([&#39;가위&#39;,&#39;가위&#39;]) PlayerB=RPC2([&#39;가위&#39;,&#39;바위&#39;]) . # 1~100 PlayerA.trainable=False PlayerB.trainable=False for _ in range(100): PlayerA * PlayerB # 100~500 PlayerA.trainable=False PlayerB.trainable=True for _ in range(400): PlayerA * PlayerB . PlayerB . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.1923536439665472, 0.8076463560334528] 데이터: {&#39;바위&#39;: 678, &#39;가위&#39;: 161} . 앞으로 아래와 같은 용어를 사용한다. . (정의) 어떠한 플레이어가 양손 중 하나를 선택하는 확률을 데이터를 바탕으로 매 순간 업데이트 한다면 그 플레이어는 &quot;학습모드 상태이다&quot;고 표현한다. | (정의) 반대로 어떠한 플레이어가 양손 중 하나를 항상 동일한 확률로 낸다면 그 플레이어는 &quot;학습모드 상태가 아니다&quot;라고 표현한다. | . . (4) 새로운 두명의 플레이어C와 플레이어D를 만들어라. 두 플레이어는 모두 동일하게 (가위,바위) 중 하나를 선택할 수 있다. 두 명의 플레이어는 100번째 대결까지는 두 가지 패중 하나를 랜덤하게 선택하고 101번째 대결부터 500번째 대결까지는 문제(3)의 플레이어B와 같은 방식으로 확률을 업데이트 하여 두 가지 패를 서로 다른 확률로 낸다고 하자. 즉 100번째 대결까지는 두 플레이어가 모두 학습모드 상태가 아니고 101번째부터 500번째 대결까지는 두 플레이어가 모두 학습모드 상태이다. 500번째 대결까지의 학습이 끝났을 경우 플레이어 C와 플레이어D가 각 패를 낼 확률은 각각 얼마인가? . 시점 플레이어C가 (가위,바위)를 낼 확률 플레이어D가 (가위,바위)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (1/2, 1/2) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 500 | 대결 데이터를 학습하여 수정한 확률 | 대결 데이터를 학습하여 수정한 확률 | 양쪽 플레이어 모두 학습모드임 | . hint: 시간이 지날수록 두 플레이어 모두 바위를 내는 쪽이 유리하다는 것을 알게 될 것이다. . (풀이) . PlayerC=RPC2([&#39;가위&#39;,&#39;바위&#39;]) PlayerD=RPC2([&#39;가위&#39;,&#39;바위&#39;]) . # 1~100 PlayerC.trainable=False PlayerD.trainable=False for _ in range(100): PlayerC * PlayerD # 100~500 PlayerC.trainable=True PlayerD.trainable=True for _ in range(400): PlayerC * PlayerD . PlayerC . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.07692307692307693, 0.9230769230769231] 데이터: {&#39;바위&#39;: 469, &#39;가위&#39;: 39} PlayerD . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.07942973523421588, 0.9205702647657841] 데이터: {&#39;바위&#39;: 453, &#39;가위&#39;: 39} (5) 새로운 플레이어 E와 F를 생각하자. 플레이어E와 플레이어F는 각각 (가위,바위) 그리고 (가위,보) 중 하나를 선택할 수 있다고 가정하자. 시뮬레이션 대결결과를 이용하여 아래의 확률을 근사적으로 추정하라. . 플레이어E가 승리할 확률: | 플레이어F가 승리할 확률: | 플레이어E와 플레이어F가 비길 확률: | . hint: 플레이어E가 가위를 낸다면 최소한 지지는 않기 때문에 플레이어E가 좀 더 유리한 패를 가지고 있다. 따라서 플레이어E의 결과가 더 좋을 것이다. . PlayerE=RPC([&#39;가위&#39;,&#39;바위&#39;]) PlayerF=RPC([&#39;가위&#39;,&#39;보&#39;]) for _ in range(100): PlayerE * PlayerF print(&#39;플레이어E가 승리할 확률: {}&#39;.format(sum(PlayerE.data.rewards==2)/100)) print(&#39;플레이어F가 승리할 확률: {}&#39;.format(sum(PlayerE.data.rewards==0)/100)) print(&#39;플레이어E와 플레이어F가 비길 확률: {}&#39;.format(sum(PlayerE.data.rewards==1)/100)) . 플레이어E가 승리할 확률: 0.47 플레이어F가 승리할 확률: 0.36 플레이어E와 플레이어F가 비길 확률: 0.17 . (6) (5)와 동일한 두 명의 플레이어E, F를 생각하자. 두 플레이어는 100회까지는 랜덤으로 자신의 패를 선택한다. 그리고 101회부터 500회까지는 플레이어F만 데이터로 부터 학습을 하여 수정된 확률을 사용한다. 500번의 대결이 끝나고 플레이어F가 (가위,보)를 선택하는 확률이 어떻게 업데이트 되어있는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (1/2, 1/2) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 500 | (1/2, 1/2) | 데이터를 학습하여 수정한 확률 | 플레이어E는 학습모드아님 / 플레이어F는 학습모드 | . hint: 플레이어F는 보를 내는 것이 낫다고 생각할 것이다. (가위를 내면 지거나 비기지만 보를 내면 지거나 이긴다.) . PlayerE=RPC2([&#39;가위&#39;,&#39;바위&#39;]) PlayerF=RPC2([&#39;가위&#39;,&#39;보&#39;]) . # 1~100 PlayerE.trainable=False PlayerF.trainable=False for _ in range(100): PlayerE * PlayerF # 100~500 PlayerE.trainable=False PlayerF.trainable=True for _ in range(400): PlayerE * PlayerF . PlayerE . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.5, 0.5] 데이터: {&#39;바위&#39;: 112, &#39;가위&#39;: 441} PlayerF . 낼 수 있는 패: [&#39;가위&#39;, &#39;보&#39;] 확률: [0.10067114093959731, 0.8993288590604027] 데이터: {&#39;보&#39;: 402, &#39;가위&#39;: 45} (7) (6)번의 플레이어E와 플레이어F가 500회~1000회까지 추가로 게임을 한다. 이번에는 플레이어E만 데이터로부터 학습한다. 1000회까지 대결을 끝낸 이후 플레이어E가 (가위,바위)를 내는 확률은 어떻게 업데이트 되었는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (1/2, 1/2) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 500 | (1/2, 1/2) | 데이터를 학습하여 수정한 확률 | 플레이어E는 학습모드아님 / 플레이어F는 학습모드 | . t &lt;= 1000 | 데이터를 학습하여 수정한 확률 | t=500시점에 업데이트된 확률 | 플레이어E는 학습모드 / 플레이어F는 학습모드아님 | . hint: 플레이어F는 보를 내도록 학습되어 있다. 따라서 플레이어E가 바위를 내면 지고 가위를 내면 이길것이다. 따라서 플레이어E는 가위가 유리하다고 생각할 것이다. . # 500~1000 PlayerE.trainable=True PlayerF.trainable=False for _ in range(500): PlayerE * PlayerF . PlayerE . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.902158273381295, 0.09784172661870504] 데이터: {&#39;바위&#39;: 136, &#39;가위&#39;: 1256} PlayerF . 낼 수 있는 패: [&#39;가위&#39;, &#39;보&#39;] 확률: [0.10067114093959731, 0.8993288590604027] 데이터: {&#39;보&#39;: 528, &#39;가위&#39;: 80} (8) (7)번의 플레이어E와 플레이어F가 1000회~30000회까지 추가로 게임을 한다. 이번에는 플레이어F만 데이터로부터 학습한다. 30000회까지 대결을 끝낸 이후 플레이어F가 (가위,보)를 내는 확률은 어떻게 업데이트 되었는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (1/2, 1/2) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 500 | (1/2, 1/2) | 데이터를 학습하여 수정한 확률 | 플레이어E는 학습모드아님 / 플레이어F는 학습모드 | . t &lt;= 1000 | 데이터를 학습하여 수정한 확률 | t=500시점에 업데이트된 확률 | 플레이어E는 학습모드 / 플레이어F는 학습모드아님 | . t &lt;= 30000 | t=1000시점에 업데이트된 확률 | 데이터를 학습하여 수정한 확률 | 플레이어E는 학습모드아님 / 플레이어F는 학습모드 | . hint: 플레이어F는 원래 보가 유리하다고 생각하여 보를 자주 내도록 학습되었다. 하지만 플레이어E가 그러한 플레이어F의 성향을 파악하고 가위를 주로 내도록 학습하였다. 플레이어F는 그러한 플레이어E의 성향을 다시 파악하여 이번에는 가위을 자주 내는 것이 유리하다고 생각할 것이다. . # 1000~30000 PlayerE.trainable=False PlayerF.trainable=True for _ in range(29000): PlayerE * PlayerF . PlayerE . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.902158273381295, 0.09784172661870504] 데이터: {&#39;바위&#39;: 4468, &#39;가위&#39;: 33162} PlayerF . 낼 수 있는 패: [&#39;가위&#39;, &#39;보&#39;] 확률: [0.9214985023917028, 0.0785014976082972] 데이터: {&#39;보&#39;: 1756, &#39;가위&#39;: 20614} (9) 플레이어E와 플레이어F의 대결기록을 초기화 한다. 이번에는 플레이어F가 항상 (3/4)의 확률로 가위를 (1/4)의 확률로 보를 낸다고 가정한다. 플레이어E는 100번의 대결까지는 랜덤으로 (가위,바위)중 하나를 내고 101번째 대결부터 1000번째 대결까지는 대결 데이터를 학습하여 수정한 확률을 사용한다고 하자. 1000번째 대결이후에 플레이어E가 (가위,바위)를 내는 확률이 어떻게 업데이트 되어있는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (3/4, 1/4) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 1000 | 데이터를 학습하여 수정한 확률 | (3/4, 1/4) | 플레이어E는 학습모드 / 플레이어F는 학습모드 아님 | . (풀이) . PlayerE=RPC2([&#39;가위&#39;,&#39;바위&#39;]) PlayerF=RPC2([&#39;가위&#39;,&#39;보&#39;]) . # 1~100 PlayerE.trainable=False PlayerF.trainable=False PlayerF.prob=[3/4,1/4] for _ in range(100): PlayerE * PlayerF # 100~1000 PlayerE.trainable=True PlayerF.trainable=False for _ in range(900): PlayerE * PlayerF . PlayerE . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.363831308077198, 0.636168691922802] 데이터: {&#39;바위&#39;: 892, &#39;가위&#39;: 509} 바위가 좀 더 유리하게 나온다 . (추가풀이) . PlayerE.trainable=True PlayerF.trainable=False for _ in range(10000*100): PlayerE * PlayerF . PlayerE . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.1438411969483742, 0.8561588030516258] 데이터: {&#39;바위&#39;: 1248374, &#39;가위&#39;: 209736} E가 가위를 냈을경우 보상의 기대값은 $1 times 3/4 + 2 times 1/4 = 5/4$ 이고 바위를 냈을경우 보상의 기대값은 $2 times 3/4 + 0 times 1/4 = 6/4$ 이므로 바위가 더 유리하다. 따라서 점점 바위를 내도록 학습한다. . (10) 플레이어E와 플레이어F의 대결기록을 초기화 한다. 이번에는 플레이어F가 항상 (2/3)의 확률로 가위를 (1/3)의 확률로 보를 낸다고 가정한다. 플레이어E는 100번의 대결까지는 랜덤으로 (가위,바위)중 하나를 내고 101번째 대결부터 1000번째 대결까지는 대결 데이터를 학습하여 수정한 확률을 사용한다고 하자. 1000번째 대결이후에 플레이어E가 (가위,바위)를 내는 확률이 어떻게 업데이트 되어있는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (2/3, 1/3) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 1000 | 데이터를 학습하여 수정한 확률 | (2/3, 1/3) | 플레이어E는 학습모드 / 플레이어F는 학습모드 아님 | . PlayerE=RPC2([&#39;가위&#39;,&#39;바위&#39;]) PlayerF=RPC2([&#39;가위&#39;,&#39;보&#39;]) . # 1~100 PlayerE.trainable=False PlayerF.trainable=False PlayerF.prob=[2/3,1/3] for _ in range(100): PlayerE * PlayerF # 100~1000 PlayerE.trainable=True PlayerF.trainable=False for _ in range(900): PlayerE * PlayerF . PlayerE . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;] 확률: [0.5139500734214391, 0.48604992657856094] 데이터: {&#39;바위&#39;: 664, &#39;가위&#39;: 700} PlayerF . 낼 수 있는 패: [&#39;가위&#39;, &#39;보&#39;] 확률: [0.6666666666666666, 0.3333333333333333] 데이터: {&#39;가위&#39;: 344, &#39;보&#39;: 292} E가 가위를 냈을경우 보상의 기대값은 $1 times 2/3 + 2 times 1/3 = 4/3$ 이고 바위를 냈을 경우 보상의 기대값은 $2 times 2/3 + 0 times 1/3 = 4/3$ 이므로 가위도 바위도 유리하지 않다. 따라서 가위와 바위를 어떠한 확률로 내든 상관없다. . 문제2의 추가해설 . (프로그래밍 팁) . 기본적인 구현기능인 RPC클래스를 상속을 이용하여 적절하게 modify하면 문제를 쉽게 풀 수 있습니다. 문항에 따라서 어떤것은 기본 RPC클래스를 쓰는것이 유리하고 어떠한 것은 새로운 클래스를 정의하는 것이 유리할 수 있습니다. 예를들어 2-(1),(2),(5)는 RPC클래스를 그대로 쓰는 것이 유리했으며 나머지는 새로운 클래스인 RPC2를 사용하는것이 문제풀이에 유리했습니다. . (계산팁) . 추가확률을 계산할 경우 pandas의 dataframe을 이용하는 것보다 RPC2에서 제가 구현한 것 처럼 dict와 같은 내장자료형을 이용하는 것이 훨씬 연산속도가 빠릅니다. 연산속도의 차이가 나는 이유는 (1) 기본적으로 판다스는 느리며 (2) RPC의 data에는 모든 자료를 저장는데 RPC2의 data는 각 패를 내었을 경우 보상의 누적만 저장하기 때문 입니다. . (약간의 개념해설) . 이 문제는 제로섬게임의 확장입니다. (양쪽 플레이어의 보상합이 일정하므로 이러한 게임을 constantsum 이라고 부릅니다) 어떤 분은 이 문제를 보고 게임이론을 떠올릴 수 있고 어떤 분은 강화학습을 떠올렸을 것 같습니다. . 문제의 포인트는 상대방의 전략에 따라서 나의 최적전략이 끝없이 달라진다는 점입니다. 문항 (5)-(10)까지의 문제는 이러한 상황을 묘사합니다. 직관적으로는 더 좋은패를 가지고 있는 플레이어E가 유리할 듯 하지만 결국 상대의 패를 보고 전략을 끝없이 수정하면 어떠한 하나의 action도 최적이 될 수 없습니다. 이 문제의 경우 문항 (8)의 시점에서는 둘 다 가위를 내도록 업데이트 되었는데 이를 이용하여 플레이어E가 다시 바위를 낼 수 있고 그 심리를 역이용하여 플레이어F가 다시 보를 낼 수 있고 그 심리를 다시 역이용하여 플레이어E가 다시 가위를 내며 그 심리를 역이용하여 플레이어F는 다시 가위를 낼 수 있어 무한반복이 됩니다. (상대도 바보가 아니거든요.) . 하지만 두 가지 액션을 확률로 선택한다면 문항 (10)의 상황과 같이 상대방이 어떠한 선택을 하더라도 유리한 선택이 존재하지 않는 어떠한 균형점이 존재할 수 있는데 이를 내쉬의 균형이라 합니다. 내쉬의 균형에 따르면 플레이어E는 가위와 바위를 2:1의 비율로 플레이어F는 가위와 보를 2:1로 낼때 서로가 서로의 전략을 바꾸지 않는 균형상태에 도달합니다. 이러한 게임의 셋팅에 대하여 좀 더 관심 있으신 분은 게임이론을 참고하셔서 공부해보시기 바랍니다. (저도 기본적인 내용밖에 모르지만 흥미있는 분야입니다) . 반면 주어진 게임환경에서 플레이어E,F가 (에이전트라고 부릅니다) 전략을 학습하는 과정이 흥미롭게 느껴졌다면 강화학습을 한번 참고해보시기 바랍니다. 강화학습은 알파고를 학습하여 이세돌을 이긴 알고리즘입니다. 아래영상은 컴퓨터플레이어가 벽돌깨기 게임을 하며 데이터를 쌓고 데이터로 부터 적절한 action을 학습하는 과정을 묘사한 영상입니다. 여러분들이 기말고사에서 간단히 만들어본 알고리즘의 발전형입니다. 강화학습에 흥미가 있으시면 방학동안에 공부해보시길 바랍니다. (궁금한 점은 제 메일로 질문하셔도 됩니다, 제가 게임이론은 전공이 아니지만 강화학습은 좀 할줄알거든요 ㅎㅎ) . Appendix . - 아래의 클래스를 참고하여 문제1,2을 풀어라. (5월25일 강의노트에 소개된 클래스를 약간 정리한 것) . 참고하지 않아도 감점은 없음 | . class RPC: def __init__(self,candidate): self.candidate = candidate self.actions = list() self.rewards = list() self.prob = [0.5,0.5] def __eq__(self,other): # 연산 == 를 재정의 return self.actions[-1] == other.actions[-1] #note: 둘의 액션이 같으면 무승부 def __gt__(self,other): # 연산 &gt; 를 재정의 pair = self.actions[-1], other.actions[-1] return pair == (&#39;가위&#39;,&#39;보&#39;) or pair == (&#39;바위&#39;,&#39;가위&#39;) or pair == (&#39;보&#39;,&#39;바위&#39;) #note: 가위&gt;보, 바위&gt;가위, 보&gt;가위 def __mul__(self,other): # step1: 각자의 패를 선택 self.choose() other.choose() # step2: 승패 판단 + upate reward if self == other: # 무승부일경우 self.rewards.append(1) other.rewards.append(1) elif self &gt; other: # self의 승리 self.rewards.append(2) other.rewards.append(0) else: # other의 승리 self.rewards.append(0) other.rewards.append(2) # step3: update data self.update_data() other.update_data() def update_data(self): self.data = pd.DataFrame({&#39;actions&#39;:self.actions, &#39;rewards&#39;:self.rewards}) def _repr_html_(self): html_str = &quot;&quot;&quot; 낼 수 있는 패: {} &lt;br/&gt; 데이터: &lt;br/&gt; {} &quot;&quot;&quot; return html_str.format(self.candidate,self.data._repr_html_()) def choose(self): self.actions.append(np.random.choice(self.candidate,p=self.prob)) . - 사용예시 . a=RPC([&#39;가위&#39;,&#39;가위&#39;]) b=RPC([&#39;가위&#39;,&#39;보&#39;]) . for i in range(5): a*b . a . 낼 수 있는 패: [&#39;가위&#39;, &#39;가위&#39;] 데이터: actions rewards . 0 가위 | 2 | . 1 가위 | 2 | . 2 가위 | 1 | . 3 가위 | 2 | . 4 가위 | 2 | . b . 낼 수 있는 패: [&#39;가위&#39;, &#39;보&#39;] 데이터: actions rewards . 0 보 | 0 | . 1 보 | 0 | . 2 가위 | 1 | . 3 보 | 0 | . 4 보 | 0 | .",
            "url": "https://guebin.github.io/IP2022/2022/06/14/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC-%ED%92%80%EC%9D%B4.html",
            "relUrl": "/2022/06/14/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC-%ED%92%80%EC%9D%B4.html",
            "date": " • Jun 14, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "2022년 파이썬 입문 기말고사",
            "content": "0. imports . 아래코드를 이용하여 numpy, matplotlib, pandas를 import하라. . import numpy as np import matplotlib.pyplot as plt import pandas as pd from IPython.display import HTML . 1. &#44592;&#48376;&#47928;&#51228; (50&#51216;) . (1) 도함수를 구하는 함수 derivate를 선언하라. 이 함수를 이용하여 $f(x)=x^2$의 그래프와 $f&#39;(x)=2x$의 그래프를 $x in (-1,1)$의 범위에서 그려라. . (2) 적당한 클래스 정의하여 인스턴스 a를 만들고 print(a)의 출력결과가 본인의 학번이 나오도록 하라. . ## 코드예시 class Klass: ??? ??? a=Klass() print(a) . ## 출력결과 2022-43052 . (3) for문이 실행될때마다 [묵,찌,빠] 중에 하나를 내며 빠를 누적 3회 낼경우 for문이 멈추는 이터레이터를 생성하라. . (4)-(6) . class GS25: n=0 total_number_of_guests = 0 def __init__(self): self.number_of_guests = 0 . (4) 위의 클래스를 수정하여 아래와 같이 GS25에서 새로운 인스턴스가 생성될때마다 . GS25의 점포수가 ?개로 늘었습니다. . 라는 메시지가 출력되도록 하라. . (5) 함수 come를 인스턴스 메소드로 정의하라. 이 메소드가 실행될때마다 각 점포의 손님 인스턴스 변수 number_of_guests와 클래스변수 total_number_of_guests를 1씩 증가시키고 아래의 메시지를 출력하라. . 새로운 손님이 오셨습니다! GS25를 방문한 총 손님수는 n명입니다. 현재 GS25 점포를 방문한 손님수는 m명입니다. . (6) 새로운 클래스메서드 show를 만들고 아래와 같은 메시지를 출력하도록 하라. . GS25의 점포수: ?? GS25를 방문한 총 손님수: ?? . (사용예시) (4)-(6)을 모두 적용한 경우 사용예시는 아래와 같다. . a=GS25() ## (4)의 사용예시 . GS25의 점포수가 1개로 늘었습니다. . b=GS25() ## (4)의 사용예시 . GS25의 점포수가 2개로 늘었습니다. . a.come() ## (5)의 사용예시 . 새로운 손님이 오셨습니다! GS25를 방문한 모든 손님수는 1명입니다. 현재 GS25 점포를 방문한 손님수는 1명입니다. . a.come() ## (5)의 사용예시 . 새로운 손님이 오셨습니다! GS25를 방문한 모든 손님수는 2명입니다. 현재 GS25 점포를 방문한 손님수는 2명입니다. . b.come() ## (5)의 사용예시 . 새로운 손님이 오셨습니다! GS25를 방문한 모든 손님수는 3명입니다. 현재 GS25 점포를 방문한 손님수는 1명입니다. . GS25.show() ## (6)의 사용예시 . GS25의 점포수: 2 GS25를 방문한 총 손님수: 3 . (7) __eq__는 연산 == 를 재정의하는 메소드이다. 클래스 RPC_BASE를 상속하여 새로운 클래스 RPC5를 만들라. 연산 ==를 재정의하여 RPC5의 두 인스턴스의 action이 같은 경우 true를 리턴하는 기능을 구현하라. . class RPC_BASE: def __init__(self): self.action = np.random.choice([&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]) . hint: Appendix를 참고할 것 . hint: RPC5의 선언부분은 아래와 같은 형태를 가지고 있다. . class RPC5(???): def __eq__(self,other): return ?????? . hint: RPC5클래스의 사용예시는 아래와 같다. . a=RPC5() a.action . &#39;바위&#39; . b=RPC5() b.action . &#39;보&#39; . a==b . False . (8) __gt__는 연산 &gt; 를 재정의하는 메소드이다. 클래스 RPC_BASE를 상속하여 새로운 클래스 RPC6를 만들라. 연산 &gt;를 재정의하여 RPC6의 두 인스턴스 a,b의 action이 각각 (&#39;가위&#39;,&#39;보&#39;), (&#39;바위&#39;,&#39;가위&#39;), (&#39;보&#39;,&#39;바위&#39;) 인 경우 true를 리턴하는 기능을 구현하라. . hint: Appendix를 참고할 것 . hint: RPC6클래스의 사용예시는 아래와 같다. . a=RPC6() a.action . &#39;바위&#39; . b=RPC6() b.action . &#39;보&#39; . a&gt;b, a&lt;b . (False, True) . (9)-(10) . 아래와 같은 데이터프레임을 선언하고 물음에 답하라. . np.random.seed(43052) df=pd.DataFrame({&#39;type&#39;:np.random.choice([&#39;A&#39;,&#39;B&#39;],100), &#39;score&#39;:np.random.randint(40,95,100)}) df . type score . 0 B | 45 | . 1 A | 40 | . 2 B | 79 | . 3 B | 46 | . 4 B | 57 | . ... ... | ... | . 95 B | 69 | . 96 A | 71 | . 97 A | 93 | . 98 A | 63 | . 99 A | 82 | . 100 rows × 2 columns . (9) type==&#39;A&#39;의 평균score를 구하는 코드를 작성하라. . (10) type==&#39;A&#39;의 평균score보다 같거나 큰 값을 가지는 행을 출력하라. . 2. &#44032;&#50948;, &#48148;&#50948;, &#48372; &#54616;&#45208;&#48764;&#44592; (150&#51216;) . (1) 플레이어A는 (가위,가위) 중 하나를 선택할 수 있고 플레이어B는 (가위,바위) 중 하나를 선택할 수 있다. 각 플레이어는 각 패 중 하나를 랜덤으로 선택하는 액션을 한다고 가정하자. 아래에 해당하는 확률을 시뮬레이션을 이용하여 추정하라. . 플레이어A가 승리할 확률: | 플레이어B가 승리할 확률: | 플레이어A와 플레이어B가 비길 확률: | . hint: 50% 확률로 b가 승리하고 50% 확률로 비긴다. . (2) 문제 (1)과 같이 아래의 상황을 가정하자. . 플레이어A 플레이어B . 각 플레이어가 낼 수 있는 패 (candidate) | (가위,가위) | (가위,바위) | . 각 패를 선택할 확률 (prob) | (0.5,0.5) | (0.5,0.5) | . 각 플레이어는 아래와 같은 규칙으로 가위바위보 결과에 따른 보상점수를 적립한다고 하자. . 승리: 보상점수 2점 적립 | 무승부: 보상점수 1점 적립 | 패배: 보상점수 0점 적립 | . 100번째 대결까지 시뮬레이션을 시행하고 플레이어B가 가위를 낼 경우 얻은 보상점수의 총합과 바위를 낼 경우 얻은 보상점수의 총합을 각각 구하라. 플레이어B는 가위를 내는것이 유리한가? 바위를 내는것이 유리한가? . hint: 플레이어B는 바위를 내는 것이 유리하다. . hint: 플레이어B가 100번중에 49번 가위를 내고 51번 바위를 낸다면 플레이어B가 적립할 보상점수는 각각 아래와 같다. . 가위를 내었을 경우: 49 * 1 = 49점 | 바위를 내었을 경우: 51 * 2 = 102점 | 총 보상점수 = 49점 + 102점 = 151점 | . (3) (2)에서 얻은 데이터를 학습하여 플레이어B가 &quot;가위&quot; 혹은 &quot;바위&quot; 를 선택할 확률을 매시점 조금씩 조정한다고 가정하자. 구체적으로는 현재시점까지 얻은 보상점수의 비율로 확률을 결정한다. 예를들어 플레이어B가 100회의 대결동안 누적한 보상점수의 총합이 아래와 같다고 하자. . 가위를 내었을 경우 보상점수 총합 = 50점 | 바위를 내었을 경우 보상점수 총합 = 100점 | . 그렇다면 플레이어B는 각각 (50/150,100/150) 의 확률로 (가위,바위) 중 하나를 선택한다. 101번째 대결에 플레이어B가 가위를 내서 비겼다면 이후에는 (51/151,100/151) 의 확률로 (가위,바위) 중 하나를 선택한다. 102번째 대결에 플레이어B가 바위를 내서 이겼다면 이후에는 각각 (51/153,102/153) 의 확률로 (가위,바위) 중 하나를 선택한다. 이러한 상황을 요약하여 표로 정리하면 아래와 같다. . 시점 플레이어B가 가위를 냈을 경우 얻은 점수 총합 플레이어B가 바위를 냈을 경우 얻은 점수 총합 t+1시점에서 플레이어B가 (가위,바위)를 낼 확률 . t=100 | 50 | 100 | (50/150, 100/150) | . t=101 | 51 | 100 | (51/151, 100/151) | . t=102 | 51 | 102 | (51/153, 102/153) | . 이러한 방식으로 500회까지 게임을 진행하며 확률을 수정하였을 경우 501번째 대결에서 플레이어B가 (가위,바위)를 낼 확률은 각각 얼마인가? . hint: 시간이 지날수록 플레이어B는 (가위,바위)중 바위를 내는 쪽이 유리하다는 것을 알게 될 것이다. . . 앞으로 아래와 같은 용어를 사용한다. . (정의) 어떠한 플레이어가 양손 중 하나를 선택하는 확률을 데이터를 바탕으로 매 순간 업데이트 한다면 그 플레이어는 &quot;학습모드 상태이다&quot;고 표현한다. | (정의) 반대로 어떠한 플레이어가 양손 중 하나를 항상 동일한 확률로 낸다면 그 플레이어는 &quot;학습모드 상태가 아니다&quot;라고 표현한다. | . . (4) 새로운 두명의 플레이어C와 플레이어D를 만들어라. 두 플레이어는 모두 동일하게 (가위,바위) 중 하나를 선택할 수 있다. 두 명의 플레이어는 100번째 대결까지는 두 가지 패중 하나를 랜덤하게 선택하고 101번째 대결부터 500번째 대결까지는 문제(3)의 플레이어B와 같은 방식으로 확률을 업데이트 하여 두 가지 패를 서로 다른 확률로 낸다고 하자. 즉 100번째 대결까지는 두 플레이어가 모두 학습모드 상태가 아니고 101번째부터 500번째 대결까지는 두 플레이어가 모두 학습모드 상태이다. 500번째 대결까지의 학습이 끝났을 경우 플레이어 C와 플레이어D가 각 패를 낼 확률은 각각 얼마인가? . 시점 플레이어C가 (가위,바위)를 낼 확률 플레이어D가 (가위,바위)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (1/2, 1/2) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 500 | 대결 데이터를 학습하여 수정한 확률 | 대결 데이터를 학습하여 수정한 확률 | 양쪽 플레이어 모두 학습모드임 | . hint: 시간이 지날수록 두 플레이어 모두 바위를 내는 쪽이 유리하다는 것을 알게 될 것이다. . (5) 새로운 플레이어 E와 F를 생각하자. 플레이어E와 플레이어F는 각각 (가위,바위) 그리고 (가위,보) 중 하나를 선택할 수 있다고 가정하자. 시뮬레이션 대결결과를 이용하여 아래의 확률을 근사적으로 추정하라. . 플레이어E가 승리할 확률: | 플레이어F가 승리할 확률: | 플레이어E와 플레이어F가 비길 확률: | . hint: 플레이어E가 가위를 낸다면 최소한 지지는 않기 때문에 플레이어E가 좀 더 유리한 패를 가지고 있다. 따라서 플레이어E의 결과가 더 좋을 것이다. . (6) (5)와 동일한 두 명의 플레이어E, F를 생각하자. 두 플레이어는 100회까지는 랜덤으로 자신의 패를 선택한다. 그리고 101회부터 500회까지는 플레이어F만 데이터로 부터 학습을 하여 수정된 확률을 사용한다. 500번의 대결이 끝나고 플레이어F가 (가위,보)를 선택하는 확률이 어떻게 업데이트 되어있는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (1/2, 1/2) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 500 | (1/2, 1/2) | 데이터를 학습하여 수정한 확률 | 플레이어E는 학습모드아님 / 플레이어F는 학습모드 | . hint: 플레이어F는 보를 내는 것이 낫다고 생각할 것이다. (가위를 내면 지거나 비기지만 보를 내면 지거나 이긴다.) . (7) (6)번의 플레이어E와 플레이어F가 500회~1000회까지 추가로 게임을 한다. 이번에는 플레이어E만 데이터로부터 학습한다. 1000회까지 대결을 끝낸 이후 플레이어E가 (가위,바위)를 내는 확률은 어떻게 업데이트 되었는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (1/2, 1/2) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 500 | (1/2, 1/2) | 데이터를 학습하여 수정한 확률 | 플레이어E는 학습모드아님 / 플레이어F는 학습모드 | . t &lt;= 1000 | 데이터를 학습하여 수정한 확률 | t=500시점에 업데이트된 확률 | 플레이어E는 학습모드 / 플레이어F는 학습모드아님 | . hint: 플레이어F는 보를 내도록 학습되어 있다. 따라서 플레이어E가 바위를 내면 지고 가위를 내면 이길것이다. 따라서 플레이어E는 가위가 유리하다고 생각할 것이다. . (8) (7)번의 플레이어E와 플레이어F가 1000회~30000회까지 추가로 게임을 한다. 이번에는 플레이어F만 데이터로부터 학습한다. 30000회까지 대결을 끝낸 이후 플레이어F가 (가위,보)를 내는 확률은 어떻게 업데이트 되었는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (1/2, 1/2) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 500 | (1/2, 1/2) | 데이터를 학습하여 수정한 확률 | 플레이어E는 학습모드아님 / 플레이어F는 학습모드 | . t &lt;= 1000 | 데이터를 학습하여 수정한 확률 | t=500시점에 업데이트된 확률 | 플레이어E는 학습모드 / 플레이어F는 학습모드아님 | . t &lt;= 30000 | t=1000시점에 업데이트된 확률 | 데이터를 학습하여 수정한 확률 | 플레이어E는 학습모드아님 / 플레이어F는 학습모드 | . hint: 플레이어F는 원래 보가 유리하다고 생각하여 보를 자주 내도록 학습되었다. 하지만 플레이어E가 그러한 플레이어F의 성향을 파악하고 가위를 주로 내도록 학습하였다. 플레이어F는 그러한 플레이어E의 성향을 다시 파악하여 이번에는 가위을 자주 내는 것이 유리하다고 생각할 것이다. . (9) 플레이어E와 플레이어F의 대결기록을 초기화 한다. 이번에는 플레이어F가 항상 (3/4)의 확률로 가위를 (1/4)의 확률로 보를 낸다고 가정한다. 플레이어E는 100번의 대결까지는 랜덤으로 (가위,바위)중 하나를 내고 101번째 대결부터 1000번째 대결까지는 대결 데이터를 학습하여 수정한 확률을 사용한다고 하자. 1000번째 대결이후에 플레이어E가 (가위,바위)를 내는 확률이 어떻게 업데이트 되어있는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (3/4, 1/4) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 1000 | 데이터를 학습하여 수정한 확률 | (3/4, 1/4) | 플레이어E는 학습모드 / 플레이어F는 학습모드 아님 | . (10) 플레이어E와 플레이어F의 대결기록을 초기화 한다. 이번에는 플레이어F가 항상 (2/3)의 확률로 가위를 (1/3)의 확률로 보를 낸다고 가정한다. 플레이어E는 100번의 대결까지는 랜덤으로 (가위,바위)중 하나를 내고 101번째 대결부터 1000번째 대결까지는 대결 데이터를 학습하여 수정한 확률을 사용한다고 하자. 1000번째 대결이후에 플레이어E가 (가위,바위)를 내는 확률이 어떻게 업데이트 되어있는가? . 시점 플레이어E가 (가위,바위)를 낼 확률 플레이어F가 (가위,보)를 낼 확률 비고 . t &lt;= 100 | (1/2, 1/2) | (2/3, 1/3) | 양쪽 플레이어 모두 학습모드가 아님 | . t &lt;= 1000 | 데이터를 학습하여 수정한 확률 | (2/3, 1/3) | 플레이어E는 학습모드 / 플레이어F는 학습모드 아님 | . Appendix . - 아래의 클래스를 참고하여 문제1,2을 풀어라. (5월25일 강의노트에 소개된 클래스를 약간 정리한 것) . 참고하지 않아도 감점은 없음 | . class RPC: def __init__(self,candidate): self.candidate = candidate self.actions = list() self.rewards = list() self.prob = [0.5,0.5] def __eq__(self,other): # 연산 == 를 재정의 return self.actions[-1] == other.actions[-1] #note: 둘의 액션이 같으면 무승부 def __gt__(self,other): # 연산 &gt; 를 재정의 pair = self.actions[-1], other.actions[-1] return pair == (&#39;가위&#39;,&#39;보&#39;) or pair == (&#39;바위&#39;,&#39;가위&#39;) or pair == (&#39;보&#39;,&#39;바위&#39;) #note: 가위&gt;보, 바위&gt;가위, 보&gt;가위 def __mul__(self,other): # step1: 각자의 패를 선택 self.choose() other.choose() # step2: 승패 판단 + upate reward if self == other: # 무승부일경우 self.rewards.append(1) other.rewards.append(1) elif self &gt; other: # self의 승리 self.rewards.append(2) other.rewards.append(0) else: # other의 승리 self.rewards.append(0) other.rewards.append(2) # step3: update data self.update_data() other.update_data() def update_data(self): self.data = pd.DataFrame({&#39;actions&#39;:self.actions, &#39;rewards&#39;:self.rewards}) def _repr_html_(self): html_str = &quot;&quot;&quot; 낼 수 있는 패: {} &lt;br/&gt; 데이터: &lt;br/&gt; {} &quot;&quot;&quot; return html_str.format(self.candidate,self.data._repr_html_()) def choose(self): self.actions.append(np.random.choice(self.candidate,p=self.prob)) . - 사용예시 . a=RPC([&#39;가위&#39;,&#39;가위&#39;]) b=RPC([&#39;가위&#39;,&#39;보&#39;]) . for i in range(5): a*b . a . 낼 수 있는 패: [&#39;가위&#39;, &#39;가위&#39;] 데이터: actions rewards . 0 가위 | 2 | . 1 가위 | 2 | . 2 가위 | 1 | . 3 가위 | 2 | . 4 가위 | 2 | . b . 낼 수 있는 패: [&#39;가위&#39;, &#39;보&#39;] 데이터: actions rewards . 0 보 | 0 | . 1 보 | 0 | . 2 가위 | 1 | . 3 보 | 0 | . 4 보 | 0 | .",
            "url": "https://guebin.github.io/IP2022/2022/06/13/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC.html",
            "relUrl": "/2022/06/13/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC.html",
            "date": " • Jun 13, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "2021년 1학기 파이썬입문 기말고사 (풀이포함)",
            "content": "# 1. (20&#51216;) . N사에서 게임유저들에게 여름방학 기념이벤트로 진명왕의 집판검이라는 이름의 아이템을 선물했다고 하자. 진명왕의 집판검은 총 5회에 걸쳐서 강화(upgrade)될 수 있데 강화의 성공확률은 10%라고 하자. 강화가 5번성공하면 더 이상 강화가 진행되지 않는다고 하자. (따라서 더 이상 강화시도를 하지 않아도 무방하다) 아래는 이 아이템에 강화를 진행하였을때 각 강화상태를 설명한 예시이다. . 시도횟수 강화성공여부 강화상태 비고 . 1 | 강화실패 | +0 $ to$ +0 | 강화실패로 인하여 강화상태 변화없음 | . 2 | 강화성공 | +0 $ to$ +1 | 강화성공으로 인한 강화상태 변화 | . 3 | 강화실패 | +1 $ to$ +1 | 강화실패로 인하여 강화상태 변화없음 | . 4 | 강화성공 | +1 $ to$ +2 | 강화성공으로 인한 강화상태 변화 | . 5 | 강화성공 | +2 $ to$ +3 | 강화성공으로 인한 강화상태 변화 | . 6 | 강화성공 | +3 $ to$ +4 | 강화성공으로 인한 강화상태 변화 | . 7 | 강화실패 | +4 $ to$ +4 | 강화실패로 인하여 강화상태 변화없음 | . 8 | 강화성공 | +4 $ to$ +5 | 모든 강화 성공 | . 9 | - | +5 $ to$ +5 | 더 이상 강화시도 하지 않음 | . 10 | $ dots$ | $ dots$ | $ dots$ | . 강화는 하루에 한 번씩만 시도할 수 있으며 시도가능한 기간은 7월1일부터 8월31일까지로 한정되어 있다고 하자. 따라서 방학동안 유저들은 총 62번 시도를 할 수 있다. 방학이 끝난이후 100명 유저중 대략 몇명정도 +5 강화상태에 있겠는가? 파이썬을 통한 시뮬레이션을 활용하여 추론하라. (단, +5강화에 성공하지 못한 모든 유저는 반드시 하루에 한번 강화를 시도해야 한다고 가정하자.) . (풀이1) . import numpy as np np.random.seed(1) sum(np.random.binomial(n=62, p=0.1, size=10000)&gt;=5)/10000 . 0.7514 . (풀이2) . class ExecutionSword(): def __init__(self,prob): self.nuser=100000 self.prob=prob self.attemptresult=None self.upgradestate=pd.DataFrame({&#39;day0&#39;:[0]*self.nuser}) self.failstate=pd.DataFrame({&#39;day0&#39;:[0]*self.nuser}) self.ratio=0 self.day=0 def addday(self): self.day=self.day+1 def attempt(self): self.attemptresult = np.random.binomial(n=1, p=self.prob, size=self.nuser) def update(self): # 강화상태 업데이트 self.upgradestate[&#39;day%s&#39; % self.day] = np.minimum(5,self.upgradestate[&#39;day%s&#39; % (self.day-1)]+self.attemptresult) # 강화실패누적횟수 업데이트 self.failstate[&#39;day%s&#39; % self.day]=self.failstate[&#39;day%s&#39; % (self.day-1)]+(self.attemptresult==0)*1 # 강화상태==5 or 강화상태==0 일 경우 강화실패누적횟수 초기화 self.failstate[&#39;day%s&#39; % self.day][self.upgradestate[&#39;day%s&#39; % self.day]== 0]=0 self.failstate[&#39;day%s&#39; % self.day][self.upgradestate[&#39;day%s&#39; % self.day]== 5]=0 def reset(self): # 실패횟수 = 2 인것을 찾아 index_ 에 저장 -&gt; index_ 에 해당하는 유저의 강화횟수와 실패횟수를 모두 0으로 초기화 index_= self.failstate[&#39;day%s&#39; % self.day]==2 self.failstate[&#39;day%s&#39; % self.day][index_] = 0 self.upgradestate[&#39;day%s&#39; % self.day][index_] = 0 def arrangeprob(self): self.ratio=sum(self.upgradestate[&#39;day%s&#39; % self.day]==5) / self.nuser if self.ratio &gt; 0.5: self.prob = 0.9 . import pandas as pd s1=ExecutionSword(0.1) for i in range(62): s1.addday() s1.attempt() s1.update() . sum(s1.upgradestate.day62==5)/s1.nuser . 0.75551 . # 2. (70&#51216;) . 강화성공확률을 40%로 수정한다. 강화에 누적2회 실패하면 강화상태가 초기화 된다고 하자. (따라서 강화실패 누적횟수를 카운트하는 변수가 필요하다) 단, 강화실패 누적횟수는 누적2회 달성시 0으로 초기화 된다. 또한 강화상태가 +0인 경우는 실패하여도 강화실패 누적횟수가 추가되지 않는다. . 시도횟수 강화성공여부 강화상태 강화실패누적 비고 . 1 | 강화성공 | +0 $ to$ +1 | 0 $ to$ 0 | - | . 2 | 강화성공 | +1 $ to$ +2 | 0 $ to$ 0 | - | . 3 | 강화실패 | +2 $ to$ +2 | 0 $ to$ 1 | - | . 4 | 강화성공 | +2 $ to$ +3 | 1 $ to$ 1 | - | . 5 | 강화실패 | +3 $ to$ +0 | 1 $ to$ 0 | 강화실패로 누적2회로 인한 초기화 | . 6 | 강화실패 | +0 $ to$ +0 | 0 $ to$ 0 | 강화실패 누적횟수 증가하지 않음 | . 7 | 강화성공 | +0 $ to$ +1 | 0 $ to$ 0 | - | . 8 | 강화성공 | +1 $ to$ +2 | 0 $ to$ 0 | - | . 9 | 강화성공 | +2 $ to$ +3 | 0 $ to$ 0 | - | . 10 | 강화성공 | +3 $ to$ +4 | 0 $ to$ 0 | - | . 11 | 강화성공 | +4 $ to$ +5 | 0 $ to$ 0 | 모든 강화 성공 | . 12 | - | +5 $ to$ +5 | 0 $ to$ 0 | 더 이상 강화시도 하지 않음 | . 13 | $ dots$ | $ dots$ | $ dots$ | $ dots$ | . (1) 이 경우 62일의 방학뒤에 100명의 유저중 대략 몇명정도 +5 강화상태에 있겠는가? 시뮬레이션을 활용하여 추론하라. (단, +5강화에 성공하지 못한 모든 유저는 반드시 하루에 한번 강화를 시도해야 한다고 가정하자.) . (2) 31번째 시도 이후 대략 몇명의 유저가 +5 강화상태에 있겠는가? . s2=ExecutionSword(0.4) . for i in range(62): s2.addday() s2.attempt() s2.update() s2.reset() ## 초기화가 되는 조건이 있으므로 문제1에서 reset함수만 추가하면 된다. . sum(s2.upgradestate.day31==5)/s2.nuser . 0.36392 . sum(s2.upgradestate.day62==5)/s2.nuser . 0.61803 . (3) 100명의 유저중 50명이상의 유저가 +5 강화상태에 도달하는 순간 모든 유저의 강화성공확률을 90%로 증가시킨다고 하자. 62일의 방학뒤에 100명의 유저 중 몇명 정도가 +5 강화상태에 있겠는가? . s3=ExecutionSword(0.4) . for i in range(62): s3.addday() s3.attempt() s3.update() s3.reset() ## 초기화가 되는 조건이 있으므로 reset함수 추가 s3.arrangeprob() ## 전체유저의 50%가 강화성공하면 강화확률이 조정되는 조건이 있으므로 arragneprob 추가 . sum(s3.upgradestate.day62==5)/s3.nuser . 0.9993 .",
            "url": "https://guebin.github.io/IP2022/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2022/06/09/2021%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC-(%ED%92%80%EC%9D%B4%ED%8F%AC%ED%95%A8).html",
            "relUrl": "/%ED%8C%8C%EC%9D%B4%EC%8D%AC/2022/06/09/2021%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EA%B8%B0%EB%A7%90%EA%B3%A0%EC%82%AC-(%ED%92%80%EC%9D%B4%ED%8F%AC%ED%95%A8).html",
            "date": " • Jun 9, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "(14주차) 6월6일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 클래스 공부 7단계 (1) . - (2/8) 클래스 공부 7단계 (2) . - (3/8) 클래스 공부 7단계 (3) . - (4/8) 클래스 공부 8단계 . - (5/8) 클래스 공부 9단계 (1) . - (6/8) 클래스 공부 9단계 (2) . - (7/8) 클래스 공부 10단계 (1) . - (8/8) 클래스 공부 10단계 (2) . imports . import numpy as np import matplotlib.pyplot as plt import pandas as pd . &#53364;&#47000;&#49828;&#44277;&#48512; 7&#45800;&#44228; . &#54632;&#49688;&#44277;&#48512; . - 다시 함수를 공부해봅시다. . def f(x): return x+1 . f(3) . 4 . - 함수의 사용방법? . 입력으로 변수 x를 받음 = 입력으로 인스턴스 x를 받음. | 출력으로 변수 x+1을 리턴 = 출력으로 인스턴스 x+1을 리턴. | . - 사실1: 파이썬에서 함수는 인스턴스를 입력으로 받고 인스턴스를 출력한다. . - 함수의 자료형? . ?f . Signature: f(x) Docstring: &lt;no docstring&gt; File: /tmp/ipykernel_3296343/2907208198.py Type: function . type이 functiond이다. | f는 function class의 instance이다. | 결국 f 역시 하나의 오브젝트에 불과하다. | . - 사실2: 함수도 결국 인스턴스이다. -&gt; 함수의 입력으로 함수를 쓸 수도 있고 함수의 출력으로 함수가 나올 수도 있다. . &#54632;&#49688;&#54805; &#54532;&#47196;&#44536;&#47000;&#48141; . (예제1) 숫자입력, 함수출력 . def f(a): def _f(x): return (x-a)**2 return _f . g=f(10) # g(x)=(x-10)**2 . g(2) # (2-10)**2 = 64 . 64 . 해석: f(a)는 a를 입력으로 받고 g(x)=(x-a)^2 를 함수를 리턴해주는 함수 | . (예제1)의 다른표현: 익명함수 lambda . 표현1 . def f(a): _f = lambda x: (x-a)**2 ### lambda x: (x-a)**2 가 실행되는 순간 함수오브젝트가 만들어지고 그것이 _f 로 저장됨 return _f . g=f(10) # g(x)=(x-10)**2 . g(3) # (3-10)**2 = 49 . 49 . 표현2 . def f(a): return lambda x: (x-a)**2 . g=f(10) # g(x)=(x-10)**2 . g(3) # (3-10)**2 = 49 . 49 . lambda x: (x-a)**2 는 $ text{lambda}(x) = (x-a)^2$의 느낌으로 기억하면 외우기 쉽다. | lambda x: (x-a)**2 는 &quot;아직 이름이 없는 함수오브젝트를 (가칭 lambda 라고 하자) 만들고 기능은 x를 입력으로 하고 (x-a)**2를 출력하도록 하자&quot; 라는 뜻으로 해석하면 된다. | . (예제2) 함수입력, 숫자출력 . def f(x): return x**2 . def d(f,x): # 함수를 입력을 받는 함수를 정의 h=0.000000000001 return (f(x+h)-f(x))/h . d(f,4) # f&#39;(4) = 2*4 = 8 . 8.000711204658728 . (예제3) 함수입력, 함수출력 . def f(x): return x**2 . def derivate(f): def df(x): h=0.000000000001 return (f(x+h)-f(x))/h return df . ff = derivate(f) . ff(7) # f의 도함수 . 14.004797321831575 . 원래함수 시각화 . x = np.linspace(-1,1,100) plt.plot(x,f(x)) . [&lt;matplotlib.lines.Line2D at 0x7f68c528e820&gt;] . 도함수 시각화 . x = np.linspace(-1,1,100) plt.plot(x,ff(x)) . [&lt;matplotlib.lines.Line2D at 0x7f68c495bd60&gt;] . (예제3)의 다른표현 . def f(x): return x**2 . def derivate(f): h=0.000000000001 return lambda x: (f(x+h)-f(x))/h . ff = derivate(f) . ff(10) . 20.00888343900442 . (예제4) 함수들의 리스트 . flst = [lambda x: x, lambda x: x**2, lambda x: x**3] flst . [&lt;function __main__.&lt;lambda&gt;(x)&gt;, &lt;function __main__.&lt;lambda&gt;(x)&gt;, &lt;function __main__.&lt;lambda&gt;(x)&gt;] . for f in flst: print(f(2)) . 2 4 8 . for f in flst: plt.plot(x,f(x),&#39;--&#39;) . 위의코드는 아래와 같음 . plt.plot(x,(lambda x: x)(x),&#39;--&#39;) plt.plot(x,(lambda x: x**2)(x),&#39;--&#39;) plt.plot(x,(lambda x: x**3)(x),&#39;--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f68c2dbd640&gt;] . &#51221;&#47532; . - 지금까지 개념 . 함수: 변수를 입력으로 받아서 변수를 출력하는 개념 | 변수: 어떠한 값을 저장하는 용도로 쓰거나 함수의 입력 혹은 출력으로 사용함 | . - 파이썬의 함수형프로그래밍을 잘하려면? . 변수든 함수이든 둘다 인스턴스임. | 변수를 함수처럼: 메소드 | 함수를 변수처럼($ star$): 함수자체를 함수의 입력으로 혹은 출력으로 쓸 수도 있음. 함수를 특정 값처럼 생각해서 함수들의 list를 만들 수도 있다. | . callable object . - 함수 오브젝트의 비밀? . f = lambda x: x+1 . lst=[1,2,3] . set(dir(f)) &amp; {&#39;__call__&#39;} . {&#39;__call__&#39;} . 함수 오브젝트에는 숨겨진 기능 __call__이 있다. | . f.__call__(3) # f(3) . 4 . f.__call__(4) # f(4) . 5 . 여기에 우리가 정의한 내용이 있다. | . - 함수처럼 쓸 수 없는 인스턴스는 단지 call이 없는 것일 뿐이다. . class Klass: def __init__(self): self.name=&#39;guebin&#39; . a=Klass() . a() . TypeError Traceback (most recent call last) Input In [302], in &lt;cell line: 1&gt;() -&gt; 1 a() TypeError: &#39;Klass&#39; object is not callable . a는 callable이 아니라고 한다. | . class Klass2(Klass): # 상속 def __call__(self): print(self.name) . b=Klass2() . b() . guebin . b는 callable object! 즉 숨겨진 메서드로 __call__를 가진 오브젝트! | Klass는 callable object를 만들지 못하지만 Klass2는 callable object를 만든다. | . - 클래스로 함수를 만들기 . class AddConstant: def __init__(self,c): self.c = c def __call__(self,a): return a + self.c . f = AddConstant(3) # callable object생성, f.c에는 3이 저장되어있음. . f(5) # f.c 와 5를 더하는 기능을 수행, # f(x) = x+3 을 수행함 . 8 . f(10) . 13 . - 클래스도 그러고보니까 오브젝트 아니었나? 클래스도 함수처럼 Klass()와 같이 사용하면 인스턴스를 만들었음. -&gt; Klass.__call__() 은 Klass()와 같은 역할을 할 것이다. . class Klass: def __init__(self): self.name=&#39;hynn&#39; . a=Klass.__call__() # 이것이 a=Klass() 와 같은 효과 . a.name . &#39;hynn&#39; . &#54028;&#51060;&#50028;&#51032; &#48708;&#48128; 1~4 . 파이썬의 비밀1: 자료형은 클래스의 이름이다. | 파이썬의 비밀2: 클래스에는 __str__처럼 숨겨진 메서드가 존재한다. 이를 이용하여 파이썬 내부의 기능을 가로챌 수 있다. | 파이썬의 비밀3: 주피터노트북에서는 &quot;오브젝트이름+엔터&quot;를 쳐서 나오는 출력은 __repr__로 가로챌 수 있따. (주피터의 비밀) | 파이썬의 비밀4: 함수와 클래스는 숨겨진 메소드에 __call__을 가진 오브젝트일 뿐이다. | . &#53364;&#47000;&#49828;&#44277;&#48512; 8&#45800;&#44228; . for&#47928;&#51032; &#48373;&#49845; . - 아래와 같은 예제들을 관찰하여 for문을 복습하자. . (예제1) . for i in [1,2,3,4]: print(i) . 1 2 3 4 . (예제2) . for i in (1,2,3,4): print(i) . 1 2 3 4 . (예제3) . for i in &#39;1234&#39;: print(i) . 1 2 3 4 . (예제4) . a=5 for i in a: print(i) . TypeError Traceback (most recent call last) Input In [338], in &lt;cell line: 2&gt;() 1 a=5 -&gt; 2 for i in a: 3 print(i) TypeError: &#39;int&#39; object is not iterable . 5라고 출력되어야 하지 않나? | . - 의문1: . for i in ???: print(i) . 에서 ??? 자리에 올수 있는 것이 무엇일까? . (예제5) . 상황1 . lst = [[1,2,3,4],[3,4,5,6]] for l in lst: print(l) . [1, 2, 3, 4] [3, 4, 5, 6] . 상황2 . df=pd.DataFrame(lst) df . 0 1 2 3 . 0 1 | 2 | 3 | 4 | . 1 3 | 4 | 5 | 6 | . for i in df: print(i) . 0 1 2 3 . 칼럼이름들이 나오는것 같음 -&gt; 확인해보자. . df.columns = pd.Index([&#39;X&#39;+str(i) for i in range(1,5)]) df . X1 X2 X3 X4 . 0 1 | 2 | 3 | 4 | . 1 3 | 4 | 5 | 6 | . for i in df: print(i) . X1 X2 X3 X4 . - 의문2: for의 출력결과는 어떻게 예측할 수 있을까? . for&#47928;&#51032; &#46041;&#51089;&#50896;&#47532; . - 의문1의 해결: 아래의 ??? 자리에 올 수 있는 것은 dir()하여 __iter__가 있는 object이다. . for i in ???: print(i) . 이러한 오브젝트를 iterable object라고 한다. . - 확인 . a=[1,2,3] set(dir(a)) &amp; {&#39;__iter__&#39;} . {&#39;__iter__&#39;} . a=1,2,3 set(dir(a)) &amp; {&#39;__iter__&#39;} . {&#39;__iter__&#39;} . a=&#39;123&#39; set(dir(a)) &amp; {&#39;__iter__&#39;} . {&#39;__iter__&#39;} . a=5 set(dir(a)) &amp; {&#39;__iter__&#39;} . set() . 예상대로 예제1~4에서는 int의 클래스의 instance만 __iter__ 가 없다. | . - __iter__의 역할: iterable object를 iterator로 만들 수 있다! . lst = [1,2,3] lst . [1, 2, 3] . lst[1] # 충실한 리스트 . 2 . ltor = iter(lst) #ltor = lst.__iter__() ltor . &lt;list_iterator at 0x7f68c2fe1460&gt; . ltor[1] # 더이상 리스트가 아니다 . TypeError Traceback (most recent call last) Input In [369], in &lt;cell line: 1&gt;() -&gt; 1 ltor[1] TypeError: &#39;list_iterator&#39; object is not subscriptable . ltor? . Type: list_iterator String form: &lt;list_iterator object at 0x7f68c2fe1460&gt; Docstring: &lt;no docstring&gt; . - iterator가 되면 무엇이 좋은가? -&gt; 숨겨진 기능 __next__가 열린다. . set(dir(lst)) &amp; {&#39;__next__&#39;}, set(dir(ltor)) &amp; {&#39;__next__&#39;} . (set(), {&#39;__next__&#39;}) . lst에는 __next__가 없지만 ltor에는 있다! | . - 그래서 __next__의 기능은? -&gt; 원소를 차례대로 꺼내준다 + 더 이상 꺼낼 원소가 없으면 StopIteration Error를 발생시킨다. . lst . [1, 2, 3] . ltor.__next__() . 1 . ltor.__next__() . 2 . ltor.__next__() . 3 . ltor.__next__() . StopIteration Traceback (most recent call last) Input In [379], in &lt;cell line: 1&gt;() -&gt; 1 ltor.__next__() StopIteration: . - for문의 동작원리 . for i in lst: print(i) . (1) lst.__iter__() 혹은 iter(lst) 를 이용하여 lst를 iterator로 만든다. (iterable object를 iterator object로 만든다) . (2) iterator에서 .__next__()함수를 호출하고 결과를 i에 저장한뒤에 for문 블락안에 있는 내용 (들여쓰기 된 내용)을 실행한다. -&gt; 반복 . (3) StopIteration 에러가 발생하면 for문을 멈춘다. . - 아래의 ??? 자리에 올 수 있는 것이 iterable object가 아니라 iterator 자체이여도 for문이 돌아갈까? (당연히 돌아가야 할 것 같음) . for i in ???: print(i) . for i in iter([1,2,3]): print(i) . 1 2 3 . 당연히가능! | . - a가 iterator일때 iter(a) 의 출력결과가 a와 같도록 조정한다면 for문의 동작원리 (1)-(3)을 수정하지 않아도 좋다. -&gt; 실제로 이렇게 동작한다. . - 요약 . iterable object는 숨겨진 기능으로 __iter__를 가진다. | iterator object는 숨겨진 기능으로 __iter__와 __next__를 가진다. (즉 iterator는 그 자체로 iterable object가 된다!) | . lst = [1,2,3] ltor = iter(lst) . set(dir(lst)) &amp; {&#39;__iter__&#39;, &#39;__next__&#39;} . {&#39;__iter__&#39;} . set(dir(ltor)) &amp; {&#39;__iter__&#39;, &#39;__next__&#39;} . {&#39;__iter__&#39;, &#39;__next__&#39;} . - 의문2의 해결: for의 출력결과는 어떻게 예측할 수 있을까? iterator를 만들어서 .__next__()의 출력값을 확인하면 알 수 있다. . for i in df: print(i) . X1 X2 X3 X4 . dftor=iter(df) dftor.__next__() . &#39;X1&#39; . dftor.__next__() . &#39;X2&#39; . dftor.__next__() . &#39;X3&#39; . dftor.__next__() . &#39;X4&#39; . dftor.__next__() . StopIteration Traceback (most recent call last) Input In [404], in &lt;cell line: 1&gt;() -&gt; 1 dftor.__next__() StopIteration: . range() . - 파이썬에서 for문을 처음 배울 때: range(5)를 써라! . for i in range(5): print(i) . 0 1 2 3 4 . range(5)가 도데체 무엇이길래? | . - range(5)의 정체는 그냥 iterable object이다. . set(dir(range(5))) &amp; {&#39;__iter__&#39;,&#39;__next__&#39;} . {&#39;__iter__&#39;} . - 그래서 언제든지 iterator로 바꿀 수 있다. . rtor= iter(range(5)) rtor . &lt;range_iterator at 0x7f68c2ff2b70&gt; . set(dir(rtor)) &amp; {&#39;__iter__&#39;,&#39;__next__&#39;} . {&#39;__iter__&#39;, &#39;__next__&#39;} . - for문에서 range(5)가 행동하는 방법? . rtor = iter(range(5)) . rtor.__next__() . 0 . rtor.__next__() . 1 . rtor.__next__() . 2 . rtor.__next__() . 3 . rtor.__next__() . 4 . rtor.__next__() . StopIteration Traceback (most recent call last) Input In [423], in &lt;cell line: 1&gt;() -&gt; 1 rtor.__next__() StopIteration: . zip . - 이터레이터의 개념을 알면 for문에 대한 이해도가 대폭 상승한다. . for i in zip([1,2,3],&#39;abc&#39;): print(i) . (1, &#39;a&#39;) (2, &#39;b&#39;) (3, &#39;c&#39;) . zip은 뭐지? | . zip([1,2,3],&#39;abc&#39;) . &lt;zip at 0x7f68c2ff7bc0&gt; . - 어차피 for i in ????: 의 ???? 자리는 iterable object의 자리이다. . set(dir(zip([1,2,3],&#39;abc&#39;))) &amp; {&#39;__iter__&#39;,&#39;__next__&#39;} . {&#39;__iter__&#39;, &#39;__next__&#39;} . __next__()함수가 있음 $ to$ zip([1,2,3],&#39;abc&#39;)은 그자체로 iterator 였다! | . z= zip([1,2,3],&#39;abc&#39;) . z.__next__() . (1, &#39;a&#39;) . z.__next__() . (2, &#39;b&#39;) . z.__next__() . (3, &#39;c&#39;) . z.__next__() . StopIteration Traceback (most recent call last) Input In [433], in &lt;cell line: 1&gt;() -&gt; 1 z.__next__() StopIteration: . &#49324;&#50857;&#51088;&#51221;&#51032; &#51060;&#53552;&#47112;&#51060;&#53552; . - 내가 이터레이터를 만들어보자. . class Klass: # 찌를 내는순간 for문이 멈추도록 하는 이터레이터를 만들자 def __init__(self): self.candidate = [&quot;묵&quot;,&quot;찌&quot;,&quot;빠&quot;] def __iter__(self): return self def __next__(self): action = np.random.choice(self.candidate) if action == &quot;찌&quot;: print(&quot;찌가 나와서 for문을 멈춥니다&quot;) raise StopIteration else: return action . a= Klass() . set(dir(a)) &amp; {&#39;__iter__&#39;, &#39;__next__&#39;} # a는 이터레이터! . {&#39;__iter__&#39;, &#39;__next__&#39;} . a.__next__() . &#39;빠&#39; . a.__next__() . &#39;묵&#39; . a.__next__() . &#39;빠&#39; . a.__next__() . 찌가 나와서 for문을 멈춥니다 . StopIteration Traceback (most recent call last) Input In [458], in &lt;cell line: 1&gt;() -&gt; 1 a.__next__() Input In [435], in Klass.__next__(self) 8 if action == &#34;찌&#34;: 9 print(&#34;찌가 나와서 for문을 멈춥니다&#34;) &gt; 10 raise StopIteration 11 else: 12 return action StopIteration: . for i in a: print(i) . 빠 묵 묵 빠 찌가 나와서 for문을 멈춥니다 . &#54028;&#51060;&#50028;&#51032; &#48708;&#48128; 1~5 . 파이썬의 비밀1: 자료형은 클래스의 이름이다. | 파이썬의 비밀2: 클래스에는 __str__처럼 숨겨진 메서드가 존재한다. 이를 이용하여 파이썬 내부의 기능을 가로챌 수 있다. | 파이썬의 비밀3: 주피터노트북에서는 &quot;오브젝트이름+엔터&quot;를 쳐서 나오는 출력은 __repr__로 가로챌 수 있따. (주피터의 비밀) | 파이썬의 비밀4: 함수와 클래스는 숨겨진 메소드에 __call__을 가진 오브젝트일 뿐이다. | 파이썬의 비밀5: for문의 비밀 (iterable object, iterator, StopIteration Error) | . &#53364;&#47000;&#49828;&#44277;&#48512; 9&#45800;&#44228; . &#50696;&#48708;&#54617;&#49845; (&#48320;&#49688;&#51032; &#48276;&#50948;) . 커널을 재시작하고 아래를 관찰하자 . 예제1 . - 관찰1: 함수내의변수 출력 . def f(): x=10 print(x) . f() . 10 . - 관찰2: 함수내의 변수가 없을 경우 출력이 되지 않음 . def g(): print(x) . g() . NameError Traceback (most recent call last) Input In [4], in &lt;cell line: 1&gt;() -&gt; 1 g() Input In [3], in g() 1 def g(): -&gt; 2 print(x) NameError: name &#39;x&#39; is not defined . - 관찰3: 동일한 이름의 변수가 globald에 있다면 함수내에 (local에) 그 이름의 변수가 선언되지 않아도 global의 변수를 빌려서 사용함 . x=20 def g(): print(x) . g() . 20 . - 관찰4: f()가 실행되면서 x=10이 함수내에 (=local에) 실행되지만 이 결과가 외부의 x=20에 (=global에) 영향을 미치지는 못함 . f() . 10 . x . 20 . 예제2 . (코드1) . x = 38 def nextyear(): y= x+1 print(x,y) nextyear() . 38 39 . (코드2) . x = 38 def nextyear(): y= x+1 print(x,y) x= 0 nextyear() . UnboundLocalError Traceback (most recent call last) Input In [10], in &lt;cell line: 6&gt;() 4 print(x,y) 5 x= 0 -&gt; 6 nextyear() Input In [10], in nextyear() 2 def nextyear(): -&gt; 3 y= x+1 4 print(x,y) 5 x= 0 UnboundLocalError: local variable &#39;x&#39; referenced before assignment . - 해석: . 잘못된 해석: 코드1은 실행되었고, 코드2에서 에러가 났다. 코드1과 2의 차이점은 x=0 이라는 코드가 코드2에 추가로 포함되어있다는 것이다. 따라서 x=0이 잘못된 코드이고 이걸 실행하는 과정에서 에러가 발생했다. | 올바른 해석: 코드1에서는 x가 global variable 이고 코드2에서는 x가 local variable이어서 생기는 문제 | . - 코드2의 올바른 수정 . x = 38 def nextyear(): x= 0 y= x+1 print(x,y) nextyear() . 0 1 . &#51064;&#49828;&#53556;&#49828; &#48320;&#49688;, &#53364;&#47000;&#49828; &#48320;&#49688; (&#48373;&#49845;?) . - 예비학습이 주는 교훈 . (원칙1) global 에서 정의된 이름은 local 에서 정의된 이름이 없을 경우 그를 대신할 수 있다 (local은 경우에 따라서 global에 있는 변수를 빌려 쓸 수 있다) . (원칙2) local과 global에서 같은 이름 &#39;x&#39;가 각각 정의되어 있는 경우? global의 변수와 local의 변수는 각각 따로 행동하며 서로 영향을 주지 않는다. (독립적이다) . 만약에 local이 global의 변수를 같이 쓰고 있었다고 할지라도, 추후 새롭게 local에 새롭게 같은 이름의 변수가 정의된다면 그 순간 local과 global의 변수를 각자 따로 행동하며 서로 영향을 주지 않는다. $ to$ 아래예제확인 | . x= 10 def f(): print(x) . f() # x를 빌려쓰는 신세 . 10 . def f(): x=20 # 이제 새롭게 x를 정의했으니까 print(x) . f() # 다른길을 간다. . 20 . - 이전에 공부하였던 인스턴스변수와 클래스변수 역시 비슷한 행동을 보인다. . class Moo: x=0 # 클래스변수 . moo=Moo() . (관찰1) . Moo.x, moo.x . (0, 0) . moo.x는 사실 정의한적 없지만 Moo.x를 빌려쓰고 있다. (원칙1) | . (관찰2) . Moo.x = 100 . Moo.x, moo.x . (100, 100) . Moo.x 를 변화시키면 moo.x 도 변화한다 (빌려쓰고 있는 것이니까, 원칙1의 재확인) | . (관찰3) . moo.x = 200 . Moo.x, moo.x . (100, 200) . moo.x=200을 하는 순간 새롭게 인스턴스변수를 선언한 셈이된다. 따라서 원칙2가 적용되어 이제부터 Moo.x 와 moo.x 는 서로 독립적으로 행동한다. | . (관찰4) . Moo.x = - 99 . Moo.x, moo.x . (-99, 200) . moo.x = 99 . Moo.x, moo.x . (-99, 99) . Moo.x 를 바꾼다고 해서 moo.x 가 영향받지 않고 moo.x 를 바꿔도 Moo.x 가 영향받지 않음 (완전히 독립, 원칙2의 재확인) | . - 포인트: (1) 클래스변수와 인스턴스 변수의 구분 (2) 인스턴스 변수가 정의되지 않으면 클래스변수를 빌려쓸 수 있음 (3) 인스턴스변수와 클래스변수가 같은 이름으로 저장되어 있으면 각각 독립적으로 행동 . &#51064;&#49828;&#53556;&#49828; &#47700;&#49436;&#46300; . - self 비밀: 사실 클래스에서 정의된 함수의 첫번째 인자의 이름이 꼭 self일 필요는 없다. (무엇으로 전달하든 클래스안에서 정의된 메소드의 첫번째 인자는 기본적으로 instance의 태명역할을 한다) . class Moo: def __init__(abab): abab.name = &#39;guebin&#39; def f(cdcd): print(cdcd.name) . moo=Moo() . moo.name . &#39;guebin&#39; . moo.f() . guebin . - 인스턴스 메서드: 위의 __init__와 f와 같이 첫번째 인자를 인스턴스의 태명으로 받는 함수를 인스턴스 메서드 (간단히 메서드) 라고 한다. . 인스턴스 메소드는self.f()와 같이 사용한다. 의미는 f(self) 이다. | . moo.name = &#39;hynn&#39; . moo.__init__() # 인스턴스메서드의 사용예시: self.__init__()의 꼴로 사용 . moo.name . &#39;guebin&#39; . moo.f() # 인스턴스메서드의 사용예시: self.__init__()의 꼴로 사용 . guebin . - 아래와 같이 사용할 수 없다. . Moo.__init__() . TypeError Traceback (most recent call last) Input In [70], in &lt;cell line: 1&gt;() -&gt; 1 Moo.__init__() TypeError: __init__() missing 1 required positional argument: &#39;abab&#39; . Moo.f() . TypeError Traceback (most recent call last) Input In [71], in &lt;cell line: 1&gt;() -&gt; 1 Moo.f() TypeError: f() missing 1 required positional argument: &#39;cdcd&#39; . &#53364;&#47084;&#49828; &#47700;&#49436;&#46300; . - 클래스 메서드: 함수의 첫 인자로 클래스오브젝트를 받는 메서드를 클래스메서드라고 한다. . - 목표: Moo.f()와 같은 형태로 사용할 수 있는 함수를 만들어 보자 -&gt; 클래스메서드를 만들어보자! . class Moo: def f(self): print(&quot;인스턴스 메서드&quot;) . moo=Moo() . moo.f() . 인스턴스 메서드 . Moo.f() . TypeError Traceback (most recent call last) Input In [75], in &lt;cell line: 1&gt;() -&gt; 1 Moo.f() TypeError: f() missing 1 required positional argument: &#39;self&#39; . class Moo: @classmethod def f(cls): # 함수의 첫 인자로 클래스오브젝트를 받는다. cls는 클래스 Moo의 별명?이라고 생각하면 된다. print(&quot;클래스 메서드&quot;) . moo=Moo() . Moo.f() . 클래스 메서드 . moo.f() # 인스턴스 메서드를 따로 정의한적은 없지만 같은 이름의 클래스 메서드가 있으므로 빌려와서 씀! . 클래스 메서드 . - 예제 . class Moo: @classmethod def set_class_x(cls,value): # 클래스 메서드 cls.x = value # 클래스변수선언, note: Moo.x = value 와 같은 코드! def set_instance_x(self,value): # 인스턴스 메서드 self.x = value # 인스턴스 변수선언 . moo=Moo() . Moo.set_class_x(10) # 클래스메서드로 클래스변수에 10을 설정 . Moo.set_instance_x(10) # 클래스에서 인스턴스 메서드를 사용 -&gt; 사용불가 . TypeError Traceback (most recent call last) Input In [97], in &lt;cell line: 1&gt;() -&gt; 1 Moo.set_instance_x(10) TypeError: set_instance_x() missing 1 required positional argument: &#39;value&#39; . Moo.x, moo.x # 인스턴스변수는 따로 설정하지 않았지만 클래스 변수값을 빌려쓰고 있음 . (10, 10) . moo.set_class_x(20) # 인스턴스에서는 원래 set_class_x 라는 메서드는 없지만 클래스에서 빌려씀 . Moo.x, moo.x # 현재 moo.x는 클래스 변수를 빌려쓰고 있는 상황이므로 같이 바뀜 . (20, 20) . moo.set_instance_x(-20) # 인스턴스에서 인스턴스 메서드를 사용하여 인스턴스 변수값을 -20으로 설정 #-&gt; 이때부터 인스턴스변수와 클래스 변수는 서로 독립적인 노선을 간다. . Moo.x, moo.x . (20, -20) . Moo.set_class_x(30) # 독립적인 노선을 가기로 했으므로 클래스변수만 30으로 바뀜 Moo.x, moo.x . (30, -20) . moo.set_class_x(-40) # 여전히 인스턴스에서 set_class_x라는 함수는 없으므로 클래스메소드를 빌려쓰고 있음 Moo.x, moo.x . (-40, -20) . &#49828;&#53468;&#54001; &#47700;&#49436;&#46300; . - 스태틱 메서드: 첫 인자로 인스턴스와 클래스 모두 받지 않음. (클래스안에 정의되어 있지만 그냥 함수와 같음) . class Cals: @staticmethod def add(a,b): return a+b @staticmethod def sub(a,b): return a-b . fs = Cals() . fs.add(1,2) . 3 . fs.sub(1,2) . -1 . fs는 그냥 함수들을 묶어놓은 느낌? 정리하게 편하게? | . &#53364;&#47000;&#49828;&#44277;&#48512; 10&#45800;&#44228; . &#47928;&#51088;&#50676; join . - 예제 . lst = list(&#39;abcd&#39;) lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] . &#39;&#39;.join(lst) . &#39;abcd&#39; . - 해설: &#39;&#39;는 string object 이고 .join는 string object에 소속된 메서드이다. . a=&#39;&#39; a.join(lst) # join(a,lst) 와 같은 효과 . &#39;abcd&#39; . - join의 간단한 사용방법 . &#39;-&#39;.join(lst) . &#39;a-b-c-d&#39; . matplotlib . - 파이썬의 모든것은 객체이다: matplotlib의 다른 사용 (객체지향적 언어로 그림그리기!) . - 그림오브젝트 생성 . fig = plt.figure() # 그림오브젝트 생성되고 fig라는 이름이 붙음 . &lt;Figure size 432x288 with 0 Axes&gt; . - 그림오브젝트의 액시즈를 확인 -&gt; 아무것도 없음 . fig.axes . [] . - (0,0)자리에 (가로=1,세로=1) 크기의 액시즈를 넣어보자. . fig.add_axes([0,0,1,1]) . &lt;Axes:&gt; . fig.axes . [&lt;Axes:&gt;] . fig . - (0,1.2) 위치에 (가로=1,세로=1) 크기의 액시즈 추가 . fig.add_axes([0,1.2, 1,1]) fig . - (0.5,0.5) 위치에 (가로=1, 세로=1) 크기의 그림 추가 . fig.add_axes([0.5,0.5, 1,1]) . &lt;Axes:&gt; . fig . - fig의 세번째 액시즈에 접근 . a3 = fig.axes[2] # 이것역시 오브젝트임 a3 . &lt;Axes:&gt; . - 액시즈의 메소드중에 plot이 있음 -&gt; 이것으로 그림을 그려봄 . a3.plot([1,2,3],[4,5,3],&#39;--r&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f751cbfe040&gt;] . fig . - 다시 세번째 축에 접근하여 다른그림을 그려보자. . fig.axes[-1].plot([1,2,3],[5,4,3],&#39;:o&#39;) fig . - 이제 첫번째 축에 접근하여 새로운 그림을 그려보자. . fig.axes[0].plot([1,2,3],[4,1,4],&#39;--b&#39;) fig . - 클래스에 대한 이해가 없다면 위와 같은 그림을 그리기도 힘들고 코드를 해석하기도 힘듬 . &#52280;&#51312;&#50752; &#50640;&#51068;&#47532;&#50612;&#49905; . - 아래의 코드를 관찰하자. . a=[1,2,3] b=a a=a+[4] . 현재 a,b의 출력결과는? . a, b . ([1, 2, 3, 4], [1, 2, 3]) . - 이제 다시 아래의 코드를 관찰하자. . a=[1,2,3] b=a a.append(4) . 현재 a,b의 출력결과는? . a,b . ([1, 2, 3, 4], [1, 2, 3, 4]) . - 아래의 코드를 다시 살펴보자. . a=[1,2,3] b=a a.append(4) . a,b라는 변수들은 메모리에 어떻게 저장이 되어있을까? . 상상력을 조금 발휘하면 아래와 같이 여길 수 있다. . (1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. . (2) 아래를 실행하였을 경우 . a=[1,2,3] . 메모리주소1에 존재하는 방을 a라고 하고, 그 방에 [1,2,3]을 넣는다. | . (3) 아래를 실행하였을 경우 . b=a . 메모리주소38에 존재하는 방을 b라고 하고, 그 방에 a를 넣어야하는데, a는 [1,2,3]이니까 [1,2,3]을 넣는다. | . (4) 아래를 실행하면 . a.append(4) . 방 a로가서 [1,2,3]을 [1,2,3,4]로 바꾼다. | 그리고 방 b에는 아무것도 하지 않는다. | . - R에서는 맞는 비유인데, 파이썬은 적절하지 않은 비유이다. . id(a) . 139851743661952 . id(b) . 139851743661952 . 실제로는 a,b가 저장된 메모리 주소가 동일함 . - 파이썬에서는 아래가 더 적절한 비유이다. . (1) 메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자. . (2) 아래를 실행하였을 경우 . a=[1,2,3] . 메모리주소139851743661952에서 [1,2,3]을 생성해요 | 방 139851743661952의 방문에 a라는 포스트잇을 붙인다. | 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙은 방을 찾아가면 된다. | . (3) 아래를 실행하였을 경우 . b=a . a라는 포스트잇이 있는데, a라는 포스트잇이랑 b라는 포스트잇과 같은 효과를 주도록 한다. | 쉽게말하면 b라는 포스트잇을 방 139851743661952의 방문에 붙인다는 이야기. | 앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙어 있거나 b라는 포스트잇이 붙어있는 방을 찾아가면 된다. | . (4) 아래를 실행하면 . a.append(4) . a라는 포스트잇이 붙어있는 방으로 가서, 그 내용물 append함수를 써서 4를 추가하라. 즉 내용물 [1,2,3]을 [1,2,3,4]로 바꾸라. | 같은방에 a,b라는 포스트잇이 모두 붙어있음. 따라서 b라는 포스트잇이 붙은 방을 찾아가서 내용물을 열어보면 [1,2,3,4]가 나온다. | . - 결론: 파이썬의 모든것은 오브젝트이다. 그리고 모든 오브젝트는 메모리주소위에 올라간다. 하지만 그 메모리주소에 붙어있는 포스트잇이 하나라는 보장은 없다. .",
            "url": "https://guebin.github.io/IP2022/2022/06/06/(14%EC%A3%BC%EC%B0%A8)-6%EC%9B%946%EC%9D%BC.html",
            "relUrl": "/2022/06/06/(14%EC%A3%BC%EC%B0%A8)-6%EC%9B%946%EC%9D%BC.html",
            "date": " • Jun 6, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "(13주차) 5월30일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) 인사관리 예제 (1) . - (2/4) 인사관리 예제 (2) . - (3/4) 리스트의 상속 . - (4/4) 사용자정의 자료형의 유용함 . &#53364;&#47000;&#49828;&#44277;&#48512; 6&#45800;&#44228; . - 상속 . &#51064;&#49324;&#44288;&#47532; &#50696;&#51228; . - 아래와 같은 클래스를 만들자. . 이름, 직급, 연봉에 대한 정보가 있다. | 연봉을 올려주는 메소드가 존재함. | . class Employee: def __init__(self,name,position=None,pay=0): self.name = name self.position = position self.pay = pay def _repr_html_(self): html_str = &quot;&quot;&quot; 이름: {} &lt;br/&gt; 직급: {} &lt;br/&gt; 연봉: {} &lt;br/&gt; &quot;&quot;&quot;.format(self.name,self.position,self.pay) return html_str def giveraise(self,pct): self.pay = self.pay * (1+pct) . - 확인 . iu=Employee(&#39;iu&#39;,position=&#39;staff&#39;,pay=5000) hynn=Employee(&#39;hynn&#39;,position=&#39;staff&#39;,pay=4000) hd=Employee(&#39;hodong&#39;,position=&#39;mgr&#39;,pay=8000) . iu . 이름: iu 직급: staff 연봉: 5000 iu.giveraise(0.1) iu . 이름: iu 직급: staff 연봉: 5500.0 hynn.giveraise(0.2) hynn . 이름: hynn 직급: staff 연봉: 4800.0 - 회사의 모든 직원의 연봉을 10%씩 올려보자. . iu=Employee(&#39;iu&#39;,position=&#39;staff&#39;,pay=5000) hynn=Employee(&#39;hynn&#39;,position=&#39;staff&#39;,pay=4000) hd=Employee(&#39;hodong&#39;,position=&#39;mgr&#39;,pay=8000) . for i in [iu, hynn, hd]: i.giveraise(0.1) . iu . 이름: iu 직급: staff 연봉: 5500.0 hynn . 이름: hynn 직급: staff 연봉: 4400.0 hd . 이름: hodong 직급: mgr 연봉: 8800.0 - 매니저직급은 일반직원들의 상승분에서 5%의 보너스가 추가되어 상승한다고 가정하고 모든 직원의 연봉을 10%씩 올리는 코드를 구현해보자. . (구현1) . iu=Employee(&#39;iu&#39;,position=&#39;staff&#39;,pay=5000) hynn=Employee(&#39;hynn&#39;,position=&#39;staff&#39;,pay=4000) hd=Employee(&#39;hodong&#39;,position=&#39;mgr&#39;,pay=8000) . for i in [iu,hynn,hd]: if i.position == &#39;mgr&#39;: i.giveraise(0.1 + 0.05) else: i.giveraise(0.1) . iu . 이름: iu 직급: staff 연봉: 5500.0 hynn . 이름: hynn 직급: staff 연봉: 4400.0 hd . 이름: hodong 직급: mgr 연봉: 9200.0 (구현2) 새로운 클래스를 만들자 . class Manager: def __init__(self,name,position=None,pay=0): self.name = name self.position = position self.pay = pay def _repr_html_(self): html_str = &quot;&quot;&quot; 이름: {} &lt;br/&gt; 직급: {} &lt;br/&gt; 연봉: {} &lt;br/&gt; &quot;&quot;&quot;.format(self.name,self.position,self.pay) return html_str def giveraise(self,pct): self.pay = self.pay * (1+pct+0.05) . iu=Employee(&#39;iu&#39;,position=&#39;staff&#39;,pay=5000) hynn=Employee(&#39;hynn&#39;,position=&#39;staff&#39;,pay=4000) hd=Manager(&#39;hodong&#39;,position=&#39;mgr&#39;,pay=8000) . for i in [iu,hynn,hd]: i.giveraise(0.1) . iu . 이름: iu 직급: staff 연봉: 5500.0 hynn . 이름: hynn 직급: staff 연봉: 4400.0 hd . 이름: hodong 직급: mgr 연봉: 9200.000000000002 (구현3) 상속이용! . class Manager(Employee): def giveraise(self,pct): self.pay = self.pay * (1+pct+0.05) . iu=Employee(&#39;iu&#39;,position=&#39;staff&#39;,pay=5000) hynn=Employee(&#39;hynn&#39;,position=&#39;staff&#39;,pay=4000) hd=Manager(&#39;hodong&#39;,position=&#39;mgr&#39;,pay=8000) . for i in [iu,hynn,hd]: i.giveraise(0.1) . iu . 이름: iu 직급: staff 연봉: 5500.0 hynn . 이름: hynn 직급: staff 연봉: 4400.0 hd . 이름: hodong 직급: mgr 연봉: 9200.000000000002 - 요약: 이미 만들어진 클래스에서 대부분의 기능은 그대로 쓰지만 일부기능만 변경 혹은 추가하고 싶다면 클래스를 상속하면 된다! . &#47532;&#49828;&#53944;&#51032; &#49345;&#49549; . ref: http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791165213190 | . - list와 비슷한데 멤버들의 빈도가 계산되는 메소드를 포함하는 새로운 나만의 list를 만들고 싶다. . lst = [&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;c&#39;,&#39;b&#39;,&#39;a&#39;,&#39;d&#39;] lst . [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;d&#39;] . - 아래와 같은 딕셔너리를 만들고 싶다. . freq = {&#39;a&#39;:3, &#39;b&#39;:2, &#39;c&#39;:1, &#39;d&#39;:1} freq . {&#39;a&#39;: 3, &#39;b&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1} . lst.frequency()를 입력하면 위의 기능이 수행되도록 변형된 list를 쓰고 싶다. | . - 구현 . (시도1) 반쯤 성공? . lst . [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;d&#39;] . freq = {&#39;a&#39;:0, &#39;b&#39;:0, &#39;c&#39;:0, &#39;d&#39;:0} freq . {&#39;a&#39;: 0, &#39;b&#39;: 0, &#39;c&#39;: 0, &#39;d&#39;: 0} . for item in lst: freq[item] = freq[item] + 1 . freq . {&#39;a&#39;: 3, &#39;b&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1} . (시도2) 실패 . lst . [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;d&#39;] . freq = dict() freq . {} . for item in lst: freq[item] = freq[item] + 1 . KeyError Traceback (most recent call last) Input In [137], in &lt;cell line: 1&gt;() 1 for item in lst: -&gt; 2 freq[item] = freq[item] + 1 KeyError: &#39;a&#39; . 에러이유? freq[&#39;a&#39;]를 호출할 수 없다 -&gt; freq.get(&#39;a&#39;,0) 이용 . freq[&#39;a&#39;] . KeyError Traceback (most recent call last) Input In [138], in &lt;cell line: 1&gt;() -&gt; 1 freq[&#39;a&#39;] KeyError: &#39;a&#39; . freq.get? . Signature: freq.get(key, default=None, /) Docstring: Return the value for key if key is in the dictionary, else default. Type: builtin_function_or_method . key에 대응하는 값이 있으면 그 값을 리턴하고 없으면 default를 리턴 | . freq.get(&#39;a&#39;) # freq[&#39;a&#39;]에 해당하는 자료가 없어도 에러가 나지 않음 . freq.get(&#39;a&#39;,0) # freq[&#39;a&#39;]에 해당하는 자료가 없어도 에러가 나지 않음 + freq[&#39;a&#39;]에 해당하는 자료가 없으면 0을 리턴 . 0 . (시도3) . lst . [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;, &#39;d&#39;] . freq = dict() freq . {} . for item in lst: freq[item] = freq.get(item,0) + 1 . freq . {&#39;a&#39;: 3, &#39;b&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1} . - 이것을 내가 정의하는 새로운 list의 메소드로 넣고 싶다. . class L(list): def frequency(self): freq = dict() for item in self: freq[item] = freq.get(item,0) + 1 return freq . lst = L([1,1,1,2,2,3]) . lst # 원래 list에 있는 repr 기능을 상속받아서 이루어지는 결과 . [1, 1, 1, 2, 2, 3] . _lst = L([4,5,6]) lst + _lst # L자료형끼리의 덧셈 . [1, 1, 1, 2, 2, 3, 4, 5, 6] . lst + [4,5,6] # L자료형과 list자료형의 덧셈도 가능 . [1, 1, 1, 2, 2, 3, 4, 5, 6] . L자료형의 덧셈은 list의 덧셈과 완전히 같음 | . lst.append(10) # append함수도 그대로 쓸 수 있음 lst . [1, 1, 1, 2, 2, 3, 10] . - 기존리스트에서 추가로 frequency() 메소드가 존재함. . lst.frequency() . {1: 3, 2: 2, 3: 1, 10: 1} . Appendix: &#49324;&#50857;&#51088;&#51221;&#51032; &#51088;&#47308;&#54805;&#51032; &#50976;&#50857;&#54632; . - 사용자정의 자료형이 어떤 경우에는 유용할 수 있다. . import pandas as pd import numpy as np import matplotlib.pyplot as plt . - 예제1 . year = [&#39;2016&#39;,&#39;2017&#39;,&#39;2017&#39;,&#39;2017&#39;,2017,2018,2018,2019,2019] value = np.random.randn(9) . df= pd.DataFrame({&#39;year&#39;:year,&#39;value&#39;:value}) df . year value . 0 2016 | -0.053328 | . 1 2017 | -1.453440 | . 2 2017 | 0.951534 | . 3 2017 | -0.479833 | . 4 2017 | -0.891801 | . 5 2018 | -0.841571 | . 6 2018 | -0.945223 | . 7 2019 | 0.990534 | . 8 2019 | 0.433971 | . plt.plot(df.year,df.value) . TypeError Traceback (most recent call last) Input In [157], in &lt;cell line: 1&gt;() -&gt; 1 plt.plot(df.year,df.value) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/pyplot.py:3019, in plot(scalex, scaley, data, *args, **kwargs) 3017 @_copy_docstring_and_deprecators(Axes.plot) 3018 def plot(*args, scalex=True, scaley=True, data=None, **kwargs): -&gt; 3019 return gca().plot( 3020 *args, scalex=scalex, scaley=scaley, 3021 **({&#34;data&#34;: data} if data is not None else {}), **kwargs) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/axes/_axes.py:1605, in Axes.plot(self, scalex, scaley, data, *args, **kwargs) 1363 &#34;&#34;&#34; 1364 Plot y versus x as lines and/or markers. 1365 (...) 1602 (``&#39;green&#39;``) or hex strings (``&#39;#008000&#39;``). 1603 &#34;&#34;&#34; 1604 kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D) -&gt; 1605 lines = [*self._get_lines(*args, data=data, **kwargs)] 1606 for line in lines: 1607 self.add_line(line) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/axes/_base.py:315, in _process_plot_var_args.__call__(self, data, *args, **kwargs) 313 this += args[0], 314 args = args[1:] --&gt; 315 yield from self._plot_args(this, kwargs) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/axes/_base.py:496, in _process_plot_var_args._plot_args(self, tup, kwargs, return_kwargs) 493 x, y = index_of(xy[-1]) 495 if self.axes.xaxis is not None: --&gt; 496 self.axes.xaxis.update_units(x) 497 if self.axes.yaxis is not None: 498 self.axes.yaxis.update_units(y) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/axis.py:1448, in Axis.update_units(self, data) 1446 neednew = self.converter != converter 1447 self.converter = converter -&gt; 1448 default = self.converter.default_units(data, self) 1449 if default is not None and self.units is None: 1450 self.set_units(default) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/category.py:109, in StrCategoryConverter.default_units(data, axis) 107 # the conversion call stack is default_units -&gt; axis_info -&gt; convert 108 if axis.units is None: --&gt; 109 axis.set_units(UnitData(data)) 110 else: 111 axis.units.update(data) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/category.py:185, in UnitData.__init__(self, data) 183 self._counter = itertools.count() 184 if data is not None: --&gt; 185 self.update(data) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/category.py:220, in UnitData.update(self, data) 217 convertible = True 218 for val in OrderedDict.fromkeys(data): 219 # OrderedDict just iterates over unique values in data. --&gt; 220 _api.check_isinstance((str, bytes), value=val) 221 if convertible: 222 # this will only be called so long as convertible is True. 223 convertible = self._str_is_convertible(val) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/matplotlib/_api/__init__.py:92, in check_isinstance(_types, **kwargs) 90 names.remove(&#34;None&#34;) 91 names.append(&#34;None&#34;) &gt; 92 raise TypeError( 93 &#34;{!r} must be an instance of {}, not a {}&#34;.format( 94 k, 95 &#34;, &#34;.join(names[:-1]) + &#34; or &#34; + names[-1] 96 if len(names) &gt; 1 else names[0], 97 type_name(type(v)))) TypeError: &#39;value&#39; must be an instance of str or bytes, not a int . 에러의 이유: df.year에 str, int가 동시에 있음 . np.array(df.year) . array([&#39;2016&#39;, &#39;2017&#39;, &#39;2017&#39;, &#39;2017&#39;, 2017, 2018, 2018, 2019, 2019], dtype=object) . 자료형을 바꿔주면 해결할 수 있다. . np.array(df.year, dtype=np.float64) #np.array(df.year).astype(np.float64) #df.year.astype(np.float64) . array([2016., 2017., 2017., 2017., 2017., 2018., 2018., 2019., 2019.]) . plt.plot(df.year.astype(np.float64),df.value,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f68c5381ee0&gt;] . - 예제2 . year = [&#39;2016&#39;,&#39;2017&#39;,&#39;2017&#39;,&#39;2017년&#39;,&#39;2017년&#39;,2018,2018,2019,2019] value = np.random.randn(9) . df= pd.DataFrame({&#39;year&#39;:year,&#39;value&#39;:value}) df . year value . 0 2016 | -0.502215 | . 1 2017 | -0.646435 | . 2 2017 | -0.991310 | . 3 2017년 | -1.202340 | . 4 2017년 | 0.325500 | . 5 2018 | 0.539920 | . 6 2018 | -1.565858 | . 7 2019 | -0.286726 | . 8 2019 | -1.780535 | . np.array(df.year,dtype=np.float64) # 타입을 일괄적으로 바꾸기 어렵다. . ValueError Traceback (most recent call last) Input In [176], in &lt;cell line: 1&gt;() -&gt; 1 np.array(df.year,dtype=np.float64) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/series.py:872, in Series.__array__(self, dtype) 825 def __array__(self, dtype: npt.DTypeLike | None = None) -&gt; np.ndarray: 826 &#34;&#34;&#34; 827 Return the values as a NumPy array. 828 (...) 870 dtype=&#39;datetime64[ns]&#39;) 871 &#34;&#34;&#34; --&gt; 872 return np.asarray(self._values, dtype) ValueError: could not convert string to float: &#39;2017년&#39; . L(df.year).frequency() . {&#39;2016&#39;: 1, &#39;2017&#39;: 2, &#39;2017년&#39;: 2, 2018: 2, 2019: 2} . &#39;2016&#39;와 같은 형태, &#39;2017년&#39;와 같은 형태, 숫자형이 혼합 -&gt; 맞춤형 변환이 필요함 | . &#39;2017년&#39;.replace(&quot;년&quot;,&quot;&quot;) . &#39;2017&#39; . L(df.year) . [&#39;2016&#39;, &#39;2017&#39;, &#39;2017&#39;, &#39;2017년&#39;, &#39;2017년&#39;, 2018, 2018, 2019, 2019] . def f(a): ## 사실 데이터의 구조를 모르면 이런 함수를 짤 수 없음 --&gt; 자료의 구조를 확인해준다는 의미에서 freq가 있다면 편리하다. if type(a) is str: if &quot;년&quot; in a: return int(a.replace(&quot;년&quot;,&quot;&quot;)) else: return int(a) else: return a . [f(a) for a in df.year] . [2016, 2017, 2017, 2017, 2017, 2018, 2018, 2019, 2019] . df.year= [f(a) for a in df.year] . df . year value . 0 2016 | -0.502215 | . 1 2017 | -0.646435 | . 2 2017 | -0.991310 | . 3 2017 | -1.202340 | . 4 2017 | 0.325500 | . 5 2018 | 0.539920 | . 6 2018 | -1.565858 | . 7 2019 | -0.286726 | . 8 2019 | -1.780535 | . plt.plot(df.year, df.value, &#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f68c33c6550&gt;] .",
            "url": "https://guebin.github.io/IP2022/2022/05/30/(13%EC%A3%BC%EC%B0%A8)-5%EC%9B%9430%EC%9D%BC.html",
            "relUrl": "/2022/05/30/(13%EC%A3%BC%EC%B0%A8)-5%EC%9B%9430%EC%9D%BC.html",
            "date": " • May 30, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "(13주차) 5월25일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) __add__ (1) . - (2/4) __add__ (2) . - (3/4) __add__ (3) . - (4/4) __mul__ . imports . import numpy as np . &#53364;&#47000;&#49828;&#44277;&#48512; 5&#45800;&#44228; . - 지난시간까지 배운것: RPC자료형에 한정해서 print()등의 기능을 조작할 수 있었다. (재정의 할 수 있었다) . - 이번시간에 배울것: 특정자료형에 한정하여 print 이외의 파이썬 내부기능을 조작하여 보자. (재정의하여 보자) . motive . - 아래의 연산구조를 관찰하자. . a=1 b=2 a+b . 3 . a라는 인스턴스와 b라는 인스턴스를 +라는 기호가 연결하고 있다. | . - 이번에는 아래의 연산구조를 관찰하자. . a=[1,2] b=[3,4] a+b . [1, 2, 3, 4] . a라는 인스턴스와 b라는 인스턴스를 +라는 기호가 연결하고 있다. | . - 동작이 다른 이유? . 클래스를 배우기 이전: int자료형의 +는 &quot;정수의 덧셈&quot;을 의미하고 list자료형의 +는 &quot;자료의 추가&quot;를 의미한다. | 클래스를 배운 이후: 아마 클래스는 +라는 연산을 정의하는 숨겨진 메소드가 있을것이다. (print가 그랬듯이) 그리고 int클래스에서는 그 메소드를 &quot;정수의 덧셈&quot;이 되도록 정의하였고 list클래스에서는 그 메소드를 &quot;자료의 추가&quot;를 의미하도록 정의하였다. | . - 아래의 결과를 관찰 . a=1 b=2 . a.__add__(b) . 3 . b.__add__(a) . 3 . a=[1,2] b=[3,4] . a.__add__(b) . [1, 2, 3, 4] . b.__add__(a) . [3, 4, 1, 2] . - a+b는 사실 내부적으로 a.__add__(b)의 축약구문이다. 따라서 만약 a.__add__(b)의 기능을 바꾸면 (재정의하면) a+b의 기능도 바뀔 것이다. . __add__ . - 학생예제 . class Student: def __init__(self,age=20.0, semester=0): self.age = age self.semester = semester print(&quot;입학을 축하합니다. 당신의 나이는 {}이고 현재 학기는 {}학기 입니다.&quot;.format(self.age,self.semester)) def __add__(self,val): # val == 0: 휴학 # val == 1: 등록 if val==0: self.age=self.age+0.5 elif val==1: self.age=self.age+0.5 self.semester= self.semester+1 def _repr_html_(self): html_str = &quot;&quot;&quot; 나이: {} &lt;br/&gt; 학기: {} &lt;br/&gt; &quot;&quot;&quot; return html_str.format(self.age,self.semester) . iu= Student() . 입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다. . iu . 나이: 20.0 학기: 0 iu + 1 ## 1학년 1학기 등록 iu . 나이: 20.5 학기: 1 iu + 0 ## 휴학함 iu . 나이: 21.0 학기: 1 - 연산을 연속으로 하고 싶다. . iu + 1 + 0 + 0 + 0 + 0 . TypeError Traceback (most recent call last) Input In [109], in &lt;cell line: 1&gt;() -&gt; 1 iu + 1 + 0 + 0 + 0 + 0 TypeError: unsupported operand type(s) for +: &#39;NoneType&#39; and &#39;int&#39; . - 에러의 이유? . (되는코드) . (1+1)+1 # 1+1+1은 이렇게 볼 수 있다 . 3 . _a = (1+1) type(_a) . int . _a+1 # 이 연산은 int인스턴스 + int인스턴스 . 3 . (안되는코드) . iu+1+1 . TypeError Traceback (most recent call last) Input In [113], in &lt;cell line: 1&gt;() -&gt; 1 iu+1+1 TypeError: unsupported operand type(s) for +: &#39;NoneType&#39; and &#39;int&#39; . _a=iu+1 type(_a) . NoneType . _a+1 . TypeError Traceback (most recent call last) Input In [115], in &lt;cell line: 1&gt;() -&gt; 1 _a+1 TypeError: unsupported operand type(s) for +: &#39;NoneType&#39; and &#39;int&#39; . - 에러를 해결하는 방법: iu+1의 결과로 Student클래스의 인스턴스가 리턴되면 된다. . class Student: def __init__(self,age=20.0, semester=0): self.age = age self.semester = semester print(&quot;입학을 축하합니다. 당신의 나이는 {}이고 현재 학기는 {}학기 입니다.&quot;.format(self.age,self.semester)) def __add__(self,val): # val == 0: 휴학 # val == 1: 등록 if val==0: self.age=self.age+0.5 elif val==1: self.age=self.age+0.5 self.semester= self.semester+1 return self def _repr_html_(self): html_str = &quot;&quot;&quot; 나이: {} &lt;br/&gt; 학기: {} &lt;br/&gt; &quot;&quot;&quot; return html_str.format(self.age,self.semester) . iu = Student() . 입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다. . iu+1 # __add__의 return에 Student클래스의 인스턴스가 리턴되면서 자동으로 _repr_html_() 실행 . 나이: 20.5 학기: 1 iu+1 +0+0+0+0 . 나이: 23.0 학기: 2 __mul__ . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() self.results = list() def __mul__(self,other): self.choose() other.choose() if self.actions[-1]==&#39;가위&#39; and other.actions[-1]==&#39;가위&#39;: self.results.append(0) other.results.append(0) if self.actions[-1]==&#39;가위&#39; and other.actions[-1]==&#39;바위&#39;: self.results.append(-1) other.results.append(1) if self.actions[-1]==&#39;가위&#39; and other.actions[-1]==&#39;보&#39;: self.results.append(1) other.results.append(-1) if self.actions[-1]==&#39;바위&#39; and other.actions[-1]==&#39;가위&#39;: self.results.append(1) other.results.append(-1) if self.actions[-1]==&#39;바위&#39; and other.actions[-1]==&#39;바위&#39;: self.results.append(0) other.results.append(0) if self.actions[-1]==&#39;바위&#39; and other.actions[-1]==&#39;보&#39;: self.results.append(-1) other.results.append(1) if self.actions[-1]==&#39;보&#39; and other.actions[-1]==&#39;가위&#39;: self.results.append(-1) other.results.append(1) if self.actions[-1]==&#39;보&#39; and other.actions[-1]==&#39;바위&#39;: self.results.append(1) other.results.append(-1) if self.actions[-1]==&#39;보&#39; and other.actions[-1]==&#39;보&#39;: self.results.append(0) other.results.append(0) def choose(self): self.actions.append(np.random.choice(self.candidate)) def _repr_html_(self): html_str = &quot;&quot;&quot; 낼 수 있는 패: {} &lt;br/&gt; 액션: {} &lt;br/&gt; 승패: {} &quot;&quot;&quot; return html_str.format(self.candidate,self.actions,self.results) . a=RPC() b=RPC() . a . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 액션: [] 승패: [] b . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 액션: [] 승패: [] a*b . a . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 액션: [&#39;보&#39;] 승패: [-1] b . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 액션: [&#39;가위&#39;] 승패: [1] for i in range(5): a*b . a . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 액션: [&#39;보&#39;, &#39;가위&#39;, &#39;바위&#39;, &#39;바위&#39;, &#39;가위&#39;, &#39;보&#39;] 승패: [-1, -1, 0, 1, -1, 1] b . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 액션: [&#39;가위&#39;, &#39;바위&#39;, &#39;바위&#39;, &#39;가위&#39;, &#39;바위&#39;, &#39;바위&#39;] 승패: [1, 1, 0, -1, 1, -1] for i in range(50000): a*b . sum(a.results)/len(a.results) . -0.005739311282646082 . sum(b.results)/len(a.results) . 0.005739311282646082 . &#49689;&#51228; . RPC클래스에서 player a와 player b를 만들어라. Player a는 [&#39;가위&#39;,&#39;보&#39;] 중에 하나를 낼 수 있다. 그리고 Player b는 [&#39;가위&#39;,&#39;바위&#39;] 중에 하나를 낼 수 있다. 두 player는 가지고 있는 패를 (같은확률로) 랜덤으로 낸다. (즉 player a가 가위만 내거나 보만 내는 경우는 없다.) . (1) 누가 더 유리한가? 이유를 스스로 생각해보라. (이유를 정리하여 숙제로 제출할 필요 없음) . (2) 50000번의 시뮬레이션을 해보고 결과를 분석해보라. .",
            "url": "https://guebin.github.io/IP2022/2022/05/25/(13%EC%A3%BC%EC%B0%A8)-5%EC%9B%9425%EC%9D%BC.html",
            "relUrl": "/2022/05/25/(13%EC%A3%BC%EC%B0%A8)-5%EC%9B%9425%EC%9D%BC.html",
            "date": " • May 25, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "(12주차) 5월23일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) motivating example . - (2/4) __str__, 파이썬의 비밀2 . - (3/4) __repr__, 파이썬의 비밀3 . - (4/4) 주피터노트북의 비밀 (_repr_html_), __repr__와 __str__의 우선적용 순위 . imports . import numpy as np . &#53364;&#47000;&#49828;&#44277;&#48512; 4&#45800;&#44228; . Motivating Example . - 가위바위보 . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate def throw(self): print(np.random.choice(self.candidate)) . a=RPC() # __init__는 암묵적으로 실행 . a.throw() . 보 . - 생각해보니까 throw는 choose + show 의 결합인것 같다. . class RPC: ## 시점1 def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate def choose(self): self.actions = np.random.choice(self.candidate) def show(self): print(self.actions) . a=RPC() ## 시점2 . a.actions ## 시점3 . AttributeError Traceback (most recent call last) Input In [90], in &lt;cell line: 1&gt;() -&gt; 1 a.actions AttributeError: &#39;RPC&#39; object has no attribute &#39;actions&#39; . a.choose() ## 시점4 . a.actions ## 시점5 . &#39;가위&#39; . a.show() ## 시점6 . 가위 . 보충학습: 위와 같은코드 . class _RPC: ## 시점1 pass # &lt;- 이렇게하면 아무기능이 없는 비어있는 클래스가 정의된다 . _a = _RPC() ## 시점2 def _init(_a,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): _a.candidate = candidate _init(_a) . _a.actions ## 시점3 . AttributeError Traceback (most recent call last) Input In [102], in &lt;cell line: 1&gt;() -&gt; 1 _a.actions AttributeError: &#39;_RPC&#39; object has no attribute &#39;actions&#39; . def _choose(_a): ## 시점4 _a.actions = np.random.choice(_a.candidate) _choose(_a) . _a.actions ## 시점5 . &#39;보&#39; . def _show(_a): ## 시점6 print(_a.actions) _show(_a) . 보 . - 또 다른 인스턴스 b를 만들자. b는 가위만 낼 수 있다. . b=RPC([&#39;가위&#39;]) . b.candidate . [&#39;가위&#39;] . b.choose() b.show() . 가위 . - a,b의 선택들을 모아서 기록을 하고 싶다. . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) . a=RPC() b=RPC([&#39;가위&#39;]) . for i in range(5): a.choose() a.show() . 바위 보 바위 보 가위 . a.actions . [&#39;바위&#39;, &#39;보&#39;, &#39;바위&#39;, &#39;보&#39;, &#39;가위&#39;] . for i in range(5): b.choose() b.show() . 가위 가위 가위 가위 가위 . b.actions . [&#39;가위&#39;, &#39;가위&#39;, &#39;가위&#39;, &#39;가위&#39;, &#39;가위&#39;] . - info라는 함수를 만들어서 a,b 오브젝트가 가지고 있는 정보를 모두 보도록 하자. . (예비학습) 문자열 n이 포함된다면? . &#39;asdf n1234&#39; . &#39;asdf n1234&#39; . print(&#39;asdf n1234&#39;) . asdf 1234 . 예비학습 끝 . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def info(self): print(&quot;낼 수 있는 패: {} n기록: {}&quot;.format(self.candidate,self.actions)) . a=RPC() b=RPC([&#39;가위&#39;]) . for i in range(5): a.choose() a.show() . 가위 보 보 바위 보 . for i in range(5): b.choose() b.show() . 가위 가위 가위 가위 가위 . a.info() . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [&#39;가위&#39;, &#39;보&#39;, &#39;보&#39;, &#39;바위&#39;, &#39;보&#39;] . b.info() . 낼 수 있는 패: [&#39;가위&#39;] 기록: [&#39;가위&#39;, &#39;가위&#39;, &#39;가위&#39;, &#39;가위&#39;, &#39;가위&#39;] . - 만들고보니까 info와 print의 기능이 거의 비슷함 $ to$ print(a)를 하면 a.info()와 동일한 효과를 내도록 만들 수 있을까? . - 말도 안되는 소리같다. 왜? . 이유1: print는 파이썬 내장기능, 내장기능을 우리가 맘대로 커스터마이징해서 쓰기는 어려울 것 같다. | 이유2: 이유1이 해결된다고 쳐도 문제다. 그럼 지금까지 우리가 사용했던 수 많은 print()의 결과는 어떻게 되는가? | . - 그런데 a의 자료형(RPC자료형)에 해당하는 오브젝트들에 한정하여 print를 수정하는 방법이 가능하다면? (그럼 다른 오브젝트들은 수정된 print에 영향을 받지 않음) . __str__ . - 관찰1: 현재 print(a)의 결과는 아래와 같다. . print(a) . &lt;__main__.RPC object at 0x7fef32fef8b0&gt; . a는 RPC클래스에서 만든 오브젝트이며 a가 저장된 메모리 주소는 0x7fef32fef8b0라는 의미 | . - 관찰2: a에는 __str__이 있다. . set(dir(a)) &amp; {&#39;__str__&#39;} . {&#39;__str__&#39;} . 이것을 함수처럼 사용하니까 아래와 같이 된다. . a.__str__() . &#39;&lt;__main__.RPC object at 0x7fef32fef8b0&gt;&#39; . ?? print(a)를 해서 나오는 문자열이 리턴된다.. . print(a.__str__()) # 이거 print(a)를 실행한 결과와 같다? . &lt;__main__.RPC object at 0x7fef32fef8b0&gt; . - 생각: 만약에 내가 a.__str__()라는 함수를 재정의하여 리턴값을 &#39;guebin hahaha&#39;로 바꾸게 되면 print(a)해서 나오는 결과는 어떻게 될까? (약간 해커같죠) . (예비학습) 함수덮어씌우기 . def f(): print(&#39;asdf&#39;) . f() . asdf . def f(): print(&#39;guebin hahaha&#39;) . f() . guebin hahaha . 이런식으로 함수가 이미 정의되어 있더라도, 내가 나중에 덮어씌우면 그 함수의 기능을 다시 정의한다. . (해킹시작) . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def __str__(self): return &#39;guebin hahaha&#39; def info(self): print(&quot;낼 수 있는 패: {} n기록: {}&quot;.format(self.candidate,self.actions)) . a=RPC() . print(a) . guebin hahaha . print(a.__str__()) . guebin hahaha . - __str__의 리턴값을 info에서 타이핑했던 문자열로 재정의한다면? . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def __str__(self): return &quot;낼 수 있는 패: {} n기록: {}&quot;.format(self.candidate,self.actions) . a=RPC() . print(a) . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [] . a.choose() a.show() . 보 . print(a) . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [&#39;보&#39;] . &#54028;&#51060;&#50028;&#51032; &#48708;&#48128;2 . - print(a)와 print(a.__str__())는 같은 문법이다. . - 참고로 a.__str__()와 str(a)도 같은 문법이다. . a.__str__() . &#34;낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] n기록: [&#39;보&#39;]&#34; . str(a) . &#34;낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] n기록: [&#39;보&#39;]&#34; . - 지금까지 우리가 썼던 기능들 확인! . (예제1) . a=[1,2,3] . print(a) . [1, 2, 3] . a.__str__() . &#39;[1, 2, 3]&#39; . str(a) . &#39;[1, 2, 3]&#39; . (예제2) . a={1,2,3} print(a) . {1, 2, 3} . a.__str__() . &#39;{1, 2, 3}&#39; . str(a) . &#39;{1, 2, 3}&#39; . (예제3) . a=np.array(1) a.shape . () . print(a.shape) . () . a.shape.__str__() . &#39;()&#39; . str(a.shape) . &#39;()&#39; . (예제4) . a=range(10) print(a) . range(0, 10) . a.__str__() . &#39;range(0, 10)&#39; . str(a) . &#39;range(0, 10)&#39; . (예제5) . a = np.arange(100).reshape(10,10) print(a) . [[ 0 1 2 3 4 5 6 7 8 9] [10 11 12 13 14 15 16 17 18 19] [20 21 22 23 24 25 26 27 28 29] [30 31 32 33 34 35 36 37 38 39] [40 41 42 43 44 45 46 47 48 49] [50 51 52 53 54 55 56 57 58 59] [60 61 62 63 64 65 66 67 68 69] [70 71 72 73 74 75 76 77 78 79] [80 81 82 83 84 85 86 87 88 89] [90 91 92 93 94 95 96 97 98 99]] . a.__str__() . &#39;[[ 0 1 2 3 4 5 6 7 8 9] n [10 11 12 13 14 15 16 17 18 19] n [20 21 22 23 24 25 26 27 28 29] n [30 31 32 33 34 35 36 37 38 39] n [40 41 42 43 44 45 46 47 48 49] n [50 51 52 53 54 55 56 57 58 59] n [60 61 62 63 64 65 66 67 68 69] n [70 71 72 73 74 75 76 77 78 79] n [80 81 82 83 84 85 86 87 88 89] n [90 91 92 93 94 95 96 97 98 99]]&#39; . str(a) . &#39;[[ 0 1 2 3 4 5 6 7 8 9] n [10 11 12 13 14 15 16 17 18 19] n [20 21 22 23 24 25 26 27 28 29] n [30 31 32 33 34 35 36 37 38 39] n [40 41 42 43 44 45 46 47 48 49] n [50 51 52 53 54 55 56 57 58 59] n [60 61 62 63 64 65 66 67 68 69] n [70 71 72 73 74 75 76 77 78 79] n [80 81 82 83 84 85 86 87 88 89] n [90 91 92 93 94 95 96 97 98 99]]&#39; . __repr__ . - 생각해보니까 print를 해서 우리가 원하는 정보를 확인하는건 아니었음 . a=[1,2,3] . a . [1, 2, 3] . print(a) . [[1 2] [3 4]] . - a + 엔터는 print(a) + 엔터와 같은효과인가? . (반례) . a=np.array([1,2,3,4]).reshape(2,2) . a . array([[1, 2], [3, 4]]) . print(a) . [[1 2] [3 4]] . - a + 엔터는 print(a) + 엔터가 다른 경우도 있다. $ to$ 추측: 서로 다른 숨겨진 기능이 있다! $ to$ 결론: 추측이 맞다. 그 기능은 __repr__에 저장되어있음. . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def __repr__(self): return &quot;낼 수 있는 패: {} n기록: {}&quot;.format(self.candidate,self.actions) . a=RPC() . a # print(a.__repr__()) . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [] . - 그럼 우리가 지금까지 했던것은? . a = np.array([1,2,3]) . a . array([1, 2, 3]) . print(a) . [1 2 3] . a.__repr__() . &#39;array([1, 2, 3])&#39; . a.__str__() . &#39;[1 2 3]&#39; . &#54028;&#51060;&#50028;&#51032; &#48708;&#48128;3 . - 대화형콘솔에서 오브젝트이름+엔터를 쳐서 나오는 출력은 __repr__의 결과와 연관있다. . a = np.array(range(10000)).reshape(100,100) a . array([[ 0, 1, 2, ..., 97, 98, 99], [ 100, 101, 102, ..., 197, 198, 199], [ 200, 201, 202, ..., 297, 298, 299], ..., [9700, 9701, 9702, ..., 9797, 9798, 9799], [9800, 9801, 9802, ..., 9897, 9898, 9899], [9900, 9901, 9902, ..., 9997, 9998, 9999]]) . a.__repr__() . &#39;array([[ 0, 1, 2, ..., 97, 98, 99], n [ 100, 101, 102, ..., 197, 198, 199], n [ 200, 201, 202, ..., 297, 298, 299], n ..., n [9700, 9701, 9702, ..., 9797, 9798, 9799], n [9800, 9801, 9802, ..., 9897, 9898, 9899], n [9900, 9901, 9902, ..., 9997, 9998, 9999]])&#39; . - 참고로 a.__repr__()은 repr(a)와 같다. . repr(a) . &#39;array([[ 0, 1, 2, ..., 97, 98, 99], n [ 100, 101, 102, ..., 197, 198, 199], n [ 200, 201, 202, ..., 297, 298, 299], n ..., n [9700, 9701, 9702, ..., 9797, 9798, 9799], n [9800, 9801, 9802, ..., 9897, 9898, 9899], n [9900, 9901, 9902, ..., 9997, 9998, 9999]])&#39; . &#51452;&#54588;&#53552;&#45432;&#53944;&#48513;&#51032; &#48708;&#48128; (_repr_html_) . - 요즘에는 IDE의 발전에 따라서 오브젝트이름+엔터칠떄 나오는 출력의 형태도 다양해지고 있음 . import pandas as pd . df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]}) . df . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . 예쁘게나온다. | . - 위의결과는 print(df.__repr__())의 결과와 조금 다르게 나온다? . print(df.__repr__()) . a b 0 1 2 1 2 3 2 3 4 . - print(df.__repr__())는 예전 검은화면에서 코딩할때가 나오는 출력임 . Python 3.10.2 | packaged by conda-forge | (main, Feb 1 2022, 19:28:35) [GCC 9.4.0] on linux Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt; &gt;&gt; import pandas as pd &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;:[1,2,3],&#39;b&#39;:[2,3,4]})&gt;&gt;&gt; df a b 0 1 2 1 2 3 2 3 4 &gt;&gt;&gt; . - 주피터에서는? &quot;오브젝트이름+엔터&quot;치면 HTML(df._repr_html_())이 실행되고, _repr_html_()이 정의되어 있지 않으면 print(df.__repr__())이 실행된다. . df._repr_html_() . &#39;&lt;div&gt; n&lt;style scoped&gt; n .dataframe tbody tr th:only-of-type { n vertical-align: middle; n } n n .dataframe tbody tr th { n vertical-align: top; n } n n .dataframe thead th { n text-align: right; n } n&lt;/style&gt; n&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt; n &lt;thead&gt; n &lt;tr style=&#34;text-align: right;&#34;&gt; n &lt;th&gt;&lt;/th&gt; n &lt;th&gt;a&lt;/th&gt; n &lt;th&gt;b&lt;/th&gt; n &lt;/tr&gt; n &lt;/thead&gt; n &lt;tbody&gt; n &lt;tr&gt; n &lt;th&gt;0&lt;/th&gt; n &lt;td&gt;1&lt;/td&gt; n &lt;td&gt;2&lt;/td&gt; n &lt;/tr&gt; n &lt;tr&gt; n &lt;th&gt;1&lt;/th&gt; n &lt;td&gt;2&lt;/td&gt; n &lt;td&gt;3&lt;/td&gt; n &lt;/tr&gt; n &lt;tr&gt; n &lt;th&gt;2&lt;/th&gt; n &lt;td&gt;3&lt;/td&gt; n &lt;td&gt;4&lt;/td&gt; n &lt;/tr&gt; n &lt;/tbody&gt; n&lt;/table&gt; n&lt;/div&gt;&#39; . html코드! | . from IPython.core.display import HTML . HTML(df._repr_html_()) . a b . 0 1 | 2 | . 1 2 | 3 | . 2 3 | 4 | . - 물론 df._repr_html_()함수가 내부적으로 있어도 html이 지원되지 않는 환경이라면 print(df.__repr__())이 내부적으로 수행된다. . __repr__&#50752; __str__&#51032; &#50864;&#49440;&#51201;&#50857; &#49692;&#50948; . (예제1) . - 아래의 예제를 관찰하자. . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def __repr__(self): return &quot;낼 수 있는 패: {} n기록: {}&quot;.format(self.candidate,self.actions) . a=RPC() a . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [] . a.__repr__() . &#34;낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] n기록: []&#34; . repr(a) . &#34;낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] n기록: []&#34; . - 여기까지는 상식수준의 결과임. 이제 아래를 관찰하라. . print(a) # print(a.__str__()) . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [] . a.__str__() . &#34;낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] n기록: []&#34; . str(a) . &#34;낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] n기록: []&#34; . __str__()은 건드린적이 없는데? $ to$ 건드린적은 없는데 기능이 바껴있음 | . a.__str__?? . Signature: a.__str__() Call signature: a.__str__(*args, **kwargs) Type: method-wrapper String form: &lt;method-wrapper &#39;__str__&#39; of RPC object at 0x7fef9f7465c0&gt; Docstring: Return str(self). . a.__repr__?? . Signature: a.__repr__() Docstring: Return repr(self). Source: def __repr__(self): return &#34;낼 수 있는 패: {} n기록: {}&#34;.format(self.candidate,self.actions) File: /tmp/ipykernel_288989/831267894.py Type: method . (예제2) . - 아래의 예제를 관찰하자. . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def __str__(self): return &quot;낼 수 있는 패: {} n기록: {}&quot;.format(self.candidate,self.actions) . a=RPC() . print(a) . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [] . a . &lt;__main__.RPC at 0x7fef9f747b80&gt; . a.__str__() . &#34;낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] n기록: []&#34; . a.__repr__() . &#39;&lt;__main__.RPC object at 0x7fef9f747b80&gt;&#39; . a.__str__?? . Signature: a.__str__() Docstring: Return str(self). Source: def __str__(self): return &#34;낼 수 있는 패: {} n기록: {}&#34;.format(self.candidate,self.actions) File: /tmp/ipykernel_288989/183356077.py Type: method . a.__repr__?? . Signature: a.__repr__() Call signature: a.__repr__(*args, **kwargs) Type: method-wrapper String form: &lt;method-wrapper &#39;__repr__&#39; of RPC object at 0x7fef9f747b80&gt; Docstring: Return repr(self). . (예제3) . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def __repr__(self): return &quot;guebin hahaha&quot; def __str__(self): return &quot;낼 수 있는 패: {} n기록: {}&quot;.format(self.candidate,self.actions) . a=RPC() . a . guebin hahaha . print(a) . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [] . - __str__와 __repr__을 건드리지 않고 출력결과를 바꾸고 싶다면? . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def _repr_html_(self): html_str = &quot;&quot;&quot; 낼 수 있는 패: {} &lt;br/&gt; 기록: {} &quot;&quot;&quot; return html_str.format(self.candidate,self.actions) . a=RPC() . str(a) . &#39;&lt;__main__.RPC object at 0x7fef9f75a890&gt;&#39; . repr(a) . &#39;&lt;__main__.RPC object at 0x7fef9f75a890&gt;&#39; . a . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [] for i in range(5): a.choose() a.show() . 가위 가위 보 보 바위 . a . 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [&#39;가위&#39;, &#39;가위&#39;, &#39;보&#39;, &#39;보&#39;, &#39;바위&#39;] &#49689;&#51228; . 아래의 클래스를 수정하여 . class RPC: def __init__(self,candidate=[&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]): self.candidate = candidate self.actions = list() def choose(self): self.actions.append(np.random.choice(self.candidate)) def show(self): print(self.actions[-1]) def _repr_html_(self): html_str = &quot;&quot;&quot; 낼 수 있는 패: {} &lt;br/&gt; 기록: {} &quot;&quot;&quot; return html_str.format(self.candidate,self.actions) . 클래스에서 생성된 인스턴스의 출력결과가 아래와 같도록 하라. . 학번: 202143052 낼 수 있는 패: [&#39;가위&#39;, &#39;바위&#39;, &#39;보&#39;] 기록: [&#39;가위&#39;, &#39;가위&#39;, &#39;보&#39;, &#39;보&#39;, &#39;바위&#39;] .",
            "url": "https://guebin.github.io/IP2022/2022/05/23/(12%EC%A3%BC%EC%B0%A8)-5%EC%9B%9423%EC%9D%BC.html",
            "relUrl": "/2022/05/23/(12%EC%A3%BC%EC%B0%A8)-5%EC%9B%9423%EC%9D%BC.html",
            "date": " • May 23, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "(12주차) 5월18일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/6) 오브젝트의 개념 . - (2/6) 예제1 . - (3/6) 예제2,3,4 . - (4/6) 예제5 . - (5/6) 예제 6,7 . - (6/6) 숙제설명 . &#53364;&#47000;&#49828; &#44277;&#48512; 3&#45800;&#44228; . - 이 단계에서는 클래스오브젝트에 소속된 변수와 인스턴스오브젝트에 소속된 변수를 설명한다. . &#50724;&#48652;&#51229;&#53944;&#51032; &#44060;&#45392; . - 파이썬은 모든 것이 오브젝트로 이루어져 있다. &lt;- 우선은 그냥 명언처럼 외우세요 . - 오브젝트는 메모리주소에 저장되는 모든것을 의미한다. . a=1 id(a) # 메모리주소를 보는 명령어 . 140193842610416 . a=&#39;asdf&#39; id(a) . 140193794777968 . a=[1,2,3] id(a) . 140193794512384 . - 클래스와 인스턴스도 오브젝트다 . class A: x=0 def f(self): print(self.x) . id(A) . 94740835761168 . A는 오브젝트 | . a=A() . id(a) . 140193794535776 . a는 오브젝트 | . b=A() . id(b) . 140193794529632 . b는 오브젝트 | . - 앞으로는 A를 클래스오브젝트, a,b를 인스턴스오브젝트라고 부르자. . &#50696;&#51228;1: &#53364;&#47000;&#49828;&#48320;&#49688;, &#51064;&#49828;&#53556;&#49828;&#48320;&#49688; . - 시점0 . class A: x=0 y=0 def f(self): self.x = self.x + 1 A.y = A.y + 1 print(&quot;현재 인스턴스에서 f가 {}번 실행&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행&quot;.format(self.y)) . A.x, A.y . (0, 0) . - 시점1 . a = A() . b = A() . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 0], [0, 0], [0, 0]) . - 시점2 . a.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 1], [1, 1], [0, 1]) . - 시점3 . b.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 2번 실행 . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 2], [1, 2], [1, 2]) . - 시점4 . b.f() . 현재 인스턴스에서 f가 2번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 3번 실행 . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 3], [1, 3], [2, 3]) . - 시점5 . a.f() . 현재 인스턴스에서 f가 2번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 4번 실행 . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 4], [2, 4], [2, 4]) . - 시점6 . c=A() . [A.x,A.y], [a.x,a.y], [b.x,b.y], [c.x,c.y] . ([0, 4], [2, 4], [2, 4], [0, 4]) . - 시점7 . c.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 5번 실행 . [A.x,A.y], [a.x,a.y], [b.x,b.y], [c.x,c.y] . ([0, 5], [2, 5], [2, 5], [1, 5]) . - 신기한점: 각 인스턴스에서 인스턴스이름.f()를 실행한 횟수를 서로 공유하는 듯 하다. (A의 관리하는 것처럼 느껴진다) . - x와 y는 약간 느낌이 다르다. x는 지점소속, y는 본사소속의 느낌? . 이 예제에서 x는 인스턴스오브젝트에 소속된 변수, y는 클래스오브젝트에 소속된 변수처럼 느껴짐 . (약속) 앞으로 인스턴스오브젝트에 소속된 변수를 인스턴스변수라고 하고, 클래스오브젝트에 소속된 변수를 클래스변수라고 하자. . - 인스턴스변수와 클래스변수를 구분하는 방법? 인스턴스이름.__dict__를 쓰면 인스턴스변수만 출력된다 . 따라서 a.+ tab을 눌러서 나오는 변수중 a.__dict__에 출력되지 않으면 클래스변수이다. | . a.__dict__ . {&#39;x&#39;: 2} . b.__dict__ . {&#39;x&#39;: 2} . c.__dict__ . {&#39;x&#39;: 1} . - 이 예제에서 아래는 모두 클래스변수이다. . a.y, b.y, c.y . (5, 5, 5) . &#50696;&#51228;2: &#51064;&#49828;&#53556;&#49828;&#50640;&#49436; &#48320;&#49688;x &#48320;&#44221; (&#48320;&#44221;&#44032;&#45733;) . - 시점0 . class A: x=0 y=0 def f(self): self.x = self.x + 1 A.y = A.y + 1 print(&quot;현재 인스턴스에서 f가 {}번 실행&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행&quot;.format(self.y)) . a=A() . [A.x,A.y], [a.x,a.y] . ([0, 0], [0, 0]) . - 시점1 . a.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 . a.f() . 현재 인스턴스에서 f가 2번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 2번 실행 . a.f() . 현재 인스턴스에서 f가 3번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 3번 실행 . [A.x,A.y], [a.x,a.y] . ([0, 3], [3, 3]) . - 시점2 . a.x = 0 # f의 실행기록을 초기화하고 싶다 . a.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 4번 실행 . [A.x,A.y], [a.x,a.y] . ([0, 4], [1, 4]) . &#50696;&#51228;3: &#53364;&#47000;&#49828;&#50640;&#49436; &#48320;&#49688;y &#48320;&#44221; (&#48320;&#44221;&#44032;&#45733;) . - 시점0 . class A: x=0 y=0 def f(self): self.x = self.x + 1 A.y = A.y + 1 print(&quot;현재 인스턴스에서 f가 {}번 실행&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행&quot;.format(self.y)) . a=A() . b=A() . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 0], [0, 0], [0, 0]) . - 시점1 . a.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 1], [1, 1], [0, 1]) . - 시점2 . A.y = 100 . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 100], [1, 100], [0, 100]) . a.f() . 현재 인스턴스에서 f가 2번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 101번 실행 . [A.x,A.y], [a.x,a.y], [b.x,b.y] . ([0, 101], [2, 101], [0, 101]) . &#50696;&#51228;4: &#53364;&#47000;&#49828;&#50640;&#49436; &#48320;&#49688;x &#48320;&#44221; (&#48320;&#44221;&#44032;&#45733;) . - 시점0 . class A: x=0 y=0 def f(self): self.x = self.x + 1 A.y = A.y + 1 print(&quot;현재 인스턴스에서 f가 {}번 실행&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행&quot;.format(self.y)) . a=A() . [A.x, A.y], [a.x,a.y] . ([0, 0], [0, 0]) . - 시점1 . a.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 . [A.x, A.y], [a.x,a.y] . ([0, 1], [1, 1]) . - 시점2 . A.x = 100 # 이렇게 되면 앞으로 만들어진 인스턴스는 기본적으로 현재 인스턴스에서 100번 f를 실행하였다는 정보를 가지고 태어나게 된다. . [A.x, A.y], [a.x,a.y] . ([100, 1], [1, 1]) . - 시점3 . b=A() . [A.x, A.y], [a.x,a.y], [b.x,b.y] . ([100, 1], [1, 1], [100, 1]) . - 시점4 . b.f() . 현재 인스턴스에서 f가 101번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 2번 실행 . - 시점5 . a.f() . 현재 인스턴스에서 f가 2번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 3번 실행 . a.f() . 현재 인스턴스에서 f가 3번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 4번 실행 . b.f() . 현재 인스턴스에서 f가 102번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 5번 실행 . &#50696;&#51228;4&#51032; &#48320;&#54805; . - 시점0 . class B: x=10 # 초기자본금 y=0 def f(self): # f()를 실행할때마다 돈을 쓴다. self.x = self.x - 1 B.y = B.y + 1 print(&quot;현재 인스턴스에서 {}원 잔액남음&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 총 {}원 사용&quot;.format(self.y)) . a=B() . b=B() . [B.x,B.y], [a.x,a.y], [b.x,b.y] . ([10, 0], [10, 0], [10, 0]) . - 시점1 . a.f() # 돈을쓰는것 . 현재 인스턴스에서 9원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 1원 사용 . a.f() . 현재 인스턴스에서 8원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 2원 사용 . b.f() . 현재 인스턴스에서 9원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 3원 사용 . - 시점2 . [B.x,B.y], [a.x,a.y], [b.x,b.y] . ([10, 3], [8, 3], [9, 3]) . B.x = 999 . [B.x,B.y], [a.x,a.y], [b.x,b.y] . ([999, 3], [8, 3], [9, 3]) . - 시점3 . c = B() . c.f() . 현재 인스턴스에서 998원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 4원 사용 . - 시점4 . a.f() . 현재 인스턴스에서 7원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 5원 사용 . b.f() . 현재 인스턴스에서 8원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 6원 사용 . c.f() . 현재 인스턴스에서 997원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 7원 사용 . c.f() . 현재 인스턴스에서 996원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 8원 사용 . c.f() . 현재 인스턴스에서 995원 잔액남음 A클래스에서 만들어진 모든 인스턴스들에서 총 9원 사용 . &#50696;&#51228;5: &#51064;&#49828;&#53556;&#49828;&#50640;&#49436; &#53364;&#47000;&#49828;&#48320;&#49688; &#48320;&#44221; (&#48320;&#44221;&#44032;&#45733;??) . - 시점0 . class A: x=0 y=0 def f(self): self.x = self.x + 1 A.y = A.y + 1 print(&quot;현재 인스턴스에서 f가 {}번 실행&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행&quot;.format(self.y)) . a=A() b=A() . [A.x, A.y], [a.x,a.y], [b.x,b.y] . ([0, 0], [0, 0], [0, 0]) . - 시점1 . a.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 . b.f() . 현재 인스턴스에서 f가 1번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 2번 실행 . a.f() . 현재 인스턴스에서 f가 2번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 3번 실행 . [A.x, A.y], [a.x,a.y], [b.x,b.y] . ([0, 3], [2, 3], [1, 3]) . - 시점2 . a.y ## 인스턴스a에 소속되어있지만 클래스변수 . 3 . a.y = 999 ## 내가 하드코딩으로 a.y에 999를 입력 -&gt; 이것이 A.y나 b.y에도 반영될까? (X) . [A.x, A.y], [a.x,a.y], [b.x,b.y] . ([0, 3], [2, 999], [1, 3]) . - 시점3 . b.f() . 현재 인스턴스에서 f가 2번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 4번 실행 . a.f() . 현재 인스턴스에서 f가 3번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 999번 실행 . b.f() . 현재 인스턴스에서 f가 3번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 6번 실행 . b.f() . 현재 인스턴스에서 f가 4번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 7번 실행 . a.f() . 현재 인스턴스에서 f가 4번 실행 A클래스에서 만들어진 모든 인스턴스들에서 f가 총 999번 실행 . - 요약 . 인스턴스에서 클래스변수의 값을 변경하면? -&gt; 클래스변수의 값이 변경되는 것이 아니라 인스턴스변수가 새롭게 만들어져서 할당된다. | 이 예제에서 a.y는 이제 클래스변수에서 인스턴스변수로 재탄생되었다. 즉 999 오브젝트가 새롭게 만들어져서 a.y라는 이름을 얻은것임. | 기존의 A.y나 b.y에는 아무런 변화가 없다. | . a.y = 999 은 새로운 인스턴변수 y를 할당하는 역할을 한다. 클래스변수의 값을 변경하는 것이 아니다. (왜냐하면 애초에 a.y는 없는 값이었고, A.y를 빌리고 있었던 것임) . a.__dict__ . {&#39;x&#39;: 2, &#39;y&#39;: 999} . b.__dict__ . {&#39;x&#39;: 1} . &#50696;&#51228;5&#51032; &#48320;&#54805; . - 시점0 . class A: x=0 y=0 def f(self): self.x = self.x + 1 A.y = A.y + 1 print(&quot;현재 인스턴스에서 f가 {}번 실행 (인스턴스레벨)&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행 (클래스레벨)&quot;.format(A.y)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행 (인스턴스레벨)&quot;.format(self.y)) . a=A() . a.f() . 현재 인스턴스에서 f가 1번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 (클래스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 (인스턴스레벨) . b=A() . b.f() . 현재 인스턴스에서 f가 1번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 2번 실행 (클래스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 2번 실행 (인스턴스레벨) . - 시점1 . a.y = 999 . a.f() . 현재 인스턴스에서 f가 2번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 3번 실행 (클래스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 999번 실행 (인스턴스레벨) . a.f() . 현재 인스턴스에서 f가 3번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 4번 실행 (클래스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 999번 실행 (인스턴스레벨) . a.f() . 현재 인스턴스에서 f가 4번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 5번 실행 (클래스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 999번 실행 (인스턴스레벨) . &#50696;&#51228;6: &#51064;&#49828;&#53556;&#49828; &#49373;&#49457;&#49884;&#51216;&#50640; &#45824;&#54620; &#48516;&#49437; . - 의문: 아래의 코드에서 x는 클래변수라고 봐야할까? 인스턴스 변수라고 봐야할까? --&gt; 클래스변수 . class SoWhaTV: x=0 ### 이 시점에서 x는 클래스변수인가? 아니면 인스턴변수인가? def f(self): print(self.x) . - 시점0 . class A: x=0 y=0 def f(self): self.x = self.x + 1 A.y = A.y + 1 print(&quot;현재 인스턴스에서 f가 {}번 실행 (인스턴스레벨)&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행 (클래스레벨)&quot;.format(A.y)) #print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행 (인스턴스레벨)&quot;.format(self.y)) . a=A() b=A() . a.x,a.y,b.x,b.y . (0, 0, 0, 0) . a.__dict__, b.__dict__ . ({}, {}) . 지금 시점에서 a.x, a.y, b.x, b.y 는 모두 클래스변수임 | . - 시점1 . a.f() . 현재 인스턴스에서 f가 1번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 (클래스레벨) . a.__dict__, b.__dict__ . ({&#39;x&#39;: 1}, {}) . 이 순간 a.x가 클래스변수에서 인스턴스변수로 변경되었다. 왜? f가 실행되면서 self.x = self.x + 1 이 실행되었으므로! | . - 시점2 . b.f() . 현재 인스턴스에서 f가 1번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 2번 실행 (클래스레벨) . a.__dict__, b.__dict__ . ({&#39;x&#39;: 1}, {&#39;x&#39;: 1}) . &#50696;&#51228;7: &#51096;&#47803;&#46108;&#49324;&#50857; . - 아래처럼 코드를 바꾸면 어떻게 되는가? . class A: def __init__(self): self.x=0 # 인스턴스변수로 나중에 쓸꺼니까 명시함 A.y=0 # 클래스변수로 나중에 쓸꺼니까 명시함 def f(self): self.x = self.x + 1 A.y = A.y + 1 print(&quot;현재 인스턴스에서 f가 {}번 실행 (인스턴스레벨)&quot;.format(self.x)) print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행 (클래스레벨)&quot;.format(A.y)) #print(&quot;A클래스에서 만들어진 모든 인스턴스들에서 f가 총 {}번 실행 (인스턴스레벨)&quot;.format(self.y)) . - 사용해보자. . a=A() b=A() . a.f() . 현재 인스턴스에서 f가 1번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 (클래스레벨) . b.f() . 현재 인스턴스에서 f가 1번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 2번 실행 (클래스레벨) . b.f() . 현재 인스턴스에서 f가 2번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 3번 실행 (클래스레벨) . b.f() . 현재 인스턴스에서 f가 3번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 4번 실행 (클래스레벨) . a.f() . 현재 인스턴스에서 f가 2번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 5번 실행 (클래스레벨) . - 잘 되는것 같다? . - 조금만 생각해보면 엉터리라는 것을 알 수 있다. 아래를 관찰해보자. . c=A() # 이 시점에서 __init__()이 실행된다! . a.f() . 현재 인스턴스에서 f가 3번 실행 (인스턴스레벨) A클래스에서 만들어진 모든 인스턴스들에서 f가 총 1번 실행 (클래스레벨) . 클래스레벨의 변수가 왜 초기화가 되었지? | . - 오류의 이유? c=A()가 실행되는 시점에 __init__()이 실행되면서 A.y=0이 실행된다. 따라서 강제초기화가 진행되었음 . &#49689;&#51228; . 아래의 조건에 맞는 클래스를 생성하라. . (1) [&#39;가위&#39;,&#39;바위&#39;]와 같은 리스트를 입력으로 받아 인스턴스를 생성한다. . (2) 위의 리스트에서 하나의 값을 뽑는 메소드 f를 가지고 있다. . (3) f의 실행횟수를 기록하는 기능을 가진다. (각 인스턴스에서 실행한 횟수, 클래스에서 생성된 모든 인스턴스에서 실행한 횟수 모두 기록) . 사용예시 . a = Klass([&#39;가위&#39;,&#39;바위&#39;]) a.f() # 가위가 1/2 바위가 1/2의 확률로 출력 b = Klass([&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]) b.f() # 가위, 바위, 보가 1/3의 확률로 출력 .",
            "url": "https://guebin.github.io/IP2022/2022/05/18/(12%EC%A3%BC%EC%B0%A8)-5%EC%9B%9418%EC%9D%BC.html",
            "relUrl": "/2022/05/18/(12%EC%A3%BC%EC%B0%A8)-5%EC%9B%9418%EC%9D%BC.html",
            "date": " • May 18, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "(11주차) 5월16일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/5) __init__ . - (2/5) self의 의미 . - (3/5) 파이썬의 비밀1 . - (4/5) 파이썬의 비밀2 . - (5/5) 숙제설명 . imports . from PIL import Image import requests . &#53364;&#47000;&#49828; &#44277;&#48512; 2&#45800;&#44228; . __init__() . - STOOOP을 다시 복습 . url1 = &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39; url2 = &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop2.png?raw=true&#39; . class STOOOP: title = &#39;학교폭력!&#39; url = url1 end = &#39;멈춰~~~~&#39; def stop(self): print(self.title) display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(self.end) . s1=STOOOP() # STOOOP이라는 클래스에서 s1이라는 인스턴를 만드는 과정 . s1.title,s1.url,s1.end . (&#39;학교폭력!&#39;, &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39;, &#39;멈춰~~~~&#39;) . s1.stop() . 학교폭력! . 멈춰~~~~ . - 왜 s1의 default title이 항상 &quot;학교폭력&quot;이어야 하는가? -&gt; __init__의 개발 . - 성능4: __init__()함수를 이용하여 &quot;클래스-&gt;인스턴스&quot;의 시점에서 수행하는 일련의 동작들을 묶어서 수행할 수 있음 . class STOOOP: #title = &#39;학교폭력!&#39; url = url1 end = &#39;멈춰~~~~&#39; def __init__(self,title): self.title = title def stop(self): print(self.title) display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(self.end) . - 잘못된사용 . s1=STOOOP() # 이 시점에서 __init__ 이 수행된다! . TypeError Traceback (most recent call last) Input In [15], in &lt;cell line: 1&gt;() -&gt; 1 s1=STOOOP() TypeError: __init__() missing 1 required positional argument: &#39;title&#39; . - 올바른사용 . s1=STOOOP(&quot;수강신청매크로&quot;) # 이 시점에서 __init__ 이 수행된다! . s1.title,s1.url,s1.end . (&#39;수강신청매크로&#39;, &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39;, &#39;멈춰~~~~&#39;) . s1.stop() . 수강신청매크로 . 멈춰~~~~ . - 잘못된사용에서 에러가 발생한 이유? . TypeError: __init__() missing 1 required positional argument: &#39;title&#39; . s1 = STOOOP() 이 실행되는 순간 __init__()이 내부적으로 실행된다. | 그런데 __init__()의 첫번째 입력인 self는 입력안해도 무방했음. 그런데 두번째 입력은 title은 입력을 해야했음. | 그런데 title을 입력하지 않아서 발생하는 에러 | . - __init__(self,arg1,arg2,...) 함수에 대하여 . 엄청나게 특별해 보이지만 사실 몇가지 특별한 점을 제외하고는 어떠한 마법도 없는 함수이다. | 특별한점1: 첫번째 입력으로 반드시 self를 넣어야함. (이건 사실 클래스 내의 메소드 거의 다 그러함) | 특별한점2: 클래스에서 인스턴스를 만드는 시점에 자동으로 실행된다. | 특별한점3: __init__(self,arg1,arg2,...)의 입력중 self 이외의 입력들은 &quot;클래스-&gt;인스턴스&quot;의 시점에서 &quot;인스턴스이름 = 클래스이름(arg1,arg2,...)&quot;와 같이 사용한다. (이 예제의 경우 STOOOP(title)와 같이 사용해야함) | . - title이 디폴트로 들어가는 상황도 불편했지만, title을 명시적으로 넣지 않으면 에러가 발생하는 것도 불편하다? . class STOOOP: #title = &#39;학교폭력!&#39; url = url1 end = &#39;멈춰~~~~&#39; def __init__(self,title=None): self.title = title def stop(self): print(self.title) display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(self.end) . s2 = STOOOP() s3 = STOOOP(&#39;KOSPI 하락&#39;) . s2.stop() . None . 멈춰~~~~ . 제목이 없으면 없는대로 출력가능 | . s3.stop() . KOSPI 하락 . 멈춰~~~~ . self&#51032; &#51032;&#48120; . - 이전 예제를 다시 복습 . class Klass4: n = 1 url = &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39; def show(self): display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(&quot;당신은 이 이미지를 {}번 보았습니다&quot;.format(self.n)) self.n = self.n+1 . k4=Klass4() . k4.show() . 당신은 이 이미지를 3번 보았습니다 . - 위의 예제는 아래와 같이 구현할 수도 있다. . class Klass4: n = 1 url = &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39; def show(self): display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(&quot;당신은 이 이미지를 {}번 보았습니다&quot;.format(self.n)) #self.n = self.n+1 . k4 = Klass4() . k4.n . 1 . k4.show() . 당신은 이 이미지를 1번 보았습니다 . k4.n = k4.n + 1 . k4.show() . 당신은 이 이미지를 2번 보았습니다 . k4.n = k4.n + 1 . - 결국에는 k4.n = k4.n + 1의 기능을 구현하여 넣은것이 self.n = self.n + 1 이다. . - 따라서 self는 k4에 대응한다. 즉 self는 인스턴스의 이름에 대응한다. 우리가 하고 싶은 것은 클래스를 선언하는 시점에서 인스턴스가 생성된 이후시점에 대한 어떠한 동작들을 정의하고 싶다. 그런데 클래스를 설계하는 시점에서는 인스턴스의 이름이 정해지지 않았으므로 (아직 인스턴스가 태어나지도 않음) 이러한 동작들을 정의하기 불편하다. 그래서 클래스를 설계하는 시점에서 그 클래스로부터 만들어지는 인스턴스는 그냥 self라는 가칭으로 부른다. (굳이 비유하면 self는 인스턴스의 태명같은 것임) . - 요약: self의 의미는 (후에 만들어질) 인스턴스의 이름이다. (즉 self는 인스턴스의 태명같은것임) . &#54028;&#51060;&#50028;&#51032; &#48708;&#48128;1 . 탐구: 인스턴스의 자료형이 뭔지 탐구해보자! . - 아래의 두 클래스를 선언해보자. . class STOOOP: #title = &#39;학교폭력!&#39; url = url1 end = &#39;멈춰~~~~&#39; def __init__(self,title=None): self.title = title def stop(self): print(self.title) display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(self.end) . class Klass4: n = 1 url = &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39; def show(self): display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(&quot;당신은 이 이미지를 {}번 보았습니다&quot;.format(self.n)) #self.n = self.n+1 . - 인스턴스를 생성해보자. . k4=Klass4() s1=STOOOP() . - 타입을 알아보자. . k4? . Type: Klass4 String form: &lt;__main__.Klass4 object at 0x7f0a740beb80&gt; Docstring: &lt;no docstring&gt; . s1? . Type: STOOOP String form: &lt;__main__.STOOOP object at 0x7f0a74372970&gt; Docstring: &lt;no docstring&gt; . - ??? 타입은 자료형, 즉 int, float, list 이런것 아니었나?? . a=[1,2,3] a? . Type: list String form: [1, 2, 3] Length: 3 Docstring: Built-in mutable sequence. If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified. . - 그런데 지금 k4, s1의 타입은 Klass4, STOOOP 이다. . 가설1: 사실 파이썬 내부에 Klass4, STOOOP이라는 자료형이 있었다. 그런데 내가 만든 k4, s1이 우연히 그 자료형을 따르는 것! (이건 너무 억지스럽다) | 가설2: type이 list인것은 사실 list라는 클래스에서 생긴 인스턴스이다 -&gt; 리스트자료형을 찍어낼 수 있는 어떠한 클래스가 파이썬에 내부적으로 존재할 것이다. (이게 맞는것 같다) | . 깨달음1 . - 가설2가 맞다? 그렇다면 아래는 모두 어딘가에서 찍혀진 인스턴스이다. . a=[1,2,3] a? . Type: list String form: [1, 2, 3] Length: 3 Docstring: Built-in mutable sequence. If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified. . a=1,2,3 a? . Type: tuple String form: (1, 2, 3) Length: 3 Docstring: Built-in immutable sequence. If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable&#39;s items. If the argument is a tuple, the return value is the same object. . a=1 a? . Type: int String form: 1 Docstring: int([x]) -&gt; integer int(x, base=10) -&gt; integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by &#39;+&#39; or &#39;-&#39; and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. &gt;&gt;&gt; int(&#39;0b100&#39;, base=0) 4 . a=&#39;1&#39; a? . Type: str String form: 1 Length: 1 Docstring: str(object=&#39;&#39;) -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to &#39;strict&#39;. . - 그리고 위의 a=[1,2,3]과 같은 것들은 모두 &quot;클래스-&gt;인스턴스&quot;에 해당하는 과정이었음 . 깨달음2 . - 생각해보니까 아래와 같이 list를 선언하는 방식도 있었음 . a=list() a . [] . 이거 지금 생각하니까 list라는 이름의 클래스에서 a라는 인스턴스를 찍어내는 문법이다?! | . - 아래도 가능함 . a=list((1,2,3)) a? . Type: list String form: [1, 2, 3] Length: 3 Docstring: Built-in mutable sequence. If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified. . 이것도 지금 보니까 list라는 이름의 클래스에서 a라는 인스턴스를 찍어내는 문법이다. 여기에서 (1,2,3)은 __init__()의 입력이다. | . 깨달음3 . - 그러고보니까 각 자료형마다 특수한 기능들이 있었음 . a=[1,2,3] . - a.+tab 을 하면 append, clear 등등이 나온다. . - 이러한 기능은 지금까지 우리가 &quot;list자료형 특수기능들&quot;이라고 부르면서 사용했었다. 그런데 a가 list클래스에서 생성된 인스턴스라는 관점에서 보면 이러한 기능들은 list클래스에서 정의된 메소드라고 볼 수 있다. . 깨달음4 . - a.f()는 f(a)로 해석가능하다고 하였다. 이 해석에 따르면 메소드의 첫번째 입력은 메소드가 소속된 인스턴스라고 해석할 수 있다. . - 동일한 논리로 아래의 코드는 stop()의 입력에서 s1을 넣는다는 의미이다. . s1.stop() . None . 멈춰~~~~ . &#49689;&#51228; . 아래의 조건에 맞는 클래스를 생성하라. . (1) [&#39;가위&#39;,&#39;바위&#39;]와 같은 리스트를 입력으로 받아 인스턴스를 생성한다. . (2) 위의 리스트에서 하나의 값을 뽑는 메소드 f를 가지고 있다. . 사용예시 . a = Klass([&#39;가위&#39;,&#39;바위&#39;]) a.f() # 가위가 1/2 바위가 1/2의 확률로 출력 b = Klass([&#39;가위&#39;,&#39;바위&#39;,&#39;보&#39;]) b.f() # 가위, 바위, 보가 1/3의 확률로 출력 . 5월16일에 1시간, 5월18일에 2시간 분량을 업로드하겠습니다. (원래 5월16일 2시간, 5월18일 1시간 분량이었습니다) .",
            "url": "https://guebin.github.io/IP2022/2022/05/16/(11%EC%A3%BC%EC%B0%A8)-5%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2022/05/16/(11%EC%A3%BC%EC%B0%A8)-5%EC%9B%9416%EC%9D%BC.html",
            "date": " • May 16, 2022"
        }
        
    
  
    
        ,"post9": {
            "title": "(11주차) 5월11일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3) 이미지자료 불러오기 (PIL 이용) . - (2/3) 클래스의 성능 정리 . - (3/3) 연습문제 . imports . import requests from PIL import Image . - 예제1 . url= &#39;https://stat.jbnu.ac.kr/sites/stat/images/intro_about_02.jpg&#39; . Image.open(Image.io.BytesIO(requests.get(url).content)) . 우리학과 실습실! | . - 예제2 . url1 = &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39; url2 = &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop2.png?raw=true&#39; . Image.open(Image.io.BytesIO(requests.get(url1).content)) . Image.open(Image.io.BytesIO(requests.get(url2).content)) . &#53364;&#47000;&#49828;&#44277;&#48512; 1&#45800;&#44228; . &#53364;&#47000;&#49828; &#49440;&#50616; &#48143; &#49324;&#50857;&#50696;&#49884; . - 클래스를 선언 . class STOOOP: title = &#39;학교폭력!&#39; url = url1 end = &#39;멈춰~~~~&#39; def stop(self): print(self.title) display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(self.end) . 규칙1: 메소드(=class안에서 정의된 함수)의 첫번째 인자는 무조건 self | 규칙2: 메소드에서 class안에 정의된 변수들(title, url, end)을 사용하려면 &quot;self.변수이름&quot;와 같은 형식으로 쓴다. 즉 &quot;self.title&quot;, &quot;self.url&quot;, &quot;self.end&quot; 와 같은 방식으로 써야한다. | . | 참고: 규칙2에서 가끔 self의 자리에 &quot;STOOOP.title&quot;,&quot;STOOOP.url&quot;,&quot;STOOOP.end&quot; 와 같이 클래스의 이름으로 쓰기도 한다. | . - 클래스 사용예시 . (예시1) STOOOP 클래스 -&gt; school 인스턴스 만듬 . school = STOOOP() . school.stop() . 학교폭력! . 멈춰~~~~ . (예시2) STOOOP 클래스 -&gt; kospi 인스턴스 만듬 . kospi = STOOOP() . kospi.title = &#39;KOSPI 하락&#39; . kospi.stop() . KOSPI 하락 . 멈춰~~~~ . &#53364;&#47000;&#49828;&#51032; &#44592;&#48376;&#49457;&#45733; &#51221;&#47532; . - 성능1: 틀만있으면 여러개의 독립적인 컨텐츠를 생성할 수 있다 . school = STOOOP() kospi = STOOOP() . 함수의 사용법과 비슷하다. | 클래스이름을 쓰고 콘텐츠를 구체화하는 과정에서 필요한 입력1, 입력2를 ()에 넣는다. 이때는 STOOOP(입력1,입력2)와 같이 생성 | 위의 예시는 따로 입력이 없으므로 비워둔 상태임. 즉 STOOOP()와 같은 식으로 생성. | . - 성능2: 생성된 콘텐츠(=인스턴스)에서 .을 찍고 접근할 수 있는 여러 자료들에 접근가능하며 내용도 독립적으로 바꿀 수 있다. . school.title # 출력 . &#39;학교폭력!&#39; . kospi.title # 출력 . &#39;학교폭력!&#39; . kospi.title = &#39;코스피하락&#39; # 변경 . - 성능3: 생성된 콘텐츠(=인스턴스)에서 .을 찍고 쓸 수 있는 자체적인 함수(=method라고 함)를 독립적으로 사용할 수 있다. . school.stop() . 학교폭력! . 멈춰~~~~ . kospi.stop() . 코스피하락 . 멈춰~~~~ . &#50672;&#49845;&#47928;&#51228; . 문제1: 아래의 클래스를 구현하라. . - 클래스내에는 변수 a가 있다. 변수 a의 초기값은 True이다. . - 클래스에는 show()라는 메소드가 있다. show()의 기능은 a의 값을 print하는 기능을 한다. . (풀이) . class Klass1: a = True def show(self): print(self.a) . ex1 = Klass1() . ex1.a . True . ex1.show() . True . 문제2: 아래의 클래스를 구현하라. . - 클래스내에는 변수 a가 있다. 변수 a의 초기값은 1이다. . - 클래스에는 up()라는 메소드가 있다. up()의 기능은 a의 값을 1증가시키는 기능을 한다. . (풀이) . class Klass2: a = 1 def up(self): self.a = self.a + 1 . ex2 = Klass2() ex2.a . 1 . ex2.up() . ex2.a . 2 . ex2.up() ex2.up() ex2.up() ex2.a . 5 . 문제3: 아래의 클래스를 구현하라. . - 클래스내에는 변수 a가 있다. 변수 a의 초기값은 0이다. . - 클래스에는 up(),down(),show()라는 메소드가 있다. 각각은 a의 값을 1증가, a의 값을 1감소, a의 값을 print하는 기능을 한다. . (풀이) . class Klass3: a = 0 def up(self): self.a = self.a + 1 def down(self): self.a = self.a - 1 def show(self): print(self.a) . ex3=Klass3() . ex3.show() . 0 . ex3.up() ex3.show() . 1 . ex3.up() ex3.up() ex3.show() . 3 . ex3.up() ex3.down() ex3.show() . 3 . ex3.down() ex3.down() ex3.show() . 1 . 문제4: 아래의 클래스를 구현하라. . - 클래스내에는 변수 url이 있음. url의 초기값은 https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true이다. . - 클래스에는 show()이라는 메소드를 가지는데, 메소드는 아래와 같은 기능을 한다. . 기능1: url의 그림을 출력 | 기능2: &#39;당신은 이 그림을 $n$번 보았습니다&#39; 출력. 여기에서 $n$은 그림을 본 횟수 | . (풀이) . class Klass4: n = 1 url = &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39; def show(self): display(Image.open(Image.io.BytesIO(requests.get(self.url).content))) print(&quot;당신은 이 이미지를 {}번 보았습니다&quot;.format(self.n)) self.n = self.n+1 . a=Klass4() . a.show() . 당신은 이 이미지를 2번 보았습니다 . b=Klass4() b.url = url2 . b.show() . 당신은 이 이미지를 3번 보았습니다 . &#49689;&#51228; . - 클래스를 선언하라. [&quot;가위&quot;,&quot;바위&quot;,&quot;보&quot;]중 하나를 골라서 내는 메소드를 정의하라. . hint . import numpy as np . np.random.choice([&quot;가위&quot;,&quot;바위&quot;,&quot;보&quot;]) . &#39;바위&#39; .",
            "url": "https://guebin.github.io/IP2022/2022/05/11/(11%EC%A3%BC%EC%B0%A8)-5%EC%9B%9411%EC%9D%BC.html",
            "relUrl": "/2022/05/11/(11%EC%A3%BC%EC%B0%A8)-5%EC%9B%9411%EC%9D%BC.html",
            "date": " • May 11, 2022"
        }
        
    
  
    
        ,"post10": {
            "title": "(10주차) 5월9일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . &#48136;(Meme)&#44284; &#53364;&#47000;&#49828; . &#49888;&#54812;&#49440; &#50612;&#51796;&#54000;&#48708; . - 원본 . youtube: https://www.youtube.com/watch?v=ReKRSTB5PK8&amp;t=2s | . - 무슨말인지 하나도 몰랐어요 . - 하나하나가 요즘 많이 쓰는 말인것은 알겠음 . - 멈춰까지 유행어였음!! (몰랐어요, 댓글보고 알았음) . - 이런걸 인터넷밈 혹은 줄여서 그냥 밈이라고 부른다. . - 너무 재밋어서 사람들이 따라하면서 유행시킵니다. (약간변형하기도 하고요) . 분홍밤의 어쩔티비: https://www.youtube.com/watch?v=_lQqPec8dFU | . &#48136;&#44284; &#51064;&#53552;&#45367;&#48136; . - 밈이란? (유전자처럼) 복제가능한 something . 이기적 유전자에서 제시한 개념 | 유전자는 (1) 복제 (2) 변형되면서 전파되는 속성이 있다는 사실을 관찰 | 종교, 사상, 이념도 유전자처럼 (1) 복제 (2) 변형되면서 전파되더라.. | 밈 = 유전자의 일반화된 개념 = 복제가능한 something | . - 인터넷 밈 . 밈의 한 형태 | 인터넷을 통하여 (1)복제 (2)변형되면서 전파되는 something | . &#49888;&#54812;&#49440;&#51032; &#50612;&#51796;&#54000;&#48708;&#50640; &#49324;&#50857;&#46108; &#48136; . (1) &#50612;&#51796;&#54000;&#48708;? . - 기원: 불분명 . 가설1: 초등학생이 유투브채널 개설할때 XX티비 라고 개설하는것에서 유래? | 가설2: &quot;어쩌라고 티비나봐&quot;의 줄임말? | . - 발전: 인터넷을 통하여 사람들이 쓰기시작하면서 밈화 . 변형1: 저쩔티비, 안물티비, 안궁티비.. | 변형2: 어쩔냉장고, 어쩔세탁기, 어쩔다이슨청소기내돈내산.. . Note: 사실 내돈내산도 밈이라고 볼 수 있음 | . - 유행 . 분석글: https://whitefaceone.tistory.com/2494 | 중앙일보 분석기사: https://www.joongang.co.kr/article/25048899#home | . (2) &#50864;&#51684;&#47000;&#48120; . - 기원 . https://pann.nate.com/talk/357542118 | . (3) &#50500;&#47924;&#44256;&#53664;&#47803;&#54616;&#51564;? . - 기원: 인터넷방송? . https://www.inven.co.kr/board/overwatch/4538/2776334 | . (4) &#53356;&#53356;&#47336;&#49296;&#48981; . - 기원: 트위치? . https://whitefaceone.tistory.com/2067 | . (5) &#49801;&#49800;&#49800;&#49800;&#49801; &#12613;&#12610;&#12601;&#12609; ($ star$) . - 기원: 트위치 -&gt; 문자 -&gt; 돌하르방 . https://namu.wiki/w/%EC%8A%88%EC%8A%89%20%EC%8A%88%EC%88%99.%20%EC%8A%89.%20%EC%8B%9C.%20%EC%8B%9C%EB%B0%9C%EB%9F%BC%EC%95%84. | . - 전혀 다른 성질을 가진 밈으로 재탄생한 경우임 . 만들어진 계기: 트위치에서 tts를 이용해 조롱을 하기 위해 탄생 | 유명해진 계기: 택배실수 | 슉슈슈슈슉: 돌하르방과 결합.. (돌하르방의 기묘한 자세와 결합하여 더 재미있음) | . (6) &#47688;&#52656;! ($ star$) . - 기원 학교폭력, 멈춰 . youtube: https://www.youtube.com/watch?v=aQyLhYC4E8Y | . - 발전 (뒤늦게 생각해보니까 너무 어이없고 재미있음) . https://www.youtube.com/watch?v=lmkLZufjJS4&amp;list=PLSEouoj9wewjzMFrPKZPPUeMpn9Da_hSs&amp;index=8 | 코스피하락, 멈춰~ : https://www.teamblind.com/kr/post/%EC%BD%94%EC%8A%A4%ED%94%BC-%ED%95%98%EB%9D%BD-%EB%A9%88%EC%B6%B0-nsn651dz | 수강신청 매크로, 멈춰~ : https://www.youtube.com/watch?v=RsXy5Hk_s8Q | . - 이것 역시 전혀 다른 성질을 가진 밈으로 재 탄생한 경우임 . (1)~(6) &#51060;&#50808;&#50640; &#45908; &#51080;&#51012;&#49688;&#46020;.. // &#45236;&#44032; &#47784;&#47484; &#49688;&#46020; // &#46496;&#50732;&#47532;&#51648; &#47803; &#54664;&#51012; &#49688;&#46020; // &#45236;&#44032; &#47924;&#51648;&#54664;&#51012; &#49688;&#46020; // &#45236;&#44032; &#46608; &#51096;&#47803;&#51012; // &#45236;&#44032; &#44048;&#55176; . https://www.careet.net/606 | . &#50696;&#51228;&#46308;&#51012; &#53685;&#54644; &#49332;&#54196;&#48376; &#48136;&#51032; &#51032;&#48120; . - 딱히 정형화 하기 어렵지만 위의예제들은 복제가 되는 어떠한 틀이 있다. 이것을 밈(=유전자)라고 부른다!! . - 많은 사람들에게 그 복제내용이 확산되어 재생산된다. 이것을 밈화라고 한다. . - 그대로 복제하지 않고 변형을 거치며 전혀 다른 성질을 가질 수 있다. . - 밈이 또 다른 밈을 만들수 있다. . 신혜선의 어쩔티비는 다양한 밈의 결합체, 그리고 신혜선의 어쩔티비 자체가 밈화 되었음. | 내돈내산 밈과 어쩔티비밈의 변형이 결합하여 어쩔다이슨청소기내돈내산 이 탄생. | . &#53364;&#47000;&#49828; . - 클래스의 정의 . 많은 교재에서 정의를 회피한다. | 대신에 비유적으로 설명하거나 다른 대상을 가져와서 설명한다. | . - 클래스에 대한 비유적 설명 (implicit definition) . 클래스는 과자틀과 비슷하다. 클래스란 똑같은 무엇인가를 계속 만들어 낼 수도 있는 설계도면이고 객체란 클래스로 만든 피조물을 뜻한다. (점프투파이썬) | In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods). // 객체 지향 프로그래밍에서 클래스는 상태(멤버 변수) 및 동작 구현(멤버 함수 또는 메서드)에 대한 초기 값을 제공하는 객체 생성을 위한 확장 가능한 프로그램 코드 템플릿입니다. | http://www.tcpschool.com/java/java_class_intro | https://javacpro.tistory.com/29 | https://ko.wikipedia.org/wiki/%ED%81%B4%EB%9E%98%EC%8A%A4_(%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D) | 기타 서적들.. (진짜 무슨 한 챕터씩 설명하고 있음) | . - 클래스에 대한 명시적 정의 (책에 나온것 아니고 제 생각입니다!!) . 클래스는 복제, 변형, 재생산을 용이하게 하기 위해 만들어진 확장가능한 프로그램의 코드의 단위(extensible program-code-template)이다. 즉 밈이다. | . - 클래스도 결국 밈이다. 생각해보면 클래스를 만들고 사용하는 과정이 인터넷에서 밈을 만들고 노는것과 닮아 있다. . 1단계: 개념의 인지 (이거 재미있겠다 밈으로 만들자 // 이 코드 쓸모있다, 이 코드를 쉽게 찍어내는 클래스로 만들어두자) | 2단계: 복사하고 싶은 속성을 추려 복사가능한 틀을 만듬 (밈 초기 컨텐츠 // 클래스의 선언) | 3단계: 밈에서 다양한 컨텐츠를 재생산, 때로는 변형하여 재생산, 때로는 그것을 응용한 다른밈을 만듬 (밈화 // 클래스의 인스턴스화, 상속, 메소드오버라이딩) | . &quot;&#47688;&#52656;&quot;&#48136;&#51012; &#52968;&#53584;&#52768;&#54868; . - 멈춰밈을 이용하여 코스피하락, 수강신청매크로등 다양한 예제를 만들고 놀고 싶다. . from IPython.core.display import HTML . &#50696;&#48708;&#54617;&#49845; . &#47928;&#51088;&#50676;&#54252;&#47607;&#54021; (&#47928;&#51088;&#50676;&#45180;&#50892;&#45347;&#44592;) . - 예제1 . &#39;제 이름은 {}입니다&#39;.format(&#39;최규빈&#39;) . &#39;제 이름은 최규빈입니다&#39; . - 예제2 . &#39;제 이름은 {}이고 사는곳은 {}입니다.&#39;.format(&#39;최규빈&#39;,&#39;전주&#39;) . &#39;제 이름은 최규빈이고 사는곳은 전주입니다.&#39; . &#39;제 이름은 {}이고 사는곳은 {}입니다.&#39;.format(&#39;전주&#39;,&#39;최규빈&#39;) . &#39;제 이름은 전주이고 사는곳은 최규빈입니다.&#39; . - 예제3 . &#39;제 이름은 {name}이고 사는곳은 {add}입니다.&#39;.format(name=&#39;최규빈&#39;,add=&#39;전주&#39;) . &#39;제 이름은 최규빈이고 사는곳은 전주입니다.&#39; . &#39;제 이름은 {name}이고 사는곳은 {add}입니다.&#39;.format(add=&#39;전주&#39;,name=&#39;최규빈&#39;) . &#39;제 이름은 최규빈이고 사는곳은 전주입니다.&#39; . HTML . - 예제1 . HTML(&quot;&lt;p&gt; 이름 &lt;/p&gt;&quot;) . 이름 . - 예제2 . HTML(&quot;&lt;img src=&#39;https://stat.jbnu.ac.kr/sites/stat/atchmnfl_mngr/imageSlide/469/temp_1573001043314100.jpg&#39;&gt;&quot;) . - 예제3 . HTML(&quot;&lt;p&gt; 전북대학교 &lt;/p&gt; &lt;img src=&#39;https://stat.jbnu.ac.kr/sites/stat/atchmnfl_mngr/imageSlide/469/temp_1573001043314100.jpg&#39;&gt;&quot;) . 전북대학교 . HTML&#51012; &#51060;&#50857;&#54620; &#48136;&#49373;&#49457; . - 밈을 위한 이미지 주소 . url1=&#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39; url2=&#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop2.png?raw=true&#39; . - 예제1: 원본 . htmlstr = &quot;&lt;p&gt; {title} &lt;/p&gt; &lt;img src= &#39;{url}&#39;&gt; &lt;p&gt; {end} &lt;/p&gt; &quot; HTML(htmlstr.format(title=&#39;학교폭력&#39;,url=url1,end=&#39;멈춰~~~~&#39;)) . 학교폭력 . 멈춰~~~~ . - 예제1: 코스피하락 . HTML(htmlstr.format(title=&#39;코스피하락&#39;,url=url1,end=&#39;멈춰~~~~&#39;)) . 코스피하락 . 멈춰~~~~ . - 예제3: 수강신청 매크로 . HTML(htmlstr.format(title=&#39;수강신청 매크로&#39;,url=url1,end=&#39;멈춰~~~~&#39;)) . 수강신청 매크로 . 멈춰~~~~ . &#54632;&#49688;&#47484; &#47564;&#46308;&#50612;&#49436; &#53076;&#46300;&#47484; &#44288;&#47532; . - 함수의 선언 . def stop(): htmlstr = &quot;&lt;p&gt; {title} &lt;/p&gt; &lt;img src= &#39;{url}&#39;&gt; &lt;p&gt; {end} &lt;/p&gt; &quot; display(HTML(htmlstr.format(title=ttl,url=url,end=end))) . &#50696;&#51228; 1,2,3&#51012; &#54632;&#49688;&#47196; &#46041;&#49884;&#44288;&#47532; . $t=1$ &quot;&#54617;&#44368;&#54253;&#47141; &#47688;&#52656;&quot; &#49373;&#49457; . ttl = &#39;학교폭력&#39; url = url1 end = &#39;멈춰~~~~&#39; stop() . 학교폭력 . 멈춰~~~~ . $t=2$: &quot;&#53076;&#49828;&#54588;&#54616;&#46973; &#47688;&#52656;&quot; &#49373;&#49457; . ttl = &#39;코스피하락&#39; url = url1 end = &#39;멈춰~~~~&#39; stop() . 코스피하락 . 멈춰~~~~ . $t=3$: &quot;&#49688;&#44053;&#49888;&#52397; &#47588;&#53356;&#47196; &#47688;&#52656;&quot; &#49373;&#49457; . ttl = &#39;수강신청 매크로&#39; url = url1 end = &#39;멈춰~~~~&#39; stop() . 수강신청 매크로 . 멈춰~~~~ . $t=4$: &quot;&#49688;&#44053;&#49888;&#52397; &#47588;&#53356;&#47196; &#47688;&#52656;&quot;&#51032; &#45149;&#51012; &#47932;&#44208;&#45824;&#49888; &#45712;&#45196;&#54364;&#47196;! . ttl = &#39;수강신청 매크로&#39; url = url1 end = &#39;멈춰!!!!!&#39; stop() . 수강신청 매크로 . 멈춰!!!!! . $t=5$: &quot;&#53076;&#49828;&#54588;&#54616;&#46973; &#47688;&#52656;&quot;&#47484; &#45796;&#49884; &#52636;&#47141; &lt;-- &#49892;&#49688;&#48156;&#49373;&#44032;&#45733; . ttl = &#39;코스피하락&#39; url = url1 end = &#39;멈춰!!!!!&#39; stop() . 코스피하락 . 멈춰!!!!! . 앗 실수 | . ttl = &#39;코스피하락&#39; url = url1 end = &#39;멈춰~~~~&#39; stop() . 코스피하락 . 멈춰~~~~ . $t=6$: &quot;&#54617;&#44368;&#54253;&#47141; &#47688;&#52656;&quot;&#50752; &quot;&#53076;&#49828;&#54588;&#54616;&#46973; &#47688;&#52656;&quot;&#47484; &#46041;&#49884;&#50640; &#52636;&#47141; . ttl = &#39;학교폭력&#39; url = url1 end = &#39;멈춰~~~~&#39; stop() . 학교폭력 . 멈춰~~~~ . ttl = &#39;코스피하락&#39; url = url1 end = &#39;멈춰~~~~&#39; stop() . 코스피하락 . 멈춰~~~~ . $t=7$ &quot;&#54617;&#44368;&#54253;&#47141; &#47688;&#52656;&quot;&#51032; &#51060;&#48120;&#51648;&#47484; &#49888;&#54812;&#49440;&#51004;&#47196; &#48320;&#44221;, &quot;&#53076;&#49828;&#54588;&#54616;&#46973; &#47688;&#52656;&quot;&#51032; title&#51012; &#39;KOSPI&#54616;&#46973;&#39;&#51004;&#47196; &#48320;&#44221; . ttl = &#39;학교폭력&#39; url = url2 end = &#39;멈춰!!!!!&#39; stop() . 학교폭력 . 멈춰!!!!! . ttl = &#39;KOSPI 하락&#39; url = url1 end = &#39;멈춰!!!!!&#39; stop() . KOSPI 하락 . 멈춰!!!!! . &#50696;&#51228; 1,2,3&#51012; &#53364;&#47000;&#49828;&#47484; &#51060;&#50857;&#54644; &#46041;&#49884;&#44288;&#47532; . class STOOOP: # STOOOP 은 양식문서의 이름이라 생각할 수 있다. title = &quot;학교폭력&quot; url = url1 end = &quot;멈춰~~~~&quot; def stop(self): ## 규칙1: class안에서 정의된 함수는 첫번째 입력으로 무조건 self htmlstr = &quot;&lt;p&gt; {title} &lt;/p&gt; &lt;img src= &#39;{url}&#39;&gt; &lt;p&gt; {end} &lt;/p&gt; &quot; display(HTML(htmlstr.format(title=self.title,url=self.url,end=self.end))) ## 규칙2: class안에서 정의된 변수 (title, url, end)를 쓰려면 &quot;self.변수이름&quot;의 형태로 써야함 . $t=1$ &quot;&#54617;&#44368;&#54253;&#47141; &#47688;&#52656;&quot; &#49373;&#49457; . school = STOOOP() # STOOOP이라는 이름의 양식문서를 복사해 하나의 hwp를 파일을 만들어 밈을 생성하고 그 파일이름을 school이라고 하자. # 그러니까 STOOP.hwp 와 school.hwp가 있는 상황 . school.title . &#39;학교폭력&#39; . school.url . &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39; . school.end . &#39;멈춰~~~~&#39; . school.stop() . 학교폭력 . 멈춰~~~~ . $t=2$: &quot;&#53076;&#49828;&#54588;&#54616;&#46973; &#47688;&#52656;&quot; &#49373;&#49457; . kospi = STOOOP() # 코스피하락 멈춰를 위해 STOOP.hwp양식문서에서 하나의 밈을 찍어낸다(=kospi.hwp 생성). . kospi.title, kospi.url, kospi.end . (&#39;학교폭력&#39;, &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39;, &#39;멈춰~~~~&#39;) . kospi.title = &#39;코스피하락&#39; # kospi.hwp 제목을 코스피하락으로 변경 . kospi.title, kospi.url, kospi.end . (&#39;코스피하락&#39;, &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39;, &#39;멈춰~~~~&#39;) . kospi.stop() . 코스피하락 . 멈춰~~~~ . $t=3$: &quot;&#49688;&#44053;&#49888;&#52397; &#47588;&#53356;&#47196; &#47688;&#52656;&quot; &#49373;&#49457; . macro = STOOOP() . macro.title, macro.url, macro.end . (&#39;학교폭력&#39;, &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39;, &#39;멈춰~~~~&#39;) . macro.title = &#39;수강신청 매크로&#39; . macro.title, macro.url, macro.end . (&#39;수강신청 매크로&#39;, &#39;https://github.com/guebin/IP2022/blob/master/_notebooks/2022-05-07-stop1.jpeg?raw=true&#39;, &#39;멈춰~~~~&#39;) . macro.stop() . 수강신청 매크로 . 멈춰~~~~ . $t=4$: &quot;&#49688;&#44053;&#49888;&#52397; &#47588;&#53356;&#47196; &#47688;&#52656;&quot;&#51032; &#45149;&#51012; &#47932;&#44208;&#45824;&#49888; &#45712;&#45196;&#54364;&#47196;! . macro.end = &#39;멈춰!!!!!&#39; . macro.stop() . 수강신청 매크로 . 멈춰!!!!! . $t=5$: &quot;&#53076;&#49828;&#54588;&#54616;&#46973; &#47688;&#52656;&quot;&#47484; &#45796;&#49884; &#52636;&#47141; . kospi.stop() . 코스피하락 . 멈춰~~~~ . $t=6$: &quot;&#54617;&#44368;&#54253;&#47141; &#47688;&#52656;&quot;&#50752; &quot;&#53076;&#49828;&#54588;&#54616;&#46973; &#47688;&#52656;&quot;&#47484; &#46041;&#49884;&#50640; &#52636;&#47141; . school.stop() . 학교폭력 . 멈춰~~~~ . kospi.stop() . 코스피하락 . 멈춰~~~~ . $t=7$ &quot;&#54617;&#44368;&#54253;&#47141; &#47688;&#52656;&quot;&#51032; &#51060;&#48120;&#51648;&#47484; &#49888;&#54812;&#49440;&#51004;&#47196; &#48320;&#44221;, &quot;&#53076;&#49828;&#54588;&#54616;&#46973; &#47688;&#52656;&quot;&#51032; title&#51012; &#39;KOSPI&#54616;&#46973;&#39;&#51004;&#47196; &#48320;&#44221; . school.url = url2 kospi.title = &#39;KOSPI 하락&#39; . school.stop() . 학교폭력 . 멈춰~~~~ . kospi.stop() . KOSPI 하락 . 멈춰~~~~ . &#49689;&#51228; . - &quot;수강신청 멈춰&quot;의 이미지를 신혜선으로 변경하고 출력해볼 것 . macro.url 변경 | macro.stop() 을 사용 | .",
            "url": "https://guebin.github.io/IP2022/2022/05/09/(10%EC%A3%BC%EC%B0%A8)-5%EC%9B%949%EC%9D%BC.html",
            "relUrl": "/2022/05/09/(10%EC%A3%BC%EC%B0%A8)-5%EC%9B%949%EC%9D%BC.html",
            "date": " • May 9, 2022"
        }
        
    
  
    
        ,"post11": {
            "title": "(10주차) 5월6일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 부분 데이터 꺼내기: 판다스를 왜 써야할까? . - (2/8) pandas 개발동기 . - (3/8) 열의 이름 부여 . - (4/8) 행의 이름 부여, 자료형, len, shape, for문의 반복변수, pd.Series . - (5/8) 첫번째 칼럼을 선택, 여러개의 칼럼을 선택 . - (6/8) 첫번째 행의 선택, 여러개의 행을 선택 . - (7/8) query (1) . - (8/8) query (2), 판다스공부 3단계 . import . import numpy as np import pandas as pd . &#48512;&#48516; &#45936;&#51060;&#53552; &#44732;&#45236;&#44592;: &#54032;&#45796;&#49828;&#47484; &#50780; &#50024;&#50556;&#54624;&#44620;? . &#44592;&#48376; &#51064;&#45937;&#49905; . - 예제1: 기본인덱싱 . a=&#39;asdf&#39; a[2] . &#39;d&#39; . a[-1] . &#39;f&#39; . - 예제2: 슬라이싱 . a=&#39;asdf&#39; a[1:3] . &#39;sd&#39; . a[-2:] . &#39;df&#39; . - 예제3: 스트라이딩 . a=&#39;asdfg&#39; a[::2] . &#39;adg&#39; . - 예제4: 불가능한것 . a=&#39;asdf&#39; a[[1,2]] # 정수인덱스를 리스트화 시켜서 인덱싱하는 것은 불가능 . TypeError Traceback (most recent call last) Input In [9], in &lt;cell line: 2&gt;() 1 a=&#39;asdf&#39; -&gt; 2 a[[1,2]] TypeError: string indices must be integers . a=&#39;asdf&#39; a[[True,True,False,False]] . TypeError Traceback (most recent call last) Input In [10], in &lt;cell line: 2&gt;() 1 a=&#39;asdf&#39; -&gt; 2 a[[True,True,False,False]] TypeError: string indices must be integers . &#54060;&#49884; &#51064;&#45937;&#49905; . - 예제1: 인덱스의 리스트 (혹은 ndarray)를 전달 . a=np.arange(55,61) a . array([55, 56, 57, 58, 59, 60]) . a[[1,2,-1]] . array([56, 57, 60]) . a[np.array([1,2,-1])] . array([56, 57, 60]) . - 예제2: bool로 이루어진 리스트 (혹은 ndarray)를 전달 . a=np.arange(55,61) a . array([55, 56, 57, 58, 59, 60]) . a[[True,True,False,False,False,False]] . array([55, 56]) . a[np.array([True,True,False,False,False,False])] . array([55, 56]) . a[a&lt;58] . array([55, 56, 57]) . 2&#52264;&#50896;&#51088;&#47308;&#54805;&#51032; &#51064;&#45937;&#49905; . - 예제1 . a = np.arange(4*3).reshape(4,3) a . array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]]) . a[0:2,1] . array([1, 4]) . - 예제2: 차원을 유지하면서 인덱싱을 하고 싶으면? . a = np.arange(4*3).reshape(4,3) a[0:2,[1]] . array([[1], [4]]) . Hash . - 예제1: (key,value) . d={&#39;att&#39;:65, &#39;rep&#39;:45, &#39;mid&#39;:30, &#39;fin&#39;:100} d . {&#39;att&#39;: 65, &#39;rep&#39;: 45, &#39;mid&#39;: 30, &#39;fin&#39;: 100} . d[&#39;att&#39;] # key를 넣으면 value가 리턴 . 65 . - 예제2: numpy와 비교 . np.random.seed(43052) att = np.random.choice(np.arange(10,21)*5,200) rep = np.random.choice(np.arange(5,21)*5,200) mid = np.random.choice(np.arange(0,21)*5,200) fin = np.random.choice(np.arange(0,21)*5,200) key = [&#39;202212&#39;+str(s) for s in np.random.choice(np.arange(300,501),200,replace=False)] test_dic = {key[i] : {&#39;att&#39;:att[i], &#39;rep&#39;:rep[i], &#39;mid&#39;:mid[i], &#39;fin&#39;:fin[i]} for i in range(200)} test_ndarray = np.array([key,att,rep,mid,fin],dtype=np.int64).T del(att);del(rep);del(mid);del(fin);del(key) . 학번 &#39;202212460&#39;에 해당하는 학생의 출석점수를 알고 싶다면? . (풀이1) . test_dic[&#39;202212460&#39;][&#39;att&#39;] . 55 . (풀이2) . test_ndarray[test_ndarray[:,0] == 202212460, 1] ## 이게 무슨코드야 도데체! . array([55]) . (풀이2)가 (풀이1)에 비하여 불편한 점 . test_ndarray의 첫칼럼은 student id 이고 두번째 칼럼은 att라는 사실을 암기하고 있어야 한다. | student id가 아니고 만약에 학생이름을 써서 데이터를 정리한다면 모든 자료형은 문자형이 되어야 한다. | 작성한 코드의 가독성이 없다. (위치로 접근하기 때문) | . - 요약: hash 스타일로 정보를 추출하는 것이 유용할 때가 있다. 그리고 보통 hash 스타일로 정보를 뽑는 것이 유리하다. (사실 numpy는 정보추출을 위해 개발된 자료형이 아니라 행렬 및 벡터의 수학연산을 지원하기 위해 개발된 자료형이다) . - 소망: 정보를 추출할때는 hash 스타일도 유용하다는 것은 이해함 $ to$ 하지만 나는 가끔 넘파이스타일로 정보를 뽑고 싶은걸? 그리고 딕셔너리 형태가 아니고 엑셀처럼(행렬처럼) 데이터를 보고 싶은걸? $ to$ pandas의 개발 . pandas &#44060;&#48156;&#46041;&#44592; . &#50641;&#49472;&#52376;&#47100; &#45936;&#51060;&#53552;&#47484; &#53580;&#51060;&#48660; &#54805;&#53468;&#47196; &#51221;&#47532;&#54616;&#44256; &#49910;&#45796; . np.random.seed(43052) att = np.random.choice(np.arange(10,21)*5,20) rep = np.random.choice(np.arange(5,21)*5,20) mid = np.random.choice(np.arange(0,21)*5,20) fin = np.random.choice(np.arange(0,21)*5,20) key = [&#39;202212&#39;+str(s) for s in np.random.choice(np.arange(300,501),20,replace=False)] test_dic = {key[i] : {&#39;att&#39;:att[i], &#39;rep&#39;:rep[i], &#39;mid&#39;:mid[i], &#39;fin&#39;:fin[i]} for i in range(20)} . test_dic . {&#39;202212380&#39;: {&#39;att&#39;: 65, &#39;rep&#39;: 55, &#39;mid&#39;: 50, &#39;fin&#39;: 40}, &#39;202212370&#39;: {&#39;att&#39;: 95, &#39;rep&#39;: 100, &#39;mid&#39;: 50, &#39;fin&#39;: 80}, &#39;202212363&#39;: {&#39;att&#39;: 65, &#39;rep&#39;: 90, &#39;mid&#39;: 60, &#39;fin&#39;: 30}, &#39;202212488&#39;: {&#39;att&#39;: 55, &#39;rep&#39;: 80, &#39;mid&#39;: 75, &#39;fin&#39;: 80}, &#39;202212312&#39;: {&#39;att&#39;: 80, &#39;rep&#39;: 30, &#39;mid&#39;: 30, &#39;fin&#39;: 100}, &#39;202212377&#39;: {&#39;att&#39;: 75, &#39;rep&#39;: 40, &#39;mid&#39;: 100, &#39;fin&#39;: 15}, &#39;202212463&#39;: {&#39;att&#39;: 65, &#39;rep&#39;: 45, &#39;mid&#39;: 45, &#39;fin&#39;: 90}, &#39;202212471&#39;: {&#39;att&#39;: 60, &#39;rep&#39;: 60, &#39;mid&#39;: 25, &#39;fin&#39;: 0}, &#39;202212400&#39;: {&#39;att&#39;: 95, &#39;rep&#39;: 65, &#39;mid&#39;: 20, &#39;fin&#39;: 10}, &#39;202212469&#39;: {&#39;att&#39;: 90, &#39;rep&#39;: 80, &#39;mid&#39;: 80, &#39;fin&#39;: 20}, &#39;202212318&#39;: {&#39;att&#39;: 55, &#39;rep&#39;: 75, &#39;mid&#39;: 35, &#39;fin&#39;: 25}, &#39;202212432&#39;: {&#39;att&#39;: 95, &#39;rep&#39;: 95, &#39;mid&#39;: 45, &#39;fin&#39;: 0}, &#39;202212443&#39;: {&#39;att&#39;: 95, &#39;rep&#39;: 55, &#39;mid&#39;: 15, &#39;fin&#39;: 35}, &#39;202212367&#39;: {&#39;att&#39;: 50, &#39;rep&#39;: 80, &#39;mid&#39;: 40, &#39;fin&#39;: 30}, &#39;202212458&#39;: {&#39;att&#39;: 50, &#39;rep&#39;: 55, &#39;mid&#39;: 15, &#39;fin&#39;: 85}, &#39;202212396&#39;: {&#39;att&#39;: 95, &#39;rep&#39;: 30, &#39;mid&#39;: 30, &#39;fin&#39;: 95}, &#39;202212482&#39;: {&#39;att&#39;: 50, &#39;rep&#39;: 50, &#39;mid&#39;: 45, &#39;fin&#39;: 10}, &#39;202212452&#39;: {&#39;att&#39;: 65, &#39;rep&#39;: 55, &#39;mid&#39;: 15, &#39;fin&#39;: 45}, &#39;202212387&#39;: {&#39;att&#39;: 70, &#39;rep&#39;: 70, &#39;mid&#39;: 40, &#39;fin&#39;: 35}, &#39;202212354&#39;: {&#39;att&#39;: 90, &#39;rep&#39;: 90, &#39;mid&#39;: 80, &#39;fin&#39;: 90}} . 테이블형태로 보고 싶다. | . (방법1) -- 행렬이기는 하지만 방법 2,3,4,5 에 비하여 우리가 원하는 만큼 가독성을 주는 형태는 아님.. . test_ndarray = np.array([key,att,rep,mid,fin],dtype=np.int64).T test_ndarray . array([[202212380, 65, 55, 50, 40], [202212370, 95, 100, 50, 80], [202212363, 65, 90, 60, 30], [202212488, 55, 80, 75, 80], [202212312, 80, 30, 30, 100], [202212377, 75, 40, 100, 15], [202212463, 65, 45, 45, 90], [202212471, 60, 60, 25, 0], [202212400, 95, 65, 20, 10], [202212469, 90, 80, 80, 20], [202212318, 55, 75, 35, 25], [202212432, 95, 95, 45, 0], [202212443, 95, 55, 15, 35], [202212367, 50, 80, 40, 30], [202212458, 50, 55, 15, 85], [202212396, 95, 30, 30, 95], [202212482, 50, 50, 45, 10], [202212452, 65, 55, 15, 45], [202212387, 70, 70, 40, 35], [202212354, 90, 90, 80, 90]]) . (방법2) . pd.DataFrame(test_dic).T . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212370 95 | 100 | 50 | 80 | . 202212363 65 | 90 | 60 | 30 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212377 75 | 40 | 100 | 15 | . 202212463 65 | 45 | 45 | 90 | . 202212471 60 | 60 | 25 | 0 | . 202212400 95 | 65 | 20 | 10 | . 202212469 90 | 80 | 80 | 20 | . 202212318 55 | 75 | 35 | 25 | . 202212432 95 | 95 | 45 | 0 | . 202212443 95 | 55 | 15 | 35 | . 202212367 50 | 80 | 40 | 30 | . 202212458 50 | 55 | 15 | 85 | . 202212396 95 | 30 | 30 | 95 | . 202212482 50 | 50 | 45 | 10 | . 202212452 65 | 55 | 15 | 45 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . (방법3) . test_dic2 = {&#39;att&#39;:{key[i]:att[i] for i in range(20)}, &#39;rep&#39;:{key[i]:rep[i] for i in range(20)}, &#39;mid&#39;:{key[i]:mid[i] for i in range(20)}, &#39;fin&#39;:{key[i]:fin[i] for i in range(20)}} . pd.DataFrame(test_dic2) . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212370 95 | 100 | 50 | 80 | . 202212363 65 | 90 | 60 | 30 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212377 75 | 40 | 100 | 15 | . 202212463 65 | 45 | 45 | 90 | . 202212471 60 | 60 | 25 | 0 | . 202212400 95 | 65 | 20 | 10 | . 202212469 90 | 80 | 80 | 20 | . 202212318 55 | 75 | 35 | 25 | . 202212432 95 | 95 | 45 | 0 | . 202212443 95 | 55 | 15 | 35 | . 202212367 50 | 80 | 40 | 30 | . 202212458 50 | 55 | 15 | 85 | . 202212396 95 | 30 | 30 | 95 | . 202212482 50 | 50 | 45 | 10 | . 202212452 65 | 55 | 15 | 45 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . (방법4) . df = pd.DataFrame({&#39;att&#39;:att, &#39;rep&#39;:rep, &#39;mid&#39;:mid, &#39;fin&#39;:fin},index=key) df . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212370 95 | 100 | 50 | 80 | . 202212363 65 | 90 | 60 | 30 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212377 75 | 40 | 100 | 15 | . 202212463 65 | 45 | 45 | 90 | . 202212471 60 | 60 | 25 | 0 | . 202212400 95 | 65 | 20 | 10 | . 202212469 90 | 80 | 80 | 20 | . 202212318 55 | 75 | 35 | 25 | . 202212432 95 | 95 | 45 | 0 | . 202212443 95 | 55 | 15 | 35 | . 202212367 50 | 80 | 40 | 30 | . 202212458 50 | 55 | 15 | 85 | . 202212396 95 | 30 | 30 | 95 | . 202212482 50 | 50 | 45 | 10 | . 202212452 65 | 55 | 15 | 45 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . (방법5) . df = pd.DataFrame({&#39;att&#39;:att, &#39;rep&#39;:rep, &#39;mid&#39;:mid, &#39;fin&#39;:fin}) df . att rep mid fin . 0 65 | 55 | 50 | 40 | . 1 95 | 100 | 50 | 80 | . 2 65 | 90 | 60 | 30 | . 3 55 | 80 | 75 | 80 | . 4 80 | 30 | 30 | 100 | . 5 75 | 40 | 100 | 15 | . 6 65 | 45 | 45 | 90 | . 7 60 | 60 | 25 | 0 | . 8 95 | 65 | 20 | 10 | . 9 90 | 80 | 80 | 20 | . 10 55 | 75 | 35 | 25 | . 11 95 | 95 | 45 | 0 | . 12 95 | 55 | 15 | 35 | . 13 50 | 80 | 40 | 30 | . 14 50 | 55 | 15 | 85 | . 15 95 | 30 | 30 | 95 | . 16 50 | 50 | 45 | 10 | . 17 65 | 55 | 15 | 45 | . 18 70 | 70 | 40 | 35 | . 19 90 | 90 | 80 | 90 | . df=df.set_index([key]) df . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212370 95 | 100 | 50 | 80 | . 202212363 65 | 90 | 60 | 30 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212377 75 | 40 | 100 | 15 | . 202212463 65 | 45 | 45 | 90 | . 202212471 60 | 60 | 25 | 0 | . 202212400 95 | 65 | 20 | 10 | . 202212469 90 | 80 | 80 | 20 | . 202212318 55 | 75 | 35 | 25 | . 202212432 95 | 95 | 45 | 0 | . 202212443 95 | 55 | 15 | 35 | . 202212367 50 | 80 | 40 | 30 | . 202212458 50 | 55 | 15 | 85 | . 202212396 95 | 30 | 30 | 95 | . 202212482 50 | 50 | 45 | 10 | . 202212452 65 | 55 | 15 | 45 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . &#54644;&#49905;&#51004;&#47196; &#50896;&#54616;&#45716; &#51221;&#48372;&#47484; &#48977;&#51004;&#47732; &#51339;&#44192;&#45796; (&#47560;&#52824; &#46357;&#49492;&#45320;&#47532;&#52376;&#47100;) . - 예제1: 출석점수를 출력 . test_dic2[&#39;att&#39;] . {&#39;202212380&#39;: 65, &#39;202212370&#39;: 95, &#39;202212363&#39;: 65, &#39;202212488&#39;: 55, &#39;202212312&#39;: 80, &#39;202212377&#39;: 75, &#39;202212463&#39;: 65, &#39;202212471&#39;: 60, &#39;202212400&#39;: 95, &#39;202212469&#39;: 90, &#39;202212318&#39;: 55, &#39;202212432&#39;: 95, &#39;202212443&#39;: 95, &#39;202212367&#39;: 50, &#39;202212458&#39;: 50, &#39;202212396&#39;: 95, &#39;202212482&#39;: 50, &#39;202212452&#39;: 65, &#39;202212387&#39;: 70, &#39;202212354&#39;: 90} . df[&#39;att&#39;] . 202212380 65 202212370 95 202212363 65 202212488 55 202212312 80 202212377 75 202212463 65 202212471 60 202212400 95 202212469 90 202212318 55 202212432 95 202212443 95 202212367 50 202212458 50 202212396 95 202212482 50 202212452 65 202212387 70 202212354 90 Name: att, dtype: int64 . - 예제2: 학번 202212380&#39;의 출석점수 출력 . test_dic2[&#39;att&#39;][&#39;202212380&#39;] . 65 . df[&#39;att&#39;][&#39;202212380&#39;] . 65 . &#51064;&#45937;&#49905;&#51004;&#47196; &#51221;&#48372;&#47484; &#48977;&#45716; &#44592;&#45733;&#46020; &#51648;&#50896;&#51012; &#54616;&#47732; &#51339;&#44192;&#45796; (&#47560;&#52824; &#47532;&#49828;&#53944;&#45208; &#45336;&#54028;&#51060;&#52376;&#47100;) . - 예제1: 첫번째 학생의 기말고사 성적을 출력하고 싶다. . test_ndarray[0,-1] . 40 . df.iloc[0,-1] . 40 . 벼락치기: df에서 iloc이라는 특수기능을 이용하면 넘파이 인덱싱처럼 원소출력이 가능하다. | . - 예제2: 홀수번째 학생의 점수를 뽑고 싶다. . test_ndarray[::2] . array([[202212380, 65, 55, 50, 40], [202212363, 65, 90, 60, 30], [202212312, 80, 30, 30, 100], [202212463, 65, 45, 45, 90], [202212400, 95, 65, 20, 10], [202212318, 55, 75, 35, 25], [202212443, 95, 55, 15, 35], [202212458, 50, 55, 15, 85], [202212482, 50, 50, 45, 10], [202212387, 70, 70, 40, 35]]) . df.iloc[::2] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212363 65 | 90 | 60 | 30 | . 202212312 80 | 30 | 30 | 100 | . 202212463 65 | 45 | 45 | 90 | . 202212400 95 | 65 | 20 | 10 | . 202212318 55 | 75 | 35 | 25 | . 202212443 95 | 55 | 15 | 35 | . 202212458 50 | 55 | 15 | 85 | . 202212482 50 | 50 | 45 | 10 | . 202212387 70 | 70 | 40 | 35 | . - 예제3: 맨 끝에서 3명의 점수를 출력하고 싶다. . test_ndarray[-3:] . array([[202212452, 65, 55, 15, 45], [202212387, 70, 70, 40, 35], [202212354, 90, 90, 80, 90]]) . df.iloc[-3:] . att rep mid fin . 202212452 65 | 55 | 15 | 45 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . df[-3:] . att rep mid fin . 202212452 65 | 55 | 15 | 45 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . - 예제4: 맨 끝에서 3명의 점수중 마지막 2개의 칼럼만 출력하고 싶다. . test_ndarray[-3:,-2:] . array([[15, 45], [40, 35], [80, 90]]) . df.iloc[-3:,-2:] . mid fin . 202212452 15 | 45 | . 202212387 40 | 35 | . 202212354 80 | 90 | . &#44417;&#44537;: &#54644;&#49905;&#44284; &#51064;&#45937;&#49905;&#51012; &#47784;&#46160; &#51648;&#50896;&#54616;&#45716; &#50500;&#51452; &#50864;&#49688;&#54620; &#51088;&#47308;&#54805;&#51012; &#47564;&#46308;&#44256; &#49910;&#51020; . - 예제1: 중간고사 점수가 20점 이상이면서 동시에 출석점수가 60점미만인 학생들의 기말고사 점수를 출력 . (방법1) 데이터베이스 스타일 . df.query(&quot;mid &gt;= 20 and att &lt;60&quot;) . att rep mid fin . 202212488 55 | 80 | 75 | 80 | . 202212318 55 | 75 | 35 | 25 | . 202212367 50 | 80 | 40 | 30 | . 202212482 50 | 50 | 45 | 10 | . df.query(&quot;mid &gt;= 20 and att &lt;60&quot;)[&#39;fin&#39;] . 202212488 80 202212318 25 202212367 30 202212482 10 Name: fin, dtype: int64 . (방법2) 넘파이 스타일이라면? . test_ndarray . array([[202212380, 65, 55, 50, 40], [202212370, 95, 100, 50, 80], [202212363, 65, 90, 60, 30], [202212488, 55, 80, 75, 80], [202212312, 80, 30, 30, 100], [202212377, 75, 40, 100, 15], [202212463, 65, 45, 45, 90], [202212471, 60, 60, 25, 0], [202212400, 95, 65, 20, 10], [202212469, 90, 80, 80, 20], [202212318, 55, 75, 35, 25], [202212432, 95, 95, 45, 0], [202212443, 95, 55, 15, 35], [202212367, 50, 80, 40, 30], [202212458, 50, 55, 15, 85], [202212396, 95, 30, 30, 95], [202212482, 50, 50, 45, 10], [202212452, 65, 55, 15, 45], [202212387, 70, 70, 40, 35], [202212354, 90, 90, 80, 90]]) . test_ndarray[:,3] &gt;= 20 ## 중간고사가 20점이상 . array([ True, True, True, True, True, True, True, True, True, True, True, True, False, True, False, True, True, False, True, True]) . test_ndarray[:,1] &lt; 60 ## 출석이 60미만 . array([False, False, False, True, False, False, False, False, False, False, True, False, False, True, True, False, True, False, False, False]) . (test_ndarray[:,3] &gt;= 20) &amp; (test_ndarray[:,1] &lt; 60) . array([False, False, False, True, False, False, False, False, False, False, True, False, False, True, False, False, True, False, False, False]) . . Note: test_ndarray[:,3] &gt;= 20 &amp; test_ndarray[:,1] &lt; 60 와 같이 하면 에러가 난다. 조심하자! . test_ndarray[(test_ndarray[:,3] &gt;= 20) &amp; (test_ndarray[:,1] &lt; 60),-1] # 이게 무슨코드야 . array([80, 25, 30, 10]) . 구현난이도 어려움, 가독성 꽝 | . - 예제2: &#39;중간고사점수&lt;기말고사점수&#39;인 학생들의 출석점수 평균을 구하자. . df.query(&#39;mid&lt;fin&#39;)[&#39;att&#39;].mean() . 76.66666666666667 . pandas &#49324;&#50857;&#48277; . pandas &#44277;&#48512; 1&#45800;&#44228; . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; &#49440;&#50616; . - 방법1: dictionary에서 만든다. . pd.DataFrame({&#39;att&#39;:[30,40,50],&#39;mid&#39;:[50,60,70]}) . att mid . 0 30 | 50 | . 1 40 | 60 | . 2 50 | 70 | . pd.DataFrame({&#39;att&#39;:(30,40,50),&#39;mid&#39;:(50,60,70)}) . att mid . 0 30 | 50 | . 1 40 | 60 | . 2 50 | 70 | . pd.DataFrame({&#39;att&#39;:np.array([30,40,50]),&#39;mid&#39;:np.array([50,60,70])}) . att mid . 0 30 | 50 | . 1 40 | 60 | . 2 50 | 70 | . - 방법: 2차원 ndarray에서 만든다. . np.arange(2*3).reshape(2,3) . array([[0, 1, 2], [3, 4, 5]]) . pd.DataFrame(np.arange(2*3).reshape(2,3)) . 0 1 2 . 0 0 | 1 | 2 | . 1 3 | 4 | 5 | . &#50676;&#51032; &#51060;&#47492; &#48512;&#50668; . - 방법1: 딕셔너리를 통하여 만들면 딕셔너리의 key가 자동으로 열의 이름이 된다. . pd.DataFrame({&#39;att&#39;:np.array([30,40,50]),&#39;mid&#39;:np.array([50,60,70])}) . att mid . 0 30 | 50 | . 1 40 | 60 | . 2 50 | 70 | . - 방법2: pd.DataFrame()의 옵션에 columns를 이용 . pd.DataFrame(np.arange(2*3).reshape(2,3),columns=[&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;]) . X1 X2 X3 . 0 0 | 1 | 2 | . 1 3 | 4 | 5 | . - 방법3: df.columns에 원하는 열이름을 덮어씀 (1) . df=pd.DataFrame(np.arange(2*3).reshape(2,3)) df . 0 1 2 . 0 0 | 1 | 2 | . 1 3 | 4 | 5 | . df.columns = [&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;] . df . X1 X2 X3 . 0 0 | 1 | 2 | . 1 3 | 4 | 5 | . df.columns . Index([&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;], dtype=&#39;object&#39;) . - 방법4: df.columns에 원하는 열이름을 덮어씀 (2) . df=pd.DataFrame(np.arange(2*3).reshape(2,3)) df . 0 1 2 . 0 0 | 1 | 2 | . 1 3 | 4 | 5 | . df.columns = pd.Index([&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;]) . df . X1 X2 X3 . 0 0 | 1 | 2 | . 1 3 | 4 | 5 | . 방법4가 방법3의 방식보다 컴퓨터가 이해하기 좋다. (= 불필요한 에러를 방지할 수 있다) . df.columns, type(df.columns) . (Index([&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;], dtype=&#39;object&#39;), pandas.core.indexes.base.Index) . [&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;], type([&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;]) . ([&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;], list) . pd.Index([&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;]), type(pd.Index([&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;])) . (Index([&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;], dtype=&#39;object&#39;), pandas.core.indexes.base.Index) . &#54665;&#51032; &#51060;&#47492; &#48512;&#50668; . - 방법1: 중첩 dict이면 nested dic의 key가 알아서 행의 이름으로 된다. . pd.DataFrame({&#39;att&#39;:{&#39;guebin&#39;:30, &#39;iu&#39;:40, &#39;hynn&#39;:50} , &#39;mid&#39;:{&#39;guebin&#39;:5, &#39;iu&#39;:45, &#39;hynn&#39;:90}}) . att mid . guebin 30 | 5 | . iu 40 | 45 | . hynn 50 | 90 | . - 방법2: pd.DataFrame()의 index 옵션 이용 . pd.DataFrame({&#39;att&#39;:[30,40,50] , &#39;mid&#39;:[5,45,90]}, index=[&#39;guebin&#39;,&#39;iu&#39;,&#39;hynn&#39;]) . att mid . guebin 30 | 5 | . iu 40 | 45 | . hynn 50 | 90 | . - 방법3: df.index에 덮어씌움 . df=pd.DataFrame({&#39;att&#39;:[30,40,50] , &#39;mid&#39;:[5,45,90]}) df . att mid . 0 30 | 5 | . 1 40 | 45 | . 2 50 | 90 | . df.index = pd.Index([&#39;guebin&#39;,&#39;iu&#39;,&#39;hynn&#39;]) #df.index = [&#39;guebin&#39;,&#39;iu&#39;,&#39;hynn&#39;] &lt;- 이것도 실행 되기는 된다. df . att mid . guebin 30 | 5 | . iu 40 | 45 | . hynn 50 | 90 | . - 방법4: df.set_index() 를 이용하여 덮어씌운다 . df=pd.DataFrame({&#39;att&#39;:[30,40,50] , &#39;mid&#39;:[5,45,90]}) df . att mid . 0 30 | 5 | . 1 40 | 45 | . 2 50 | 90 | . df.set_index(pd.Index([&#39;guebin&#39;,&#39;iu&#39;,&#39;hynn&#39;])) . att mid . guebin 30 | 5 | . iu 40 | 45 | . hynn 50 | 90 | . (주의) 아래는 에러가 난다. . df.set_index([&#39;guebin&#39;,&#39;iu&#39;,&#39;hynn&#39;]) . KeyError Traceback (most recent call last) Input In [230], in &lt;cell line: 1&gt;() -&gt; 1 df.set_index([&#39;guebin&#39;,&#39;iu&#39;,&#39;hynn&#39;]) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/util/_decorators.py:311, in deprecate_nonkeyword_arguments.&lt;locals&gt;.decorate.&lt;locals&gt;.wrapper(*args, **kwargs) 305 if len(args) &gt; num_allow_args: 306 warnings.warn( 307 msg.format(arguments=arguments), 308 FutureWarning, 309 stacklevel=stacklevel, 310 ) --&gt; 311 return func(*args, **kwargs) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/frame.py:5488, in DataFrame.set_index(self, keys, drop, append, inplace, verify_integrity) 5485 missing.append(col) 5487 if missing: -&gt; 5488 raise KeyError(f&#34;None of {missing} are in the columns&#34;) 5490 if inplace: 5491 frame = self KeyError: &#34;None of [&#39;guebin&#39;, &#39;iu&#39;, &#39;hynn&#39;] are in the columns&#34; . df.set_index([[&#39;guebin&#39;,&#39;iu&#39;,&#39;hynn&#39;]]) # 꺽쇠를 한번 더 넣어주면 에러를 피할수 있다. . att mid . guebin 30 | 5 | . iu 40 | 45 | . hynn 50 | 90 | . &#51088;&#47308;&#54805;, len, shape, for&#47928;&#51032; &#48152;&#48373;&#48320;&#49688; . df = pd.DataFrame({&#39;att&#39;:[30,40,50],&#39;mid&#39;:[5,45,90]}) df . att mid . 0 30 | 5 | . 1 40 | 45 | . 2 50 | 90 | . - type . type(df) . pandas.core.frame.DataFrame . - len . len(df) # row의 갯수 . 3 . - shape . df.shape . (3, 2) . - for문의 반복변수 . for k in df: print(k) # 딕셔너리같죠 . att mid . for k in {&#39;att&#39;:[30,40,50],&#39;mid&#39;:[5,45,90]}: print(k) . att mid . pd.Series . - 2차원 ndarray가 pd.DataFrame에 대응한다면 1차원 ndarray는 pd.Series에 대응한다. . a=pd.Series(np.random.randn(10)) a . 0 0.453758 1 -0.716270 2 -0.167750 3 0.089546 4 0.874006 5 0.401627 6 0.204911 7 1.042722 8 -0.352356 9 -1.241658 dtype: float64 . type(a) . pandas.core.series.Series . len(a) . 10 . a.shape . (10,) . for value in a: print(value) . 0.45375797778887145 -0.7162702753778524 -0.1677503294060748 0.08954572073306402 0.8740060519863648 0.40162700372357163 0.20491068603376858 1.0427224662413124 -0.3523562215445016 -1.2416580554177619 . pandas &#44277;&#48512; 2&#45800;&#44228; . - 데이터 . np.random.seed(43052) att = np.random.choice(np.arange(10,21)*5,20) rep = np.random.choice(np.arange(5,21)*5,20) mid = np.random.choice(np.arange(0,21)*5,20) fin = np.random.choice(np.arange(0,21)*5,20) key = [&#39;202212&#39;+str(s) for s in np.random.choice(np.arange(300,501),20,replace=False)] . df=pd.DataFrame({&#39;att&#39;:att,&#39;rep&#39;:rep,&#39;mid&#39;:mid,&#39;fin&#39;:fin},index=key) df . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212370 95 | 100 | 50 | 80 | . 202212363 65 | 90 | 60 | 30 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212377 75 | 40 | 100 | 15 | . 202212463 65 | 45 | 45 | 90 | . 202212471 60 | 60 | 25 | 0 | . 202212400 95 | 65 | 20 | 10 | . 202212469 90 | 80 | 80 | 20 | . 202212318 55 | 75 | 35 | 25 | . 202212432 95 | 95 | 45 | 0 | . 202212443 95 | 55 | 15 | 35 | . 202212367 50 | 80 | 40 | 30 | . 202212458 50 | 55 | 15 | 85 | . 202212396 95 | 30 | 30 | 95 | . 202212482 50 | 50 | 45 | 10 | . 202212452 65 | 55 | 15 | 45 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . &#52395;&#48264;&#51704; &#52860;&#47100;&#51012; &#49440;&#53469; . - 방법1 . df.att . 202212380 65 202212370 95 202212363 65 202212488 55 202212312 80 202212377 75 202212463 65 202212471 60 202212400 95 202212469 90 202212318 55 202212432 95 202212443 95 202212367 50 202212458 50 202212396 95 202212482 50 202212452 65 202212387 70 202212354 90 Name: att, dtype: int64 . - 방법2: dict스타일 . df[&#39;att&#39;] . 202212380 65 202212370 95 202212363 65 202212488 55 202212312 80 202212377 75 202212463 65 202212471 60 202212400 95 202212469 90 202212318 55 202212432 95 202212443 95 202212367 50 202212458 50 202212396 95 202212482 50 202212452 65 202212387 70 202212354 90 Name: att, dtype: int64 . - 방법3: dict스타일 . df[[&#39;att&#39;]] . att . 202212380 65 | . 202212370 95 | . 202212363 65 | . 202212488 55 | . 202212312 80 | . 202212377 75 | . 202212463 65 | . 202212471 60 | . 202212400 95 | . 202212469 90 | . 202212318 55 | . 202212432 95 | . 202212443 95 | . 202212367 50 | . 202212458 50 | . 202212396 95 | . 202212482 50 | . 202212452 65 | . 202212387 70 | . 202212354 90 | . df.att 나 df[&#39;att&#39;]는 series를 리턴하고 df[[&#39;att&#39;]]는 dataframe을 리턴한다. | . - 방법4: ndarray스타일 . df.iloc[:,0] . 202212380 65 202212370 95 202212363 65 202212488 55 202212312 80 202212377 75 202212463 65 202212471 60 202212400 95 202212469 90 202212318 55 202212432 95 202212443 95 202212367 50 202212458 50 202212396 95 202212482 50 202212452 65 202212387 70 202212354 90 Name: att, dtype: int64 . - 방법5: ndarray스타일 . df.iloc[:,[0]] . att . 202212380 65 | . 202212370 95 | . 202212363 65 | . 202212488 55 | . 202212312 80 | . 202212377 75 | . 202212463 65 | . 202212471 60 | . 202212400 95 | . 202212469 90 | . 202212318 55 | . 202212432 95 | . 202212443 95 | . 202212367 50 | . 202212458 50 | . 202212396 95 | . 202212482 50 | . 202212452 65 | . 202212387 70 | . 202212354 90 | . df.iloc[:,0]은 series를 리턴하고 df.iloc[:,[0]]은 dataframe을 리턴한다. | . - 방법6: ndarray 스타일과 dict 스타일의 혼합 . df.loc[:,&#39;att&#39;] . 202212380 65 202212370 95 202212363 65 202212488 55 202212312 80 202212377 75 202212463 65 202212471 60 202212400 95 202212469 90 202212318 55 202212432 95 202212443 95 202212367 50 202212458 50 202212396 95 202212482 50 202212452 65 202212387 70 202212354 90 Name: att, dtype: int64 . - 방법7: ndarray 스타일과 dict 스타일의 혼합 . df.loc[:,[&#39;att&#39;]] . att . 202212380 65 | . 202212370 95 | . 202212363 65 | . 202212488 55 | . 202212312 80 | . 202212377 75 | . 202212463 65 | . 202212471 60 | . 202212400 95 | . 202212469 90 | . 202212318 55 | . 202212432 95 | . 202212443 95 | . 202212367 50 | . 202212458 50 | . 202212396 95 | . 202212482 50 | . 202212452 65 | . 202212387 70 | . 202212354 90 | . df.loc[:,&#39;att&#39;]은 series를 리턴하고 df.loc[:,[&#39;att&#39;]]은 dataframe을 리턴한다. | . - 방법7: nparray 스타일 + bool 인덱싱 . df.iloc[:,[True,False,False,False]] . att . 202212380 65 | . 202212370 95 | . 202212363 65 | . 202212488 55 | . 202212312 80 | . 202212377 75 | . 202212463 65 | . 202212471 60 | . 202212400 95 | . 202212469 90 | . 202212318 55 | . 202212432 95 | . 202212443 95 | . 202212367 50 | . 202212458 50 | . 202212396 95 | . 202212482 50 | . 202212452 65 | . 202212387 70 | . 202212354 90 | . - 방법8: ndarray와 dict의 홉합형 + bool 인덱싱 . df.loc[:,[True,False,False,False]] . att . 202212380 65 | . 202212370 95 | . 202212363 65 | . 202212488 55 | . 202212312 80 | . 202212377 75 | . 202212463 65 | . 202212471 60 | . 202212400 95 | . 202212469 90 | . 202212318 55 | . 202212432 95 | . 202212443 95 | . 202212367 50 | . 202212458 50 | . 202212396 95 | . 202212482 50 | . 202212452 65 | . 202212387 70 | . 202212354 90 | . &#50668;&#47084;&#44060;&#51032; &#52860;&#47100;&#51012; &#49440;&#53469; . - 방법1: dict 스타일 . df[[&#39;att&#39;,&#39;fin&#39;]] . att fin . 202212380 65 | 40 | . 202212370 95 | 80 | . 202212363 65 | 30 | . 202212488 55 | 80 | . 202212312 80 | 100 | . 202212377 75 | 15 | . 202212463 65 | 90 | . 202212471 60 | 0 | . 202212400 95 | 10 | . 202212469 90 | 20 | . 202212318 55 | 25 | . 202212432 95 | 0 | . 202212443 95 | 35 | . 202212367 50 | 30 | . 202212458 50 | 85 | . 202212396 95 | 95 | . 202212482 50 | 10 | . 202212452 65 | 45 | . 202212387 70 | 35 | . 202212354 90 | 90 | . - 방법2: ndarray 스타일 (정수리스트로 인덱싱, 슬라이싱, 스트라이딩) . df.iloc[:,[0,1]] # 정수의 리스트를 전달하여 컬럼추출 . att rep . 202212380 65 | 55 | . 202212370 95 | 100 | . 202212363 65 | 90 | . 202212488 55 | 80 | . 202212312 80 | 30 | . 202212377 75 | 40 | . 202212463 65 | 45 | . 202212471 60 | 60 | . 202212400 95 | 65 | . 202212469 90 | 80 | . 202212318 55 | 75 | . 202212432 95 | 95 | . 202212443 95 | 55 | . 202212367 50 | 80 | . 202212458 50 | 55 | . 202212396 95 | 30 | . 202212482 50 | 50 | . 202212452 65 | 55 | . 202212387 70 | 70 | . 202212354 90 | 90 | . df.iloc[:,range(2)] . att rep . 202212380 65 | 55 | . 202212370 95 | 100 | . 202212363 65 | 90 | . 202212488 55 | 80 | . 202212312 80 | 30 | . 202212377 75 | 40 | . 202212463 65 | 45 | . 202212471 60 | 60 | . 202212400 95 | 65 | . 202212469 90 | 80 | . 202212318 55 | 75 | . 202212432 95 | 95 | . 202212443 95 | 55 | . 202212367 50 | 80 | . 202212458 50 | 55 | . 202212396 95 | 30 | . 202212482 50 | 50 | . 202212452 65 | 55 | . 202212387 70 | 70 | . 202212354 90 | 90 | . df.iloc[:,:2] # 슬라이싱 , 0,1,2에서 마지막 2는 제외되고 0,1에 해당하는 것만 추출 . att rep . 202212380 65 | 55 | . 202212370 95 | 100 | . 202212363 65 | 90 | . 202212488 55 | 80 | . 202212312 80 | 30 | . 202212377 75 | 40 | . 202212463 65 | 45 | . 202212471 60 | 60 | . 202212400 95 | 65 | . 202212469 90 | 80 | . 202212318 55 | 75 | . 202212432 95 | 95 | . 202212443 95 | 55 | . 202212367 50 | 80 | . 202212458 50 | 55 | . 202212396 95 | 30 | . 202212482 50 | 50 | . 202212452 65 | 55 | . 202212387 70 | 70 | . 202212354 90 | 90 | . df.iloc[:,::2] # 스트라이딩 . att mid . 202212380 65 | 50 | . 202212370 95 | 50 | . 202212363 65 | 60 | . 202212488 55 | 75 | . 202212312 80 | 30 | . 202212377 75 | 100 | . 202212463 65 | 45 | . 202212471 60 | 25 | . 202212400 95 | 20 | . 202212469 90 | 80 | . 202212318 55 | 35 | . 202212432 95 | 45 | . 202212443 95 | 15 | . 202212367 50 | 40 | . 202212458 50 | 15 | . 202212396 95 | 30 | . 202212482 50 | 45 | . 202212452 65 | 15 | . 202212387 70 | 40 | . 202212354 90 | 80 | . - 방법3: ndarray 와 dict의 혼합형 . df.loc[:,[&#39;att&#39;,&#39;mid&#39;]] . att mid . 202212380 65 | 50 | . 202212370 95 | 50 | . 202212363 65 | 60 | . 202212488 55 | 75 | . 202212312 80 | 30 | . 202212377 75 | 100 | . 202212463 65 | 45 | . 202212471 60 | 25 | . 202212400 95 | 20 | . 202212469 90 | 80 | . 202212318 55 | 35 | . 202212432 95 | 45 | . 202212443 95 | 15 | . 202212367 50 | 40 | . 202212458 50 | 15 | . 202212396 95 | 30 | . 202212482 50 | 45 | . 202212452 65 | 15 | . 202212387 70 | 40 | . 202212354 90 | 80 | . df.loc[:,&#39;att&#39;:&#39;mid&#39;] # 마지막의 mid도 포함된다. . att rep mid . 202212380 65 | 55 | 50 | . 202212370 95 | 100 | 50 | . 202212363 65 | 90 | 60 | . 202212488 55 | 80 | 75 | . 202212312 80 | 30 | 30 | . 202212377 75 | 40 | 100 | . 202212463 65 | 45 | 45 | . 202212471 60 | 60 | 25 | . 202212400 95 | 65 | 20 | . 202212469 90 | 80 | 80 | . 202212318 55 | 75 | 35 | . 202212432 95 | 95 | 45 | . 202212443 95 | 55 | 15 | . 202212367 50 | 80 | 40 | . 202212458 50 | 55 | 15 | . 202212396 95 | 30 | 30 | . 202212482 50 | 50 | 45 | . 202212452 65 | 55 | 15 | . 202212387 70 | 70 | 40 | . 202212354 90 | 90 | 80 | . df.loc[:,&#39;rep&#39;:] . rep mid fin . 202212380 55 | 50 | 40 | . 202212370 100 | 50 | 80 | . 202212363 90 | 60 | 30 | . 202212488 80 | 75 | 80 | . 202212312 30 | 30 | 100 | . 202212377 40 | 100 | 15 | . 202212463 45 | 45 | 90 | . 202212471 60 | 25 | 0 | . 202212400 65 | 20 | 10 | . 202212469 80 | 80 | 20 | . 202212318 75 | 35 | 25 | . 202212432 95 | 45 | 0 | . 202212443 55 | 15 | 35 | . 202212367 80 | 40 | 30 | . 202212458 55 | 15 | 85 | . 202212396 30 | 30 | 95 | . 202212482 50 | 45 | 10 | . 202212452 55 | 15 | 45 | . 202212387 70 | 40 | 35 | . 202212354 90 | 80 | 90 | . - 방법4: bool을 이용한 인덱싱 . df.iloc[:,[True,False,True,False]] . att mid . 202212380 65 | 50 | . 202212370 95 | 50 | . 202212363 65 | 60 | . 202212488 55 | 75 | . 202212312 80 | 30 | . 202212377 75 | 100 | . 202212463 65 | 45 | . 202212471 60 | 25 | . 202212400 95 | 20 | . 202212469 90 | 80 | . 202212318 55 | 35 | . 202212432 95 | 45 | . 202212443 95 | 15 | . 202212367 50 | 40 | . 202212458 50 | 15 | . 202212396 95 | 30 | . 202212482 50 | 45 | . 202212452 65 | 15 | . 202212387 70 | 40 | . 202212354 90 | 80 | . df.loc[:,[True,False,True,False]] . att mid . 202212380 65 | 50 | . 202212370 95 | 50 | . 202212363 65 | 60 | . 202212488 55 | 75 | . 202212312 80 | 30 | . 202212377 75 | 100 | . 202212463 65 | 45 | . 202212471 60 | 25 | . 202212400 95 | 20 | . 202212469 90 | 80 | . 202212318 55 | 35 | . 202212432 95 | 45 | . 202212443 95 | 15 | . 202212367 50 | 40 | . 202212458 50 | 15 | . 202212396 95 | 30 | . 202212482 50 | 45 | . 202212452 65 | 15 | . 202212387 70 | 40 | . 202212354 90 | 80 | . &#52395;&#48264;&#51704; &#54665;&#51012; &#49440;&#53469; . - 방법1 . df.iloc[0] . att 65 rep 55 mid 50 fin 40 Name: 202212380, dtype: int64 . - 방법2 . df.iloc[[0]] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . - 방법3 . df.iloc[0,:] . att 65 rep 55 mid 50 fin 40 Name: 202212380, dtype: int64 . - 방법4 . df.iloc[[0],:] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . - 방법5 . df.loc[&#39;202212380&#39;] . att 65 rep 55 mid 50 fin 40 Name: 202212380, dtype: int64 . - 방법6 . df.loc[[&#39;202212380&#39;]] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . - 방법7 . df.loc[&#39;202212380&#39;,:] . att 65 rep 55 mid 50 fin 40 Name: 202212380, dtype: int64 . - 방법8 . df.loc[[&#39;202212380&#39;],:] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . - 방법9 . len(df) . 20 . _lst = [True]+[False]*19 . df.iloc[_lst] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . df.iloc[_lst,:] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . df.loc[_lst] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . df.loc[_lst,:] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . &#50668;&#47084;&#44060;&#51032; &#54665;&#51012; &#49440;&#53469; . - 방법1 . df.iloc[[0,2]] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212363 65 | 90 | 60 | 30 | . df.iloc[[0,2],:] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212363 65 | 90 | 60 | 30 | . - 방법2 . df.loc[[&#39;202212380&#39;,&#39;202212363&#39;]] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212363 65 | 90 | 60 | 30 | . df.loc[[&#39;202212380&#39;,&#39;202212363&#39;],:] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212363 65 | 90 | 60 | 30 | . - 그 밖의 방법들 . df.iloc[::3] # 스트라이딩 . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212488 55 | 80 | 75 | 80 | . 202212463 65 | 45 | 45 | 90 | . 202212469 90 | 80 | 80 | 20 | . 202212443 95 | 55 | 15 | 35 | . 202212396 95 | 30 | 30 | 95 | . 202212387 70 | 70 | 40 | 35 | . df.iloc[:5] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212370 95 | 100 | 50 | 80 | . 202212363 65 | 90 | 60 | 30 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . df.loc[:&#39;202212312&#39;] . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212370 95 | 100 | 50 | 80 | . 202212363 65 | 90 | 60 | 30 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . df.loc[list(df.att&lt;80),&#39;rep&#39;:] . rep mid fin . 202212380 55 | 50 | 40 | . 202212363 90 | 60 | 30 | . 202212488 80 | 75 | 80 | . 202212377 40 | 100 | 15 | . 202212463 45 | 45 | 90 | . 202212471 60 | 25 | 0 | . 202212318 75 | 35 | 25 | . 202212367 80 | 40 | 30 | . 202212458 55 | 15 | 85 | . 202212482 50 | 45 | 10 | . 202212452 55 | 15 | 45 | . 202212387 70 | 40 | 35 | . df.loc[df.att&lt;80,&#39;rep&#39;:] . rep mid fin . 202212380 55 | 50 | 40 | . 202212363 90 | 60 | 30 | . 202212488 80 | 75 | 80 | . 202212377 40 | 100 | 15 | . 202212463 45 | 45 | 90 | . 202212471 60 | 25 | 0 | . 202212318 75 | 35 | 25 | . 202212367 80 | 40 | 30 | . 202212458 55 | 15 | 85 | . 202212482 50 | 45 | 10 | . 202212452 55 | 15 | 45 | . 202212387 70 | 40 | 35 | . df.iloc[list(df.att&lt;80),1:] . rep mid fin . 202212380 55 | 50 | 40 | . 202212363 90 | 60 | 30 | . 202212488 80 | 75 | 80 | . 202212377 40 | 100 | 15 | . 202212463 45 | 45 | 90 | . 202212471 60 | 25 | 0 | . 202212318 75 | 35 | 25 | . 202212367 80 | 40 | 30 | . 202212458 55 | 15 | 85 | . 202212482 50 | 45 | 10 | . 202212452 55 | 15 | 45 | . 202212387 70 | 40 | 35 | . - 아래는 에러가 난다 주의! . df.iloc[df.att&lt;80,1:] . ValueError Traceback (most recent call last) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/indexing.py:769, in _LocationIndexer._validate_tuple_indexer(self, key) 768 try: --&gt; 769 self._validate_key(k, i) 770 except ValueError as err: File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/indexing.py:1352, in _iLocIndexer._validate_key(self, key, axis) 1347 raise NotImplementedError( 1348 &#34;iLocation based boolean &#34; 1349 &#34;indexing on an integer type &#34; 1350 &#34;is not available&#34; 1351 ) -&gt; 1352 raise ValueError( 1353 &#34;iLocation based boolean indexing cannot use &#34; 1354 &#34;an indexable as a mask&#34; 1355 ) 1356 return ValueError: iLocation based boolean indexing cannot use an indexable as a mask The above exception was the direct cause of the following exception: ValueError Traceback (most recent call last) Input In [383], in &lt;cell line: 1&gt;() -&gt; 1 df.iloc[df.att&lt;80,1:] File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/indexing.py:961, in _LocationIndexer.__getitem__(self, key) 959 if self._is_scalar_access(key): 960 return self.obj._get_value(*key, takeable=self._takeable) --&gt; 961 return self._getitem_tuple(key) 962 else: 963 # we by definition only have the 0th axis 964 axis = self.axis or 0 File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/indexing.py:1458, in _iLocIndexer._getitem_tuple(self, tup) 1456 def _getitem_tuple(self, tup: tuple): -&gt; 1458 tup = self._validate_tuple_indexer(tup) 1459 with suppress(IndexingError): 1460 return self._getitem_lowerdim(tup) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/indexing.py:771, in _LocationIndexer._validate_tuple_indexer(self, key) 769 self._validate_key(k, i) 770 except ValueError as err: --&gt; 771 raise ValueError( 772 &#34;Location based indexing can only have &#34; 773 f&#34;[{self._valid_types}] types&#34; 774 ) from err 775 return key ValueError: Location based indexing can only have [integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array] types . query ($ star$) . - 예제1 . df.query(&#39;att==90 and mid&gt;30&#39;) . att rep mid fin . 202212469 90 | 80 | 80 | 20 | . 202212354 90 | 90 | 80 | 90 | . - 예제2 . df.query(&#39;att&lt;rep and mid&lt;fin&#39;) . att rep mid fin . 202212370 95 | 100 | 50 | 80 | . 202212488 55 | 80 | 75 | 80 | . 202212458 50 | 55 | 15 | 85 | . - 예제3 . df.query(&#39;att &lt; rep &lt; 80&#39;) . att rep mid fin . 202212318 55 | 75 | 35 | 25 | . 202212458 50 | 55 | 15 | 85 | . - 예제4 . df.query(&#39;50 &lt; att &lt;= 90 and mid &lt; fin&#39;) . att rep mid fin . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212463 65 | 45 | 45 | 90 | . 202212452 65 | 55 | 15 | 45 | . 202212354 90 | 90 | 80 | 90 | . - 예제5 . df.query(&#39; (mid+fin)/2 &gt;=60&#39;) . att rep mid fin . 202212370 95 | 100 | 50 | 80 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212463 65 | 45 | 45 | 90 | . 202212396 95 | 30 | 30 | 95 | . 202212354 90 | 90 | 80 | 90 | . - 예제6 . _mean = df.att.mean() _mean . 73.0 . df.query(&#39;att &gt;= 73&#39;) . att rep mid fin . 202212370 95 | 100 | 50 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212377 75 | 40 | 100 | 15 | . 202212400 95 | 65 | 20 | 10 | . 202212469 90 | 80 | 80 | 20 | . 202212432 95 | 95 | 45 | 0 | . 202212443 95 | 55 | 15 | 35 | . 202212396 95 | 30 | 30 | 95 | . 202212354 90 | 90 | 80 | 90 | . df.query(&#39;att &gt;= @_mean&#39;) # df.query(&#39;att&gt;= _mean&#39;)은 실행 안된다. . att rep mid fin . 202212370 95 | 100 | 50 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212377 75 | 40 | 100 | 15 | . 202212400 95 | 65 | 20 | 10 | . 202212469 90 | 80 | 80 | 20 | . 202212432 95 | 95 | 45 | 0 | . 202212443 95 | 55 | 15 | 35 | . 202212396 95 | 30 | 30 | 95 | . 202212354 90 | 90 | 80 | 90 | . - 예제7 . df . att rep mid fin . 202212380 65 | 55 | 50 | 40 | . 202212370 95 | 100 | 50 | 80 | . 202212363 65 | 90 | 60 | 30 | . 202212488 55 | 80 | 75 | 80 | . 202212312 80 | 30 | 30 | 100 | . 202212377 75 | 40 | 100 | 15 | . 202212463 65 | 45 | 45 | 90 | . 202212471 60 | 60 | 25 | 0 | . 202212400 95 | 65 | 20 | 10 | . 202212469 90 | 80 | 80 | 20 | . 202212318 55 | 75 | 35 | 25 | . 202212432 95 | 95 | 45 | 0 | . 202212443 95 | 55 | 15 | 35 | . 202212367 50 | 80 | 40 | 30 | . 202212458 50 | 55 | 15 | 85 | . 202212396 95 | 30 | 30 | 95 | . 202212482 50 | 50 | 45 | 10 | . 202212452 65 | 55 | 15 | 45 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . df.query(&quot;index &lt;= &#39;202212354&#39; or index==&#39;202212387&#39;&quot;) . att rep mid fin . 202212312 80 | 30 | 30 | 100 | . 202212318 55 | 75 | 35 | 25 | . 202212387 70 | 70 | 40 | 35 | . 202212354 90 | 90 | 80 | 90 | . 사실 이 기능은 시계열자료에서 꽃핀다. . - 예제8 . pd.date_range(&#39;20211226&#39;,periods=10) . DatetimeIndex([&#39;2021-12-26&#39;, &#39;2021-12-27&#39;, &#39;2021-12-28&#39;, &#39;2021-12-29&#39;, &#39;2021-12-30&#39;, &#39;2021-12-31&#39;, &#39;2022-01-01&#39;, &#39;2022-01-02&#39;, &#39;2022-01-03&#39;, &#39;2022-01-04&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;) . _df=pd.DataFrame(np.random.normal(size=(10,4)),columns=list(&#39;ABCD&#39;),index=pd.date_range(&#39;20211226&#39;,periods=10)) _df . A B C D . 2021-12-26 -0.367399 | 0.925727 | -0.378494 | -1.597765 | . 2021-12-27 -0.016530 | 1.041946 | 1.511319 | -0.970646 | . 2021-12-28 -1.556636 | 1.629024 | -0.965807 | 0.309184 | . 2021-12-29 0.554734 | 0.712753 | 0.769650 | 0.277420 | . 2021-12-30 -0.897457 | 0.110547 | 1.026816 | 0.294377 | . 2021-12-31 0.904037 | -0.809864 | 0.473510 | -0.047875 | . 2022-01-01 -0.850946 | -0.915568 | -1.549329 | -0.040507 | . 2022-01-02 0.054391 | -0.732693 | 0.409205 | -1.165549 | . 2022-01-03 0.053472 | 0.800553 | -0.040499 | -0.447199 | . 2022-01-04 -0.304462 | 1.257485 | 0.888741 | 0.615561 | . _df.query(&quot; &#39;2021-12-29&#39; &lt;= index &lt;= &#39;2022-01-03&#39; &quot;) . A B C D . 2021-12-29 0.554734 | 0.712753 | 0.769650 | 0.277420 | . 2021-12-30 -0.897457 | 0.110547 | 1.026816 | 0.294377 | . 2021-12-31 0.904037 | -0.809864 | 0.473510 | -0.047875 | . 2022-01-01 -0.850946 | -0.915568 | -1.549329 | -0.040507 | . 2022-01-02 0.054391 | -0.732693 | 0.409205 | -1.165549 | . 2022-01-03 0.053472 | 0.800553 | -0.040499 | -0.447199 | . _df.query(&quot; &#39;2021-12-29&#39; &lt;= index &lt;= &#39;2022-01-03&#39; and A+B&lt;C &quot;) . A B C D . 2021-12-30 -0.897457 | 0.110547 | 1.026816 | 0.294377 | . 2021-12-31 0.904037 | -0.809864 | 0.473510 | -0.047875 | . 2022-01-01 -0.850946 | -0.915568 | -1.549329 | -0.040507 | . 2022-01-02 0.054391 | -0.732693 | 0.409205 | -1.165549 | . - query가 만능은 아니다. . df.columns = pd.Index([&#39;att score&#39;, &#39;rep score&#39;, &#39;mid score&#39;, &#39;fin score&#39;]) . df.query(&quot; att score &lt; 90 &quot;) # df.loc[df[&#39;att score&#39;] &lt; 90,:] &lt;-- 이렇게 구현하면 된다! (아니면 변수이름을 바꿔주는 코드를 짜든가) . Traceback (most recent call last): File ~/anaconda3/envs/py39/lib/python3.9/site-packages/IPython/core/interactiveshell.py:3361 in run_code exec(code_obj, self.user_global_ns, self.user_ns) Input In [455] in &lt;cell line: 1&gt; df.query(&#34; att score &lt; 90 &#34;) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/frame.py:4105 in query res = self.eval(expr, **kwargs) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/frame.py:4234 in eval return _eval(expr, inplace=inplace, **kwargs) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/computation/eval.py:350 in eval parsed_expr = Expr(expr, engine=engine, parser=parser, env=env) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/computation/expr.py:811 in __init__ self.terms = self.parse() File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/computation/expr.py:830 in parse return self._visitor.visit(self.expr) File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/computation/expr.py:411 in visit raise e File ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/core/computation/expr.py:407 in visit node = ast.fix_missing_locations(ast.parse(clean)) File ~/anaconda3/envs/py39/lib/python3.9/ast.py:50 in parse return compile(source, filename, mode, flags, File &lt;unknown&gt;:1 att score &lt;90 ^ SyntaxError: invalid syntax . pandas &#44277;&#48512; 3&#45800;&#44228; . &#51204;&#52824; . ndarray = np.arange(2*3).reshape(2,3) df = pd.DataFrame(ndarray) df . 0 1 2 . 0 0 | 1 | 2 | . 1 3 | 4 | 5 | . ndarray.T . array([[0, 3], [1, 4], [2, 5]]) . df.T . 0 1 . 0 0 | 3 | . 1 1 | 4 | . 2 2 | 5 | . &#54633; . ndarray.sum(axis=0) . array([3, 5, 7]) . df.sum(axis=0) . 0 3 1 5 2 7 dtype: int64 . ndarray.sum(axis=1) . array([ 3, 12]) . df.sum(axis=1) . 0 3 1 12 dtype: int64 . cumsum . df . 0 1 2 . 0 0 | 1 | 2 | . 1 3 | 4 | 5 | . ndarray.cumsum(axis=0) . array([[0, 1, 2], [3, 5, 7]]) . df.cumsum(axis=0) . 0 1 2 . 0 0 | 1 | 2 | . 1 3 | 5 | 7 | . ndarray.cumsum(axis=1) . array([[ 0, 1, 3], [ 3, 7, 12]]) . df.cumsum(axis=1) . 0 1 2 . 0 0 | 1 | 3 | . 1 3 | 7 | 12 | . &#54805;&#53468;&#48320;&#54872; . ndarray.tolist() . [[0, 1, 2], [3, 4, 5]] . df.to_dict() . {0: {0: 0, 1: 3}, 1: {0: 1, 1: 4}, 2: {0: 2, 1: 5}} . df.to_numpy() . array([[0, 1, 2], [3, 4, 5]]) . df.to_numpy().tolist() . [[0, 1, 2], [3, 4, 5]] . &#49373;&#47029;... . pandas &#44277;&#48512; 4&#45800;&#44228;~ . 생략 . &#49689;&#51228; . - 아래의 데이터프레임에서 1,3번째 열을 추출하라. . df= pd.DataFrame({&#39;att&#39;:[90,90,95],&#39;rep&#39;:[80,90,90],&#39;mid&#39;:[50,60,70], &#39;fin&#39;:[70,80,50]}) df . att rep mid fin . 0 90 | 80 | 50 | 70 | . 1 90 | 90 | 60 | 80 | . 2 95 | 90 | 70 | 50 | .",
            "url": "https://guebin.github.io/IP2022/2022/05/04/(10%EC%A3%BC%EC%B0%A8)-5%EC%9B%946%EC%9D%BC.html",
            "relUrl": "/2022/05/04/(10%EC%A3%BC%EC%B0%A8)-5%EC%9B%946%EC%9D%BC.html",
            "date": " • May 4, 2022"
        }
        
    
  
    
        ,"post12": {
            "title": "2022년 파이썬 입문 중간고사 해설",
            "content": ". 0. imports . 아래코드를 이용하여 numpy 와 matplotlib을 import하라. . import numpy as np import matplotlib.pyplot as plt . 1. &#53076;&#46300;&#44396;&#54788; I (40&#51216;) . 주의: 문제에 조건이 있는 경우 조건을 준수할 것 . (1) a의 type을 bool로 바꾸어라. . a=1.0 . (풀이) . bool(a) . True . . Note: 출제의도: 자료형의 변환 . . (2)-(6) . 아래의 문자열을 고려하자. . test_arr = &#39;ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local&#39; . (2) 위 문자열에서 짝수번째 원소를 출력하는 코드를 작성하라. . (풀이) . test_arr[1::2] . &#39;s-s AA3zCy2AABwAQAlUkHfY7bmINTKTo/WSGlnflDY7d4Ze1J4WjhFvQMxEEfhlXQkPpw0d3b7OJMylXC+A3XiBxXnhpAscL86jNQddFSV/XtFoosc19530w8eFbzUlQKrX8yNvYb6wP0wr/nZA4ZnP8ZmMuyDc8Zi8+wr+namkns10QalqSbNRiwfMQ=shcnmlpo.oa&#39; . . Note: 출제의도: 인덱싱, 스트라이딩 . (3) 위 문자열에서 마지막 10개의 원소를 출력하는 코드를 작성하라. . (풀이) . test_arr[-10:] . &#39;ptop.local&#39; . . Note: 출제의도: -인덱싱 . (4) 위 문자열을 뒤집은 문자열을 구하는 코드를 작성하라. 즉 아래를 출력하는 코드를 작성하라. . &#39;lacol.potpalym@nocahcs ==Q7M+frw9iFRrNxbsSVqMlTarQ10d1os2njkImtaKn1+3r3wg+b8li/Z68Ec2DryauLMVmPZ98IPTnPZO4WA+ZmnE/trewr0bP/wv6ybNYjvDNpyX88XrrpKJQjlFUuz1bmFIe/86wW0V3+5x9Q1McnsAoJoaF3tAX7/KVlSvFMdsdwQANsjR6V8qLicMsZAHpXhKn1XixqBtiRXF3oAH+RCFXWlByTM/JdOk7vbP3adc0gwSppPbkVQ5XFl9h4fVELElx7MzQivrFUhbj9WJ4HJ81we5Zy4Idh7WYTDHlzfan+lPGUSDWB/mojT9KGTLNpITmrbS71YHfrHDkpUOlkAEQAAAwIBAAAAE2cy1CazN3BAAAA asr-hss&#39; . (풀이) . test_arr[::-1] . &#39;lacol.potpalym@nocahcs ==Q7M+frw9iFRrNxbsSVqMlTarQ10d1os2njkImtaKn1+3r3wg+b8li/Z68Ec2DryauLMVmPZ98IPTnPZO4WA+ZmnE/trewr0bP/wv6ybNYjvDNpyX88XrrpKJQjlFUuz1bmFIe/86wW0V3+5x9Q1McnsAoJoaF3tAX7/KVlSvFMdsdwQANsjR6V8qLicMsZAHpXhKn1XixqBtiRXF3oAH+RCFXWlByTM/JdOk7vbP3adc0gwSppPbkVQ5XFl9h4fVELElx7MzQivrFUhbj9WJ4HJ81we5Zy4Idh7WYTDHlzfan+lPGUSDWB/mojT9KGTLNpITmrbS71YHfrHDkpUOlkAEQAAAwIBAAAAE2cy1CazN3BAAAA asr-hss&#39; . . Note: 출제의도: -1 스트라이딩 . (5) 위 문자열에서 대문자의 수를 count하라. . (풀이) . sum([s.isupper() for s in test_arr]) . 155 . . Note: 출제의도: 리스트컴프리헨션, bool자료형의 sum . hint .isupper() 메소드를 이용할 것. . &#39;a&#39;.isupper() . False . &#39;A&#39;.isupper() . True . &#39;=&#39;.isupper() . False . &#39;@&#39;.isupper() . False . (6) 위 문자열에서 사용된 문자 및 특수문자의 종류는 모두 몇가지 인가? . (풀이) . len(set(test_arr)) . 69 . . Note: 출제의도: set 자료형의 이해 . note1: 문자열 &#39;AAB @ab&#39; 에서 사용된 문자는 &#39;A&#39;, &#39;B&#39;, &#39; &#39;, &#39;@&#39;, &#39;a&#39;, &#39;b&#39; 이므로 모두 6종류의 문자 및 특수문자가 사용되었다. . note2: &#39; &#39;, &#39;+&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;, &#39;=&#39;, &#39;@&#39;, &#39;1&#39;, &#39;a&#39;, &#39;A&#39; 등을 모두 다른 문자로 취급한다. . . (7) 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 생성하라 . [&#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;, &#39;aaaa&#39;, &#39;aaaaa&#39;, &#39;aaaaaa&#39;, &#39;aaaaaaa&#39;, &#39;aaaaaaaa&#39;, &#39;aaaaaaaaa&#39;, &#39;aaaaaaaaaa&#39;] &lt;- a가 10개있음 . (풀이) . [&#39;a&#39;*i for i in range(1,11)] . [&#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;, &#39;aaaa&#39;, &#39;aaaaa&#39;, &#39;aaaaaa&#39;, &#39;aaaaaaa&#39;, &#39;aaaaaaaa&#39;, &#39;aaaaaaaaa&#39;, &#39;aaaaaaaaaa&#39;] . . Note: 출제의도: 문자열의 * 연산, 리스트컴프리헨션 . (8) 길이가 1인 튜플을 만들어 자신의 학번을 저장하라. 길이가 1인 튜플을 만들어 자신의 영문이름을 저장하라. 두 튜플을 + 연산자로 합쳐아래와 같은 출력결과를 얻어라. . (202143052,&#39;guebin&#39;) . (풀이) . a=(202143052,) b=(&#39;guebin&#39;,) a+b . (202143052, &#39;guebin&#39;) . . Note: 출제의도: 튜플의 + 연산, 길이가 1인 튜플 . (9) 아래와 같은 list가 있다고 하자. . test_lst = [[&#39;g&#39;,1],[&#39;u&#39;,5],[&#39;e&#39;,2],[&#39;b&#39;,8],[&#39;i&#39;,2],[&#39;n&#39;,9]] . test_lst와 리스트컴프리헨션을 이용하여 아래를 출력하는 코드를 구현하라. . [&#39;g&#39;, &#39;uuuuu&#39;, &#39;ee&#39;, &#39;bbbbbbbb&#39;, &#39;ii&#39;, &#39;nnnnnnnnn&#39;] . (풀이) . test_lst = [[&#39;g&#39;,1],[&#39;u&#39;,5],[&#39;e&#39;,2],[&#39;b&#39;,8],[&#39;i&#39;,2],[&#39;n&#39;,9]] [i*j for i,j in test_lst] . [&#39;g&#39;, &#39;uuuuu&#39;, &#39;ee&#39;, &#39;bbbbbbbb&#39;, &#39;ii&#39;, &#39;nnnnnnnnn&#39;] . . Note: 출제의도: 스트링의 + 연산, 리스트 컴프리헨션 . (10) 다음은 학생들의 출석,레포트,중간고사,기말고사 점수를 입력으로 하여 학점을 계산하는 함수이다. . def grade(attendance, report, mid, final): if attendance&lt;70: credit = &#39;F&#39; else: total_score = attendance * 0.1 + report * 0.2 + mid * 0.3 + final * 0.4 if total_score &gt; 80: credit = &#39;A+&#39; else: credit = &#39;B0&#39; return credit . 아래는 학생들의 학번, 출석점수, 레포트, 중간고사, 기말고사 점수가 입력된 리스트이다. . data = [[&#39;202212345&#39;, [100,95,25,90]], [&#39;202212346&#39;, [60,90,95,95]], [&#39;202212347&#39;, [50,90,45,35]], [&#39;202212348&#39;, [90,90,50,75]], [&#39;202212349&#39;, [100,95,85,85]], [&#39;202212350&#39;, [90,90,100,95]], [&#39;202212351&#39;, [100,95,100,95]], [&#39;202212352&#39;, [95,85,80,60]], [&#39;202212353&#39;, [100,90,60,55]], [&#39;202212354&#39;, [100,85,70,95]], [&#39;202212355&#39;, [100,95,40,100]]] . 아래의 ???를 적절하게 완성하여 학생들의 학점을 계산하는 코드를 완성하라. . [grade(???) for _, scores in data] . (풀이) . [grade(*scores) for _, scores in data] . [&#39;B0&#39;, &#39;F&#39;, &#39;F&#39;, &#39;B0&#39;, &#39;A+&#39;, &#39;A+&#39;, &#39;A+&#39;, &#39;B0&#39;, &#39;B0&#39;, &#39;A+&#39;, &#39;A+&#39;] . . Note: 출제의도: dummy variable _, 언패킹연산자 *, for문과 튜플언패킹, 리스트컴프리헨션 . (11) 길이가 0인 문자열을 선언하라. . (풀이) . len(&#39;&#39;) . 0 . . Note: 출제의도: 길이가 0인 문자열 . . (12)-(15) . (12) dir(plt)와 dir(np)를 각각 실행하라. 실행결과를 각각 a,b로 저장하라. a,b의 type은 무엇인가? . (풀이) . a=dir(plt) b=dir(np) type(a),type(b) . (list, list) . . Note: 출제의도: tpye사용법 . (13) a의 원소와 b의 원소의 수를 각각 구하라. . (풀이) . len(a),len(b) . (254, 611) . . Note: 출제의도: len의 사용법 및 응용 . (14) a와 b의 공통원소의 수를 구하라. . (풀이) . len(set(a)&amp;set(b)) . 9 . . Note: 출제의도: set에서 &amp; 연산자 이용 . (15) a와 b의 원소를 합친 리스트를 만들어라. (공통원소는 중복하여 합치지 않는다) . (풀이) . lst = list(set(a)|set(b)) . . Note: 출제의도: set에서 | 연산자 이용 . . (16)-(18) 아래와 같은 dictionary가 있다. . test_dic = {&#39;202212345&#39;: {&#39;att&#39;:100,&#39;rep&#39;:95,&#39;mid&#39;:25,&#39;fin&#39;:90}, &#39;202212346&#39;: {&#39;att&#39;:60,&#39;rep&#39;:90,&#39;mid&#39;:95,&#39;fin&#39;:95}, &#39;202212347&#39;: {&#39;att&#39;:50,&#39;rep&#39;:90,&#39;mid&#39;:45,&#39;fin&#39;:35}, &#39;202212348&#39;: {&#39;att&#39;:90,&#39;rep&#39;:90,&#39;mid&#39;:50,&#39;fin&#39;:75}, &#39;202212349&#39;: {&#39;att&#39;:100,&#39;rep&#39;:95,&#39;mid&#39;:85,&#39;fin&#39;:85}, &#39;202212350&#39;: {&#39;att&#39;:90,&#39;rep&#39;:90,&#39;mid&#39;:100,&#39;fin&#39;:95}, &#39;202212351&#39;: {&#39;att&#39;:100,&#39;rep&#39;:95,&#39;mid&#39;:100,&#39;fin&#39;:95}, &#39;202212352&#39;: {&#39;att&#39;:95,&#39;rep&#39;:85,&#39;mid&#39;:80,&#39;fin&#39;:60}, &#39;202212353&#39;: {&#39;att&#39;:100,&#39;rep&#39;:90,&#39;mid&#39;:60,&#39;fin&#39;:55}, &#39;202212354&#39;: {&#39;att&#39;:100,&#39;rep&#39;:85,&#39;mid&#39;:70,&#39;fin&#39;:95}, &#39;202212355&#39;: {&#39;att&#39;:100,&#39;rep&#39;:95,&#39;mid&#39;:40,&#39;fin&#39;:100}} . 여기에서 202212345등은 학번을, att는 출석점수, rep는 레포트점수, mid는 중간고사점수, fin은 기말고사 점수를 의미한다. . (16) get 메소드를 이용하여 202212353에 해당하는 학생의 성적을 아래와 같이 리턴하라. . {&#39;att&#39;: 100, &#39;rep&#39;: 90, &#39;mid&#39;: 60, &#39;fin&#39;: 55} . (풀이) . test_dic.get(&#39;202212353&#39;) . {&#39;att&#39;: 100, &#39;rep&#39;: 90, &#39;mid&#39;: 60, &#39;fin&#39;: 55} . . Note: 출제의도: 딕셔너리에서 get 메소드 이용 . (17) 202212354의 레포트 점수를 리턴하라. . (풀이) . test_dic[&#39;202212354&#39;][&#39;rep&#39;] . 85 . . Note: 출제의도: 딕셔너리에서 key를 이용한 원소추출 . (18) 학생들의 학번을 리턴하는 코드를 작성하라. . (풀이) . [k for k in test_dic] . [&#39;202212345&#39;, &#39;202212346&#39;, &#39;202212347&#39;, &#39;202212348&#39;, &#39;202212349&#39;, &#39;202212350&#39;, &#39;202212351&#39;, &#39;202212352&#39;, &#39;202212353&#39;, &#39;202212354&#39;, &#39;202212355&#39;] . . Note: 출제의도: 딕셔너리와 for문 . . (19) shape이 ()인 numpy이 array를 만들어라. (즉 차원이 0인 np.array를 만들어라) . (풀이) . np.array(3).shape . () . . Note: 출제의도: 0차원인 numpy array . (20) shape이 (2,2)인 단위행렬을 만들어라. . (풀이) . np.array([[1,0],[0,1]]) . array([[1, 0], [0, 1]]) . . Note: 출제의도: 넘파이에서의 배열선언 . (21) a의 모든 원소에 1을 더하는 코드를 작성하라. . a=[1,3,2,5,-3,3,8,2,3,1] . (풀이) . np.array([1,3,2,5,-3,3,8,2,3,1])+1 . array([ 2, 4, 3, 6, -2, 4, 9, 3, 4, 2]) . . Note: 출제의도: 브로드캐스팅 . (22) 아래와 같은 수열을 생성하라. . 1,3,6,10,15,21,28,36,45, ... , 378, 406, 435 . hint: 이 수열에서 $a_n-a_{n-1}=n, ~n geq 2$ 이다. 즉 3-1=2, 6-3=3, 10-6=4, ... . (풀이) . 435-406 . 29 . np.arange(1,30).cumsum() . array([ 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210, 231, 253, 276, 300, 325, 351, 378, 406, 435]) . . Note: 출제의도: np.arange, cumsum . (23) 아래와 같은 수열을 생생성하라. . 0,1,2,3,4,5,...,99 . 위의 수열에서 1,4,7,10,13,... 번째의 원소를 뽑아라. (첫번째 원소는 0이다) . (풀이) . np.arange(100)[::3] . array([ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]) . . Note: 출제의도: np.arange, 스트라이딩 . (24) numpy를 이용하여 아래의 역행렬을 구하라. $$ begin{bmatrix} 1&amp; 0 0&amp; 3 end{bmatrix}$$ . (풀이) . np.linalg.inv(np.array([[1,0],[0,3]])) . array([[1. , 0. ], [0. , 0.33333333]]) . . Note: 출제의도: np.linalg.inv . . (25)-(30) . a,b가 아래와 같이 주어졌다고 하자. . a=[1]*10 b=[2]*10 . (25) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라. . array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) . (풀이) . np.concatenate([a,b]) . array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) . . Note: 출제의도: np.concatenate . (26) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라. . array([[1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [2], [2], [2], [2], [2], [2], [2], [2], [2], [2]]) . (풀이) . np.concatenate([np.array(a).reshape(-1,1),np.array(b).reshape(-1,1)]) . array([[1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [2], [2], [2], [2], [2], [2], [2], [2], [2], [2]]) . . Note: 출제의도: np.concatenate . (27) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라. . array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]] . (풀이) . np.concatenate([np.array(a).reshape(1,-1),np.array(b).reshape(1,-1)]) . array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]) . . Note: 출제의도: np.concatenate . (28) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라. . array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]) . (풀이) . np.concatenate([np.array(a).reshape(-1,1),np.array(b).reshape(-1,1)],axis=1) . array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]) . . Note: 출제의도: np.concatenate . (29) a,b와 np.stack을 이용하여 아래와 같은 배열을 만들어라. . array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]] . (풀이) . np.stack([a,b]) . array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]) . . Note: 출제의도: np.stack . (30) a,b와 np.stack을 이용하여 아래와 같은 배열을 만들어라. . array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]) . (풀이) . np.stack([a,b],axis=1) . array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]) . . Note: 출제의도: np.stack . (31) 아래와 같은 배열이 있다고 하자. . a=np.array([1,2,3,4,5]) b=np.array([3,2,1,1,2]) . numpy의 @ 연산자를 이용하여 $ sum_{i=1}^{5}a_ib_i$를 계산하라. . (풀이) . a@b . 24 . . Note: 출제의도: @연산자의 계산 및 해석 . (32) 아래와 같은 배열을 생성하라. . x=np.random.randn(100) . numpy의 @연산자를 이용하여 $ sum_{i=1}^{100}x_i^2$을 계산하라. . (풀이) . x=np.random.randn(100) x@x . 69.28009497479688 . . Note: 출제의도: @연산자의 계산 및 해석 . (33) 아래와 같은 배열을 생성하라. . a=np.array([1/100]*100) x=np.random.randn(100) . numpy의 @연산자를 이용하여 $ frac{1}{n} sum_{i=1}^{n}x_i$를 계산하라. . (풀이) . a=np.array([1/100]*100) x=np.random.randn(100) a@x . -0.010052841585430794 . . Note: 출제의도: @연산자의 계산 및 해석 . (34) 표준정규분포에서 100개의 난수를 생성하라. . (풀이) . np.random.randn(100) . array([ 1.85418429, 1.74095494, 1.84238756, 0.11833414, 0.50517813, -0.69557289, -1.72748266, -0.26601374, 0.57719853, 0.18027158, -0.42542364, 0.85536403, -0.58893928, 0.55397097, -1.5535881 , -0.88229423, -0.71875421, -0.43570715, -0.30980515, -0.36179948, -0.17548155, 1.44052988, -0.59466028, 0.17292887, -0.59491904, -1.9695988 , 0.11928747, 1.28964429, 0.53823904, -1.18030647, -0.20558282, -1.08160482, 0.83372329, 0.28800561, 0.15599112, -1.03586037, -1.06770958, -2.71210449, 0.58241292, 0.69235475, 1.37391505, -0.0326631 , -0.12266586, -0.20292358, -0.27657851, 0.56420234, 0.40045754, -0.63219726, 0.40820948, -0.612829 , -1.28695191, 0.46508036, 0.2463253 , -0.27429529, -0.65675501, -1.01875321, -0.69944952, -0.31570476, 0.3646879 , -1.1631018 , -1.20414629, -0.90456531, 0.89434359, -0.29053615, 1.16408738, 0.71108284, -0.52138787, 1.07033411, 1.72342412, 0.90605155, -0.28896114, -1.89628331, -1.71603025, 1.21529517, 0.23833153, -0.52176073, -0.49144623, -0.75427022, 0.10468367, 0.36750664, 0.24346823, 0.20762347, 1.08915492, 1.89502878, 1.91479936, -0.4241885 , -1.05989046, 0.96622936, 0.40962212, -2.16589513, 0.45357349, -1.23802044, 0.39859558, 0.02910548, 1.44679724, 1.16285902, -0.1593022 , -2.14983146, 0.42739322, -0.94301164]) . . Note: 출제의도: 표준정규분포 생성 . (35) 아래와 동일한 코드를 np.random.rand()로 구현하라. . np.random.uniform(low=2,high=4,size=(5,)) . (풀이) . np.random.rand(5)*2+2 . array([3.62616239, 2.4038075 , 2.64420359, 2.80481305, 2.2678642 ]) . . Note: 출제의도: np.random.rand, np.random.uniform . (36) 아래와 같은 배열을 선언하라. . a=np.random.randn(100) . np.where를 이용하여 a의 모든 음수를 0으로 바꾸는 코드를 작성하라. . (풀이) . a=np.random.randn(100) np.where(a&lt;0,0,a) . array([0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 6.23392366e-01, 0.00000000e+00, 1.08600932e+00, 3.67178107e-01, 0.00000000e+00, 2.20251453e-01, 0.00000000e+00, 0.00000000e+00, 3.89764950e-02, 6.86794220e-01, 6.89479404e-01, 1.26211471e+00, 0.00000000e+00, 4.23611162e-01, 8.19460987e-01, 3.14530150e-01, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 1.30354361e+00, 0.00000000e+00, 0.00000000e+00, 4.40581127e-01, 0.00000000e+00, 0.00000000e+00, 7.86386724e-01, 1.92151119e-02, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 3.23260088e-01, 0.00000000e+00, 7.13352290e-01, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 7.01771469e-01, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 1.01926360e+00, 0.00000000e+00, 1.00933996e+00, 0.00000000e+00, 5.55528483e-01, 5.99763436e-01, 0.00000000e+00, 1.35136571e-01, 1.35928670e-02, 9.35722269e-01, 0.00000000e+00, 8.64547752e-01, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 1.68682634e+00, 0.00000000e+00, 1.07091321e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 8.27772542e-01, 0.00000000e+00, 7.65702396e-01, 0.00000000e+00, 0.00000000e+00, 3.29389519e-01, 0.00000000e+00, 2.51416616e-01, 0.00000000e+00, 8.17591580e-01, 0.00000000e+00, 1.09930438e-01, 8.71101099e-04, 2.17063699e-01, 2.06385934e-01, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 3.19516814e-01, 5.92549379e-02, 1.92857588e+00, 1.39519785e+00, 3.77551912e-01, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 5.16744013e-01, 0.00000000e+00, 1.87178822e+00, 1.75448718e+00, 3.40204387e-01, 7.69851631e-01]) . . Note: 출제의도: np.where 을 이용한 마스킹 . (37) 아래와 같은 배열을 선언하라. . a=np.random.randn(100) . 위 배열의 최소값이 위치한 index를 return하라. . (풀이) . a=np.random.randn(100) np.where(a==np.min(a)) . (array([92]),) . . Note: 출제의도: np.where . (38) 아래와 같은 배열을 선언하라. . a=np.arange(12).reshape(3,4) a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . 차원의 수를 유지하면서 1열을 추출하는 코드를 작성하라. 즉 결과가 아래와 같이 나오도록 하라. . array([[0], [4], [8]]) . (풀이) . a[:,[0]] . array([[0], [4], [8]]) . . Note: 출제의도: 차원을 유지하는 인덱싱 . (39)-(40) . (39) 자신의 학번으로 random seed 를 설정하라. [20,25)의 범위에서 100개의 정수를 랜덤으로 생성해 (10,10) shape의 배열을 만들어라. . (풀이) . np.random.seed(43052) a=np.random.randint(low=20,high=25,size=(10,10)) . . Note: 출제의도: np.random.randint . (40) 39의 결과에서 20,21,22 는 각각 몇개씩 있는가? . (풀이) . np.sum(a==20),np.sum(a==21),np.sum(a==22) . (17, 20, 19) . . Note: 출제의도: bool형의 sum . 2. &#53076;&#46300;&#44396;&#54788; II (50&#51216;) . . (1)-(6) 아래의 코드를 실해하여 test_dic를 생성하라. . np.random.seed(43052) att = np.random.choice(np.arange(10,21)*5,200) rep = np.random.choice(np.arange(5,21)*5,200) mid = np.random.choice(np.arange(0,21)*5,200) fin = np.random.choice(np.arange(0,21)*5,200) key = [&#39;202212&#39;+str(s) for s in np.random.choice(np.arange(300,501),200,replace=False)] test_dic = {key[i] : {&#39;att&#39;:att[i], &#39;rep&#39;:rep[i], &#39;mid&#39;:mid[i], &#39;fin&#39;:fin[i]} for i in range(200)} del(att);del(rep);del(mid);del(fin);del(key) . 여기에서 202212345등은 학번을, att는 출석점수, rep는 레포트점수, mid는 중간고사점수, fin은 기말고사 점수를 의미한다. . (1) test_dic에서 출석점수가 70이상(70&gt;=)인 학생들의 학번을 출력하는 코드를 작성하라. . (풀이) . ids= [k for k in test_dic if test_dic[k][&#39;att&#39;]&gt;=70] . . Note: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리 . (2) test_dic에서 출석점수가 70미만(&lt;70)인 학생들의 수를 구하라. . (풀이) . len([k for k in test_dic if test_dic[k][&#39;att&#39;]&lt;70]) . 70 . sum([test_dic[k][&#39;att&#39;]&lt;70 for k in test_dic]) . 70 . . Note: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리 . (3) test_dic에서 출석점수가 70이상(70&gt;=)인 학생들의 중간고사 점수의 평균을 계산하라. . (풀이) . np.mean([test_dic[k][&#39;mid&#39;] for k in test_dic if test_dic[k][&#39;att&#39;]&gt;=70]) . 57.15384615384615 . . Note: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리 . (4) test_dic에서 중간고사 점수를 출력하는 코드를 작성하라. . (풀이) . mid=[test_dic[k][&#39;mid&#39;] for k in test_dic] . . Note: 출제의도: 리스트컴프리헨션, for문과 딕셔너리 . (5) test_dic에서 중간고사 점수의 표준편차와 레포트점수의 표준편차를 구하여라. 어떤것이 더 큰가? . (풀이) . np.std([test_dic[k][&#39;mid&#39;] for k in test_dic]),np.std([test_dic[k][&#39;rep&#39;] for k in test_dic]) . (29.88243631299162, 22.626533097229014) . . Note: 출제의도: 리스트컴프리헨션, for문과 딕셔너리, np.std . (6) test_dic에서 중간고사 점수가 가장 높은 사람의 학번을 출력하라. . (풀이) . [k for k in test_dic if test_dic[k][&#39;mid&#39;]==max(mid)] . [&#39;202212326&#39;, &#39;202212463&#39;, &#39;202212383&#39;, &#39;202212341&#39;, &#39;202212417&#39;, &#39;202212401&#39;, &#39;202212405&#39;, &#39;202212369&#39;, &#39;202212403&#39;, &#39;202212407&#39;, &#39;202212315&#39;] . . Note: 출제의도: 리스트컴프리헨션, for문과 딕셔너리 . 주의: att,rep,mid,fin,key를 실행하여 소멸시키지 않고 그대로 이용하거나 np.random.choice()를 이용하여 재생성한 뒤 계산할 경우 0점 처리함. . 예를들면 (5)의 경우 np.std(mid), np.std(rep) 와 같은 식으로 구현하면 0점 처리함. | . . (7) 성공확률이 0.45인 시행이 있다고 하자. 이 시행을 100번의 시행하였을 경우 73번 이상 성공할 확률은 얼마인가? 시뮬레이션을 이용하여 근사계산하라. . (풀이) . sum(np.random.binomial(n=100,p=0.45,size=(1000,)) &gt;= 73) . 0 . . Note: 출제의도: np.random.binomial, bool형의 합 . (8) 성공확률이 0.45인 시행이 있다고 하자. 이 시행을 100번 시행하였을 경우 10번이하로 실패하거나 90번이상 성공할 확률은 얼마인가? 시뮬레이션을 이용하여 근사계산하라. . (풀이) . a=np.random.binomial(n=100,p=0.45,size=(1000,)) sum((a&gt;=90) | (a&lt;=10)) . 0 . sum(a&gt;=90) + sum(a&lt;=10) # 이것도 좋은 풀이 . 0 . . Note: 출제의도: np.random.binomial, bool형의 합 . (9) 아래와 같은 행렬을 선언하자. . A=np.arange(2*1).reshape(2,1) B=np.arange(2*2).reshape(2,2) C=np.arange(2*3).reshape(2,3) D=np.arange(3*3).reshape(3,3) E=np.arange(3*2).reshape(3,2) F=np.arange(3*1).reshape(3,1) . 아래의 블락매트릭스를 만들어라. . $ begin{bmatrix} a_{11} &amp; b_{11} &amp; b_{12} &amp; c_{11} &amp; c_{12} &amp; c_{13} a_{21} &amp; b_{21} &amp; b_{22} &amp; c_{21} &amp; c_{22} &amp; c_{23} d_{11} &amp; d_{12} &amp; d_{13} &amp; e_{11} &amp; e_{12} &amp; f_{11} d_{21} &amp; d_{22} &amp; d_{23} &amp; e_{21} &amp; e_{22} &amp; f_{21} d_{31} &amp; d_{32} &amp; d_{33} &amp; e_{31} &amp; e_{32} &amp; f_{31} end{bmatrix}$ . 여기에서 $a_{ij}$는 매트릭스 ${ bf A}$의 원소이다. . (풀이) . top = np.concatenate([A,B,C],axis=1) bottom = np.concatenate([D,E,F],axis=1) np.concatenate([top,bottom],axis=0) . array([[0, 0, 1, 0, 1, 2], [1, 2, 3, 3, 4, 5], [0, 1, 2, 0, 1, 0], [3, 4, 5, 2, 3, 1], [6, 7, 8, 4, 5, 2]]) . . Note: 출제의도: np.concatenate . (10) 표준정규분포에 10000개의 난수를 아래와 같이 생성하라. . x=np.random.randn(10000) y=np.random.randn(10000) . $(i,j)$ 번째 원소가 $(x_i-y_j)^2$인 (10000,10000) 매트릭스를 만들어라. . (풀이) . (x.reshape(10000,1) - y.reshape(1,10000))**2 . array([[9.94471594e-01, 1.59617444e+00, 4.89939117e-01, ..., 5.85763251e-02, 8.71831383e-01, 4.48231705e-02], [3.82650425e-01, 7.82788668e-01, 1.16338019e+00, ..., 3.85231232e-01, 1.72229831e+00, 3.48524169e-01], [2.19381916e-03, 4.81046770e-02, 3.04162913e+00, ..., 1.65404203e+00, 3.91165053e+00, 1.57699602e+00], ..., [4.06902110e-02, 4.15352671e-03, 3.60584637e+00, ..., 2.07641061e+00, 4.54827803e+00, 1.98997559e+00], [6.35135252e-01, 1.13022358e+00, 8.10422594e-01, ..., 1.95632560e-01, 1.28594998e+00, 1.69738287e-01], [3.93009857e+00, 5.05626325e+00, 8.13727798e-02, ..., 5.52331661e-01, 2.65189382e-03, 5.98303522e-01]]) . . Note: 출제의도: 브로드캐스팅 . . (11)-(16) . 아래와 같은 매트릭스를 생성하라. . np.random.seed(43052) a=np.random.randn(10000).reshape(100,100) a . array([[ 0.38342049, 1.0841745 , 1.14277825, ..., -0.18506968, 1.05538764, 1.18701443], [-0.25027283, -1.58045215, 0.1124153 , ..., 1.0321894 , 0.40438012, -0.13491595], [-0.76763724, -0.64294232, -0.24782396, ..., -0.01530161, 0.89125897, -0.82683395], ..., [-1.41379028, 0.79611333, -0.71011837, ..., -0.9860352 , 1.30755244, 2.18677233], [ 1.33968105, -0.78457449, -0.10405858, ..., -0.71110186, 0.99841286, 2.34371635], [-0.66422032, -0.07550233, 0.7405869 , ..., 1.03232398, -0.18988252, -0.03578389]]) . (11) 각 행의 합을 구하라. 즉 1행의 합, 2행의 합, ... 100행의 합을 계산하라. . 1행의합 = 0.38342049 + 1.0841745 + ... + 1.18701443 | . (풀이) . a.sum(axis=1) . array([-8.13607922e+00, 9.87120533e+00, -1.41434956e+01, -2.21705363e+00, -1.45535236e+01, -9.15821678e+00, -2.59866360e+00, -1.54562385e+01, -1.42005088e+00, -3.51523111e+00, 9.70487578e+00, -1.26229105e+01, 1.66837113e+00, 2.43015457e+00, 2.72990184e+00, -7.99486429e+00, -8.38305954e-01, -8.45002020e+00, -1.03610098e+00, 2.07251861e+01, 1.11461478e+01, 7.62144075e+00, -7.93734585e+00, 1.82844319e+01, -2.63562392e+00, -8.97916930e+00, -1.88986183e+00, -9.32477049e+00, -6.69074565e+00, -1.42463143e+01, 6.45540510e-01, 1.80911488e+00, 2.40997157e+00, 1.63367254e+01, 7.63990677e+00, 8.13524813e+00, 3.97159000e+00, -1.10542949e+00, 4.37564512e-01, 2.87299971e+00, -4.01016768e+00, 5.71115215e+00, -4.64132698e+00, -9.13987753e+00, -6.78326000e+00, 3.36308150e+00, -5.13704342e+00, -5.09782466e+00, 6.54192465e-03, 7.19722660e+00, -4.64674820e+00, -9.24124039e+00, 6.73530841e+00, 1.12168921e+00, 1.61615988e+00, 1.37602200e+01, 6.67289840e-01, -2.09578108e+00, -2.81826564e-01, -8.52416541e+00, -7.21970047e+00, 2.27146777e+01, -1.40341974e+01, 1.69263136e+01, -1.80568372e+01, 6.52142336e+00, -1.73092812e+01, -1.34999285e+01, -7.85539317e+00, -4.74940393e-01, -2.75765037e+01, 8.74991555e+00, -9.77324158e+00, 1.42854121e+01, -1.10130356e+00, -1.39206483e-01, -1.54638921e+01, 1.36814794e+00, 8.41394160e+00, -2.42153833e+00, -2.57155344e+01, -6.72423820e+00, -9.49366257e-01, 3.79493472e+00, -6.23508582e+00, 7.75657189e+00, 9.69403620e+00, 1.46847519e+01, 7.36500792e+00, -2.54755192e+01, 1.22792449e+01, -1.02497847e+01, 1.30452028e+01, 3.92943038e+00, -3.27227585e+00, -1.06633071e+01, -1.56942302e+01, 8.01451222e+00, 2.81546938e+00, 5.56774384e+00]) . . Note: 출제의도: np.sum with axis . (12) (11)의 결과로 나온 배열의 표준편차를 구하라. . (풀이) . a.sum(axis=1).std() . 9.98012658863081 . . Note: 출제의도: np.sum with axis, np.std . (13) 각 열의 평균을 구하라. 즉 1열의 평균, 2열의 평균, ... , 100열의 평균을 계산하라. . (풀이) . a.sum(axis=0) . array([ 5.05543481e-01, -8.11250975e-01, -7.27142023e-01, 9.64876493e+00, 5.64186324e+00, -2.22728206e+00, 1.32808256e-02, -9.60905067e+00, 9.42144096e+00, -1.21946518e+01, -2.21878576e+00, -3.77018716e+00, 2.35739166e-01, -1.13202128e+01, -9.00374437e+00, -3.09372275e+00, -2.18029121e+00, 7.04210003e+00, -4.12563112e+00, 2.58233488e+00, 1.16578817e+01, -1.59430241e+01, -1.53668953e+00, 9.21879710e+00, -1.11346500e+01, -1.20131585e+01, 5.94139652e+00, -3.27022797e+00, -1.46466366e+00, -1.78386785e+00, -1.06650333e+01, -9.04542721e+00, -8.52586244e+00, 5.52166280e+00, 1.94115122e+01, 4.64389603e+00, 5.13636914e+00, 1.11424801e+01, -4.18629084e+00, 9.23822150e+00, -2.00433998e+00, -5.73784795e+00, -8.79928414e+00, -3.01766235e+00, 6.47256326e+00, 3.14419234e+00, -1.16146865e+01, -1.04800787e+01, 3.17924308e+00, 5.51687322e+00, 1.04913214e+01, -2.79741703e-01, 2.56767141e+01, -1.35620430e+01, -9.59492302e+00, 1.23241275e+01, -5.26436946e-01, -3.14823093e+00, -4.00286104e+00, -1.48618576e+01, 4.85988487e+00, -1.37972086e+01, -1.04715966e+01, -7.13893940e+00, 4.35483376e+00, -2.10610822e+01, -1.03231108e+01, -1.62132451e+01, 2.85187037e+01, -8.25697744e+00, 4.33723229e+00, 1.32763889e+00, -1.61919484e+01, -5.07924036e+00, 6.62243327e+00, -9.72863991e+00, 2.71962223e+01, -5.97710822e+00, 1.54580795e+01, -5.46739064e+00, -1.08611574e+01, -1.56520706e+01, -1.40476317e+01, 1.06067589e+01, -3.46141736e+00, -6.07673046e+00, 5.33471760e-01, 8.10276105e+00, -1.31994569e+01, -1.00936968e+00, 6.13944222e+00, -9.72765699e+00, 1.61342793e+01, 1.02634369e+01, -5.03038014e+00, -7.50604837e+00, 2.63992605e+00, 6.98470602e+00, -1.89567885e+01, 7.91910813e+00]) . . Note: 출제의도: np.sum with axis . (14) (13)의 결과로 나온 배열의 표준편차를 구하라. . (풀이) . a.sum(axis=0).std() . 9.944992000065781 . . Note: 출제의도: np.sum with axis, np.std . (15) a의 원소중 a&gt;0 을 만족하는 원소의 평균을 구하여라. . (풀이) . a[a&gt;0].mean() . 0.7879030416692301 . . Note: 출제의도: bool을 이용한 인덱싱 . (16) a의 원소중 a&gt;3을 만족하는 원소의 수를 count하라. . (풀이) . np.sum(a&gt;3) . 17 . . Note: 출제의도: bool의 sum . . (17)-(18) . 아래와 같은 배열 a를 고려하자. . np.random.seed(43052) a=np.random.binomial(1,0.2,size=(10000,)) a . array([1, 0, 1, ..., 1, 1, 0]) . (17) 0에서 1로 바뀌는 부분을 count하라. . (풀이) . np.sum(np.diff(a)==1) . 1617 . . Note: 출제의도: np.diff 응용 . (18) 1에서 0으로 바뀌는 부분을 count하라. . (풀이) . np.sum(np.diff(a)==-1) . 1618 . . Note: 출제의도: np.diff 응용 . [예시] 아래의 배열에서 0에서 1로 부분은 모두 세 군데이고, 1에서 0으로 바뀌는 부분은 모두 두 군데 이다. . 0 0 0 1 0 1 0 0 0 1 1 1 . . (19)-(25) . (19) $i=1,2, dots,1000$에 대하여 아래를 각각 구하라. . $$x_i= cos(t_i)+ cos(3t_i)+ cos(5t_i)$$ . $$y_i= sin(t_i)+ sin(4t_i)$$ . 여기에서 $t_i= frac{2 pi i }{1000}$ 이다. . (풀이) . i=np.arange(1,1001) t=i*2*np.pi/1000 x=np.cos(t)+np.cos(3*t)+np.cos(5*t) y=np.sin(t)+np.sin(4*t) . . Note: 출제의도: numpy를 이용한 수식표현 . (20) $(x_i,y_i)$를 그려라. . (풀이) . plt.plot(x,y) . [&lt;matplotlib.lines.Line2D at 0x7f769fdaaf70&gt;] . . Note: 출제의도: plt.plot . (21) 아래와 같은 변환을 통하여 $(w_i,z_i)$를 얻어라. . $$w_i= frac{1}{ sqrt{2}}x_i - frac{1}{ sqrt{2}}y_i$$ . $$z_i= frac{1}{ sqrt{2}}x_i + frac{1}{ sqrt{2}}y_i$$ . $(w_i,z_i)$를 시각화 하라. . (풀이) . w = 1/np.sqrt(2)*x - 1/np.sqrt(2)*y z = 1/np.sqrt(2)*x + 1/np.sqrt(2)*y plt.plot(w,z) . [&lt;matplotlib.lines.Line2D at 0x7f76a073a760&gt;] . . Note: 출제의도: numpy를 이용한 연산, plt.plot . (22) 아래와 같은 매트릭스를 만들어라. . $${ bf A}= begin{bmatrix} x_1 &amp; y_1 x_2 &amp; y_2 dots &amp; dots x_n &amp; y_n end{bmatrix}$$ (풀이) . A=np.stack([x,y]).T A . array([[ 2.99930917e+00, 3.14132394e-02], [ 2.99723725e+00, 6.28103581e-02], [ 2.99378587e+00, 9.41752452e-02], ..., [ 2.99723725e+00, -6.28103581e-02], [ 2.99930917e+00, -3.14132394e-02], [ 3.00000000e+00, -1.22464680e-15]]) . A=np.stack([x,y],axis=1) A . array([[ 2.99930917e+00, 3.14132394e-02], [ 2.99723725e+00, 6.28103581e-02], [ 2.99378587e+00, 9.41752452e-02], ..., [ 2.99723725e+00, -6.28103581e-02], [ 2.99930917e+00, -3.14132394e-02], [ 3.00000000e+00, -1.22464680e-15]]) . . Note: 출제의도: np.stack . (23) ${ bf A} { bf B}$의 첫번째 열과 두번째 열을 시각화한 결과가 $(w_i,z_i)$과 동일하도록 적당한 (2,2) 매트릭스 ${ bf B}$를 만들어라. . (풀이) . B= np.array([[1/np.sqrt(2), 1/np.sqrt(2)],[-1/np.sqrt(2), 1/np.sqrt(2)]]) #B= np.array([[1, 1],[-1, 1]])/np.sqrt(2) plt.plot(A@B[:,0],A@B[:,1]) . [&lt;matplotlib.lines.Line2D at 0x7f769f644b80&gt;] . . Note: 출제의도: 행렬의 수식표현, 행렬의 곱 . (24) ${ bf A}{ bf B}^2$의 첫번째 열과 두번째 열을 시각화 하라. . (풀이) . plt.plot((A@B@B)[:,0],(A@B@B)[:,1]) . [&lt;matplotlib.lines.Line2D at 0x7f769f5e7190&gt;] . . Note: 출제의도: 행렬의 곱 . (25) $n=3,4,5,6, dots$ 에 대하여 ${ bf A}{ bf B}^n$을 반복적으로 그려보라. $(x_i,y_i)$의 시각화 결과와 동일한 가장 작은 $n$은 얼마인가? $(w_i,z_i)$의 시각화 결과와 동일한 가장 작은 $n$은 얼마인가? . (풀이) . plt.plot((A@B@B@B)[:,0],(A@B@B@B)[:,1]) ## n=3 . [&lt;matplotlib.lines.Line2D at 0x7f769fcc25b0&gt;] . plt.plot((A@B@B@B@B)[:,0],(A@B@B@B@B)[:,1]) ## n=4 . [&lt;matplotlib.lines.Line2D at 0x7f769f4e8040&gt;] . (B@B)@(B@B)@(B@B)@(B@B) . array([[1., 0.], [0., 1.]]) . (B@B)@(B@B)@(B@B)@(B@B)@B . array([[ 0.70710678, 0.70710678], [-0.70710678, 0.70710678]]) . 답: $(x_i,y_i)$의 시각화 결과와 동일한 가장 작은 $n=8$ 이고 $(w_i,z_i)$의 시각화 결과와 동일한 가장 작은 $n=9$ 이다. | . . Note: 출제의도: 회전변환의 유추, 역행렬의 개념응용 . . 3. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . (1) 아래는 python을 설치하는 방법을 소개한 url 이다. 직접 url에 들어가서 설치하는 방법을 읽어보고 곤이, 철용, 아귀, 짝귀 중 옳은말을 한 사람을 모두 골라라. . https://www.pythonlikeyoumeanit.com/Module1_GettingStartedWithPython/Installing_Python.html | . (곤이) 해당 방법은 아나콘다를 이용하여 파이썬을 설치하는 방법이다. . (철용) 그래서 이 방법으로는 가상환경을 만들 수 없겠군. . (아귀) 위 url에 제시된 방법으로 설치하면 주피터가 자동설치 된다. . (짝귀) 따라서 위의 방법으로 설치하면 IDE는 주피터만 사용할 수 있다. . . Note: 출제의도: 아나콘다를 이용한 설치 . (2) 곤이는 1부터 10까지의 합을 구하는 코드를 작성하기 위하여 아래와 같이 mysum.py 파일을 만들었다. . ## mysum.py total = 0 for i in range(1,11): total = total + i print(total) . 곤이의 컴퓨터는 윈도우이며 아니콘다를 이용해 파이썬을 설치하였다고 가정한다. 다음중 옳은 설명을 한 사람을 모두 고르라. . (곤이) mysum.py를 실행하기 위해서는 anaconda prompt 에서 mysum.py가 위치한 폴더로 이동한 뒤 %run mysum.py 를 실행하면 된다. . (철용) anaconda prompt 에서 mysum.py가 위치한 폴더로 이동한 뒤 ipython을 실행하고 %run mysum.py을 실행해도 된다. . (아귀) 철용의 방법에서 %run mysum.py 대신에 !python mysum.py를 쳐도 동작한다. . (짝귀) 하지만 다른 가상환경을 만들 경우 철용과 아귀의 방법으로 실행할 수 없다는 단점이 있다. . . Note: 출제의도: *.py 의 사용방법 .",
            "url": "https://guebin.github.io/IP2022/2022/05/03/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%ED%95%B4%EC%84%A4.html",
            "relUrl": "/2022/05/03/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%ED%95%B4%EC%84%A4.html",
            "date": " • May 3, 2022"
        }
        
    
  
    
        ,"post13": {
            "title": "2022년 파이썬 입문 중간고사",
            "content": "0. imports . 아래코드를 이용하여 numpy 와 matplotlib을 import하라. . import numpy as np import matplotlib.pyplot as plt . 1. &#53076;&#46300;&#44396;&#54788; I (40&#51216;) . 주의: 문제에 조건이 있는 경우 조건을 준수할 것 . (1) a의 type을 bool로 바꾸어라. . a=1.0 . . (2)-(6) . 아래의 문자열을 고려하자. . test_arr = &#39;ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local&#39; . (2) 위 문자열에서 짝수번째 원소를 출력하는 코드를 작성하라. . (3) 위 문자열에서 마지막 10개의 원소를 출력하는 코드를 작성하라. . (4) 위 문자열을 뒤집은 문자열을 구하는 코드를 작성하라. 즉 아래를 출력하는 코드를 작성하라. . &#39;lacol.potpalym@nocahcs ==Q7M+frw9iFRrNxbsSVqMlTarQ10d1os2njkImtaKn1+3r3wg+b8li/Z68Ec2DryauLMVmPZ98IPTnPZO4WA+ZmnE/trewr0bP/wv6ybNYjvDNpyX88XrrpKJQjlFUuz1bmFIe/86wW0V3+5x9Q1McnsAoJoaF3tAX7/KVlSvFMdsdwQANsjR6V8qLicMsZAHpXhKn1XixqBtiRXF3oAH+RCFXWlByTM/JdOk7vbP3adc0gwSppPbkVQ5XFl9h4fVELElx7MzQivrFUhbj9WJ4HJ81we5Zy4Idh7WYTDHlzfan+lPGUSDWB/mojT9KGTLNpITmrbS71YHfrHDkpUOlkAEQAAAwIBAAAAE2cy1CazN3BAAAA asr-hss&#39; . (5) 위 문자열에서 대문자의 수를 count하라. . hint .isupper() 메소드를 이용할 것. . &#39;a&#39;.isupper() . False . &#39;A&#39;.isupper() . True . &#39;=&#39;.isupper() . False . &#39;@&#39;.isupper() . False . (6) 위 문자열에서 사용된 문자 및 특수문자의 종류는 모두 몇가지 인가? . note1: 문자열 &#39;AAB @ab&#39; 에서 사용된 문자는 &#39;A&#39;, &#39;B&#39;, &#39; &#39;, &#39;@&#39;, &#39;a&#39;, &#39;b&#39; 이므로 모두 6종류의 문자 및 특수문자가 사용되었다. . note2: &#39; &#39;, &#39;+&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;, &#39;=&#39;, &#39;@&#39;, &#39;1&#39;, &#39;a&#39;, &#39;A&#39; 등을 모두 다른 문자로 취급한다. . . (7) 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 생성하라 . [&#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;, &#39;aaaa&#39;, &#39;aaaaa&#39;, &#39;aaaaaa&#39;, &#39;aaaaaaa&#39;, &#39;aaaaaaaa&#39;, &#39;aaaaaaaaa&#39;, &#39;aaaaaaaaaa&#39;] &lt;- a가 10개있음 . (8) 길이가 1인 튜플을 만들어 자신의 학번을 저장하라. 길이가 1인 튜플을 만들어 자신의 영문이름을 저장하라. 두 튜플을 + 연산자로 합쳐아래와 같은 출력결과를 얻어라. . (202143052,&#39;guebin&#39;) . (9) 아래와 같은 list가 있다고 하자. . test_lst = [[&#39;g&#39;,1],[&#39;u&#39;,5],[&#39;e&#39;,2],[&#39;b&#39;,8],[&#39;i&#39;,2],[&#39;n&#39;,9]] . test_lst와 리스트컴프리헨션을 이용하여 아래를 출력하는 코드를 구현하라. . [&#39;g&#39;, &#39;uuuuu&#39;, &#39;ee&#39;, &#39;bbbbbbbb&#39;, &#39;ii&#39;, &#39;nnnnnnnnn&#39;] . (10) 다음은 학생들의 출석,레포트,중간고사,기말고사 점수를 입력으로 하여 학점을 계산하는 함수이다. . def grade(attendance, report, mid, final): if attendance&lt;70: credit = &#39;F&#39; else: total_score = attendance * 0.1 + report * 0.2 + mid * 0.3 + final * 0.4 if total_score &gt; 80: credit = &#39;A+&#39; else: credit = &#39;B0&#39; return credit . 아래는 학생들의 학번, 출석점수, 레포트, 중간고사, 기말고사 점수가 입력된 리스트이다. . data = [[&#39;202212345&#39;, [100,95,25,90]], [&#39;202212346&#39;, [60,90,95,95]], [&#39;202212347&#39;, [50,90,45,35]], [&#39;202212348&#39;, [90,90,50,75]], [&#39;202212349&#39;, [100,95,85,85]], [&#39;202212350&#39;, [90,90,100,95]], [&#39;202212351&#39;, [100,95,100,95]], [&#39;202212352&#39;, [95,85,80,60]], [&#39;202212353&#39;, [100,90,60,55]], [&#39;202212354&#39;, [100,85,70,95]], [&#39;202212355&#39;, [100,95,40,100]]] . 아래의 ???를 적절하게 완성하여 학생들의 학점을 계산하는 코드를 완성하라. . [grade(???) for _, scores in data] . (11) 길이가 0인 문자열을 선언하라. . . (12)-(15) . (12) dir(plt)와 dir(np)를 각각 실행하라. 실행결과를 각각 a,b로 저장하라. a,b의 type은 무엇인가? . (13) a의 원소와 b의 원소의 수를 각각 구하라. . (14) a와 b의 공통원소의 수를 구하라. . (15) a와 b의 원소를 합친 리스트를 만들어라. (공통원소는 중복하여 합치지 않는다) . . (16)-(18) 아래와 같은 dictionary가 있다. . test_dic = {&#39;202212345&#39;: {&#39;att&#39;:100,&#39;rep&#39;:95,&#39;mid&#39;:25,&#39;fin&#39;:90}, &#39;202212346&#39;: {&#39;att&#39;:60,&#39;rep&#39;:90,&#39;mid&#39;:95,&#39;fin&#39;:95}, &#39;202212347&#39;: {&#39;att&#39;:50,&#39;rep&#39;:90,&#39;mid&#39;:45,&#39;fin&#39;:35}, &#39;202212348&#39;: {&#39;att&#39;:90,&#39;rep&#39;:90,&#39;mid&#39;:50,&#39;fin&#39;:75}, &#39;202212349&#39;: {&#39;att&#39;:100,&#39;rep&#39;:95,&#39;mid&#39;:85,&#39;fin&#39;:85}, &#39;202212350&#39;: {&#39;att&#39;:90,&#39;rep&#39;:90,&#39;mid&#39;:100,&#39;fin&#39;:95}, &#39;202212351&#39;: {&#39;att&#39;:100,&#39;rep&#39;:95,&#39;mid&#39;:100,&#39;fin&#39;:95}, &#39;202212352&#39;: {&#39;att&#39;:95,&#39;rep&#39;:85,&#39;mid&#39;:80,&#39;fin&#39;:60}, &#39;202212353&#39;: {&#39;att&#39;:100,&#39;rep&#39;:90,&#39;mid&#39;:60,&#39;fin&#39;:55}, &#39;202212354&#39;: {&#39;att&#39;:100,&#39;rep&#39;:85,&#39;mid&#39;:70,&#39;fin&#39;:95}, &#39;202212355&#39;: {&#39;att&#39;:100,&#39;rep&#39;:95,&#39;mid&#39;:40,&#39;fin&#39;:100}} . 여기에서 202212345등은 학번을, att는 출석점수, rep는 레포트점수, mid는 중간고사점수, fin은 기말고사 점수를 의미한다. . (16) get 메소드를 이용하여 202212353에 해당하는 학생의 성적을 아래와 같이 리턴하라. . {&#39;att&#39;: 100, &#39;rep&#39;: 90, &#39;mid&#39;: 60, &#39;fin&#39;: 55} . (17) 202212354의 레포트 점수를 리턴하라. . (18) 학생들의 학번을 리턴하는 코드를 작성하라. . . (19) shape이 ()인 numpy이 array를 만들어라. (즉 차원이 0인 np.array를 만들어라) . (20) shape이 (2,2)인 단위행렬을 만들어라. . (21) a의 모든 원소에 1을 더하는 코드를 작성하라. . a=[1,3,2,5,-3,3,8,2,3,1] . (22) 아래와 같은 수열을 생성하라. . 1,3,6,10,15,21,28,36,45, ... , 378, 406, 435 . hint: 이 수열에서 $a_n-a_{n-1}=n, ~n geq 2$ 이다. 즉 3-1=2, 6-3=3, 10-6=4, ... . (23) 아래와 같은 수열을 생생성하라. . 0,1,2,3,4,5,...,99 . 위의 수열에서 1,4,7,10,13,... 번째의 원소를 뽑아라. (첫번째 원소는 0이다) . (24) numpy를 이용하여 아래의 역행렬을 구하라. $$ begin{bmatrix} 1&amp; 0 0&amp; 3 end{bmatrix}$$ . . (25)-(30) . a,b가 아래와 같이 주어졌다고 하자. . a=[1]*10 b=[2]*10 . (25) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라. . array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) . (26) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라. . array([[1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [2], [2], [2], [2], [2], [2], [2], [2], [2], [2]]) . (27) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라. . array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]] . (28) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라. . array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]) . (29) a,b와 np.stack을 이용하여 아래와 같은 배열을 만들어라. . array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]] . (30) a,b와 np.stack을 이용하여 아래와 같은 배열을 만들어라. . array([[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]) . (31) 아래와 같은 배열이 있다고 하자. . a=np.array([1,2,3,4,5]) b=np.array([3,2,1,1,2]) . numpy의 @ 연산자를 이용하여 $ sum_{i=1}^{5}a_ib_i$를 계산하라. . (32) 아래와 같은 배열을 생성하라. . x=np.random.randn(100) . numpy의 @연산자를 이용하여 $ sum_{i=1}^{100}x_i^2$을 계산하라. . (33) 아래와 같은 배열을 생성하라. . a=np.array([1/100]*100) x=np.random.randn(100) . numpy의 @연산자를 이용하여 $ frac{1}{n} sum_{i=1}^{n}x_i$를 계산하라. . (34) 표준정규분포에서 100개의 난수를 생성하라. . (35) 아래와 동일한 코드를 np.random.rand()로 구현하라. . np.random.uniform(low=2,high=4,size=(5,)) . (36) 아래와 같은 배열을 선언하라. . a=np.random.randn(100) . np.where를 이용하여 a의 모든 음수를 0으로 바꾸는 코드를 작성하라. . (37) 아래와 같은 배열을 선언하라. . a=np.random.randn(100) . 위 배열의 최소값이 위치한 index를 return하라. . (38) 아래와 같은 배열을 선언하라. . a=np.arange(12).reshape(3,4) a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . 차원의 수를 유지하면서 1열을 추출하는 코드를 작성하라. 즉 결과가 아래와 같이 나오도록 하라. . array([[0], [4], [8]]) . (39)-(40) . (39) 자신의 학번으로 random seed 를 설정하라. [20,25)의 범위에서 100개의 정수를 랜덤으로 생성해 (10,10) shape의 배열을 만들어라. . (40) 39의 결과에서 20,21,22 는 각각 몇개씩 있는가? . 2. &#53076;&#46300;&#44396;&#54788; II (50&#51216;) . . (1)-(6) 아래의 코드를 실해하여 test_dic를 생성하라. . np.random.seed(43052) att = np.random.choice(np.arange(10,21)*5,200) rep = np.random.choice(np.arange(5,21)*5,200) mid = np.random.choice(np.arange(0,21)*5,200) fin = np.random.choice(np.arange(0,21)*5,200) key = [&#39;202212&#39;+str(s) for s in np.random.choice(np.arange(300,501),200,replace=False)] test_dic = {key[i] : {&#39;att&#39;:att[i], &#39;rep&#39;:rep[i], &#39;mid&#39;:mid[i], &#39;fin&#39;:fin[i]} for i in range(200)} del(att);del(rep);del(mid);del(fin);del(key) . 여기에서 202212345등은 학번을, att는 출석점수, rep는 레포트점수, mid는 중간고사점수, fin은 기말고사 점수를 의미한다. . (1) test_dic에서 출석점수가 70이상(70&gt;=)인 학생들의 학번을 출력하는 코드를 작성하라. . np.random.seed(43052) att = np.random.choice(np.arange(10,21)*5,200) rep = np.random.choice(np.arange(5,21)*5,200) mid = np.random.choice(np.arange(0,21)*5,200) fin = np.random.choice(np.arange(0,21)*5,200) key = [&#39;202212&#39;+str(s) for s in np.random.choice(np.arange(300,501),200,replace=False)] test_dic = {key[i] : {&#39;att&#39;:att[i], &#39;rep&#39;:rep[i], &#39;mid&#39;:mid[i], &#39;fin&#39;:fin[i]} for i in range(200)} del(att);del(rep);del(mid);del(fin);del(key) . (2) test_dic에서 출석점수가 70미만(&lt;70)인 학생들의 수를 구하라. . (3) test_dic에서 출석점수가 70이상(70&gt;=)인 학생들의 중간고사 점수의 평균을 계산하라. . np.mean([test_dic[k][&#39;mid&#39;] for k in test_dic if test_dic[k][&#39;mid&#39;]&gt;=70]) . 85.41666666666667 . (4) test_dic에서 중간고사 점수를 출력하는 코드를 작성하라. . (5) test_dic에서 중간고사 점수의 표준편차와 레포트점수의 표준편차를 구하여라. 어떤것이 더 큰가? . (6) test_dic에서 중간고사 점수가 가장 높은 사람의 학번을 출력하라. . 주의: att,rep,mid,fin,key를 실행하여 소멸시키지 않고 그대로 이용하거나 np.random.choice()를 이용하여 재생성한 뒤 계산할 경우 0점 처리함. . 예를들면 (5)의 경우 np.std(mid), np.std(rep) 와 같은 식으로 구현하면 0점 처리함. | . . (7) 성공확률이 0.45인 시행이 있다고 하자. 이 시행을 100번의 시행하였을 경우 73번 이상 성공할 확률은 얼마인가? 시뮬레이션을 이용하여 근사계산하라. . (8) 성공확률이 0.45인 시행이 있다고 하자. 이 시행을 100번 시행하였을 경우 10번이하로 실패하거나 90번이상 성공할 확률은 얼마인가? 시뮬레이션을 이용하여 근사계산하라. . (9) 아래와 같은 행렬을 선언하자. . A=np.arange(2*1).reshape(2,1) B=np.arange(2*2).reshape(2,2) C=np.arange(2*3).reshape(2,3) D=np.arange(3*3).reshape(3,3) E=np.arange(3*2).reshape(3,2) F=np.arange(3*1).reshape(3,1) . 아래의 블락매트릭스를 만들어라. . $ begin{bmatrix} a_{11} &amp; b_{11} &amp; b_{12} &amp; c_{11} &amp; c_{12} &amp; c_{13} a_{21} &amp; b_{21} &amp; b_{22} &amp; c_{21} &amp; c_{22} &amp; c_{23} d_{11} &amp; d_{12} &amp; d_{13} &amp; e_{11} &amp; e_{12} &amp; f_{11} d_{21} &amp; d_{22} &amp; d_{23} &amp; e_{21} &amp; e_{22} &amp; f_{21} d_{31} &amp; d_{32} &amp; d_{33} &amp; e_{31} &amp; e_{32} &amp; f_{31} end{bmatrix}$ . 여기에서 $a_{ij}$는 매트릭스 ${ bf A}$의 원소이다. . (10) 표준정규분포에 10000개의 난수를 아래와 같이 생성하라. . x=np.random.randn(10000) y=np.random.randn(10000) . $(i,j)$ 번째 원소가 $(x_i-y_i)^2$인 (10000,10000) 매트릭스를 만들어라. . . (11)-(16) . 아래와 같은 매트릭스를 생성하라. . np.random.seed(43052) a=np.random.randn(10000).reshape(100,100) a . array([[ 0.38342049, 1.0841745 , 1.14277825, ..., -0.18506968, 1.05538764, 1.18701443], [-0.25027283, -1.58045215, 0.1124153 , ..., 1.0321894 , 0.40438012, -0.13491595], [-0.76763724, -0.64294232, -0.24782396, ..., -0.01530161, 0.89125897, -0.82683395], ..., [-1.41379028, 0.79611333, -0.71011837, ..., -0.9860352 , 1.30755244, 2.18677233], [ 1.33968105, -0.78457449, -0.10405858, ..., -0.71110186, 0.99841286, 2.34371635], [-0.66422032, -0.07550233, 0.7405869 , ..., 1.03232398, -0.18988252, -0.03578389]]) . (11) 각 행의 합을 구하라. 즉 1행의 합, 2행의 합, ... 100행의 합을 계산하라. . 1행의합 = 0.38342049 + 1.0841745 + ... + 1.18701443 | . (12) (11)의 결과로 나온 배열의 표준편차를 구하라. . (13) 각 열의 평균을 구하라. 즉 1열의 평균, 2열의 평균, ... , 100열의 평균을 계산하라. . (14) (13)의 결과로 나온 배열의 표준편차를 구하라. . (15) a의 원소중 a&gt;0 을 만족하는 원소의 평균을 구하여라. . (16) a의 원소중 a&gt;3을 만족하는 원소의 수를 count하라. . . (17)-(18) . 아래와 같은 배열 a를 고려하자. . np.random.seed(43052) a=np.random.binomial(1,0.2,size=(10000,)) a . array([1, 0, 1, ..., 1, 1, 0]) . (17) 0에서 1로 바뀌는 부분을 count하라. . (18) 1에서 0으로 바뀌는 부분을 count하라. . [예시] 아래의 배열에서 0에서 1로 부분은 모두 세 군데이고, 1에서 0으로 바뀌는 부분은 모두 두 군데 이다. . 0 0 0 1 0 1 0 0 0 1 1 1 . . (19)-(25) . (19) $i=1,2, dots,1000$에 대하여 아래를 각각 구하라. . $$x_i= cos(t_i)+ cos(3t_i)+ cos(5t_i)$$ . $$y_i= sin(t_i)+ sin(4t_i)$$ . 여기에서 $t_i= frac{2 pi i }{1000}$ 이다. . (20) $(x_i,y_i)$를 그려라. . (21) 아래와 같은 변환을 통하여 $(w_i,z_i)$를 얻어라. . $$w_i= frac{1}{ sqrt{2}}x_i - frac{1}{ sqrt{2}}y_i$$ . $$z_i= frac{1}{ sqrt{2}}x_i + frac{1}{ sqrt{2}}y_i$$ . $(w_i,z_i)$를 시각화 하라. . (22) 아래와 같은 매트릭스를 만들어라. . $${ bf A}= begin{bmatrix} x_1 &amp; y_1 x_2 &amp; y_2 dots &amp; dots x_n &amp; y_n end{bmatrix}$$ (23) ${ bf A} { bf B}$의 첫번째 열과 두번째 열을 시각화한 결과가 $(w_i,z_i)$과 동일하도록 적당한 (2,2) 매트릭스 ${ bf B}$를 만들어라. . (24) ${ bf A}{ bf B}^2$의 첫번째 열과 두번째 열을 시각화 하라. . (25) $n=3,4,5,6, dots$ 에 대하여 ${ bf A}{ bf B}^n$을 반복적으로 그려보라. $(x_i,y_i)$의 시각화 결과와 동일한 가장 작은 $n$은 얼마인가? $(w_i,z_i)$의 시각화 결과와 동일한 가장 작은 $n$은 얼마인가? . . 3. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . (1) 아래는 python을 설치하는 방법을 소개한 url 이다. 직접 url에 들어가서 설치하는 방법을 읽어보고 곤이, 철용, 아귀, 짝귀 중 옳은말을 한 사람을 모두 골라라. . https://www.pythonlikeyoumeanit.com/Module1_GettingStartedWithPython/Installing_Python.html | . (곤이) 해당 방법은 아나콘다를 이용하여 파이썬을 설치하는 방법이다. . (철용) 그래서 이 방법으로는 가상환경을 만들 수 없겠군. . (아귀) 위 url에 제시된 방법으로 설치하면 주피터가 자동설치 된다. . (짝귀) 따라서 위의 방법으로 설치하면 IDE는 주피터만 사용할 수 있다. . (2) 곤이는 1부터 10까지의 합을 구하는 코드를 작성하기 위하여 아래와 같이 mysum.py 파일을 만들었다. . ## mysum.py total = 0 for i in range(1,11): total = total + i print(total) . 곤이의 컴퓨터는 윈도우이며 아니콘다를 이용해 파이썬을 설치하였다고 가정한다. 다음중 옳은 설명을 한 사람을 모두 고르라. . (곤이) mysum.py를 실행하기 위해서는 anaconda prompt 에서 mysum.py가 위치한 폴더로 이동한 뒤 %run mysum.py 를 실행하면 된다. . (철용) ipython을 이용하여 실행하기 위해서는 anaconda prompt 에서 mysum.py가 위치한 폴더로 이동한 뒤 %run mysum.py을 실행해도 된다. . (아귀) 철용의 방법에서 %run mysum.py 대신에 !python mysum.py를 쳐도 동작한다. . (짝귀) 하지만 다른 가상환경을 만들 경우 철용과 아귀의 방법으로 실행할 수 없다는 단점이 있다. .",
            "url": "https://guebin.github.io/IP2022/2022/04/25/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "relUrl": "/2022/04/25/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "date": " • Apr 25, 2022"
        }
        
    
  
    
        ,"post14": {
            "title": "2022년 파이썬 입문 중간고사 예상유형",
            "content": ". 0. &#50500;&#47000;&#51032; &#53076;&#46300;&#47484; &#49892;&#54665;&#54616;&#50668; numpy&#50752; matplotlib.pyploy&#51012; &#51076;&#54252;&#53944;&#54616;&#46972;. . import numpy as np import matplotlib.pyplot as plt . import numpy as np import matplotlib.pyplot as plt . 1. &#53076;&#46300;&#44396;&#54788; I (&#47928;&#51228;&#50640; &#51312;&#44148;&#51060; &#51080;&#45716; &#44221;&#50864; &#51312;&#44148;&#51012; &#51456;&#49688;&#54624;&#44163;) . (1) 리스트의 *연산자를 이용하여 길이가 10이고 모든원소가 1인 리스트를 선언하라. . [1]*10 . [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] . (2) 튜플언패킹을 이용하여 아래를 한줄로 처리하는 코드를 작성하라. . a=1 b=2.33 c=&#39;guebin&#39; . a,b,c = 1,2.33,&#39;guebin&#39; . (3) 길이가 1인 튜플을 만들어 자신의 학번을 저장하라. . (43052,) . (43052,) . (4) 아래와 같은 문자열의 마지막원소를 출력하는 코드를 작성하라. . test_str = &#39;guebin&#39; . test_str = &#39;guebin&#39; test_str[-1] . &#39;n&#39; . (5) 본인 학번을 이용하여 random seed 를 설정하라. 평균이 0, 분산이 1인 정규분포에 10000개의 값을 추출한뒤 값이 1.96보다 큰 경우가 몇개 있는지 세어보라. . hint: 본인학번이 202143052인 경우 아래와 같이 설정 . np.random.seed(202143052) . np.random.seed(202143052) sum(np.random.randn(10000) &gt; 1.96) . 242 . (6) 아래와 같은 array의 shape을 (4,3)으로 수정하는 코드를 작성하라. . test_arr = np.arange(12) . test_arr = np.arange(12) test_arr.reshape(4,3) . array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]]) . 2. &#53076;&#46300;&#44396;&#54788; II . (1) ${ bf x}=(x_1, dots,x_{100})$를 표준정규분포에서 서로독립인 100개의 난수를 생성하여 만든 길이가 100인 vector라고 하자. . (a) $ sum_{i=1}^{100} x_i^2$ 를 계산하라. . (b) $y_k = sum_{i=1}^{k}x_i$를 만족하는 ${ bf y}=(y_1,y_2, dots,y_{100})$를 생성하라. . x=np.random.randn(100) sum(x**2) . 103.57060890918511 . x.cumsum() . array([ 0.47468281, 0.34386559, 1.15108986, 2.21490225, 3.68862517, 6.6560929 , 4.93164856, 4.64464292, 4.42000953, 4.59835234, 4.89968072, 5.96011555, 6.05848061, 6.30156284, 6.45723823, 5.83750354, 5.37523078, 5.15841694, 5.9573261 , 6.05283436, 5.22666108, 4.59445292, 4.28220497, 5.02407374, 4.04275772, 3.760779 , 4.64585317, 3.35034863, 4.70650237, 6.00188554, 5.655467 , 4.71014034, 4.1729924 , 2.6572072 , 2.45471889, 2.4957559 , 2.33281836, 1.93651955, 1.19124851, 0.72053316, -0.85868479, -0.51403318, -0.39293256, -0.11037825, -0.90405075, 0.36017316, -0.64589555, -0.61405341, -0.6071379 , -2.25775258, -2.58632882, -4.15597547, -4.35785515, -3.06555043, -2.53143389, -3.75231655, -2.53480854, -3.17666336, -3.24829447, -4.82257719, -5.12059882, -3.92232594, -3.92249184, -5.26608319, -5.50649365, -6.94874974, -6.31473021, -5.30493964, -6.66675701, -6.05865575, -5.9302322 , -7.51211747, -5.28113967, -4.7794617 , -5.80837388, -6.83179461, -5.72807049, -5.43528895, -4.82945081, -6.24232477, -5.84089936, -4.82742572, -4.05496918, -5.22220941, -4.43970357, -6.44483947, -6.82657167, -6.58432556, -5.34876223, -4.73907863, -3.30982415, -3.40413528, -3.31029211, -1.97453616, -1.27172043, -1.88394219, 0.7616805 , 1.32059937, 3.97185397, 3.08178286]) . (2) $i=1,2, dots,1000$에 대하여 $( cos(t_i) , sin(t_i))$를 시각화하는 코드를 작성하라. 단 $t_i= frac{2 pi i }{1000}$. . t=np.arange(1,1001)*2*np.pi/1000 plt.plot(np.cos(t),np.sin(t)) . [&lt;matplotlib.lines.Line2D at 0x7f02d16635b0&gt;] . (3) 아래의 문자열에서 W가 몇개 들어 있는지 세는 코드를 작성하라. . test_str = &#39;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&#39; . test_str = &#39;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&#39; . test_str.count(&quot;W&quot;) . 4 . list(test_str).count(&quot;W&quot;) . 4 . (4) 블록대각행렬의 구현: 입력과 출력이 아래의 예시와 같은 함수를 구현하라. . ### 예시1 입력: (2,3) 출력: 1 1 0 0 0 1 1 0 0 0 0 0 1 1 1 0 0 1 1 1 0 0 1 1 1 . ### 예시2 입력: (2,2,3) 출력: 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 0 0 0 0 1 1 1 . def f(arr): arr2 = np.cumsum(arr) bmat = np.zeros([sum(arr) ,sum(arr) ]) a,b=0,0 for i in arr2: b=i bmat[a:b,a:b] = np.ones(b-a) a=i return bmat . f([3,2,2]) . array([[1., 1., 1., 0., 0., 0., 0.], [1., 1., 1., 0., 0., 0., 0.], [1., 1., 1., 0., 0., 0., 0.], [0., 0., 0., 1., 1., 0., 0.], [0., 0., 0., 1., 1., 0., 0.], [0., 0., 0., 0., 0., 1., 1.], [0., 0., 0., 0., 0., 1., 1.]]) . 3. &#45796;&#51020;&#51012; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. . (1) 아래는 python을 설치하는 방법을 소개한 url 이다. 직접 url에 들어가서 설치하는 방법을 읽어보고 곤이, 철용, 아귀, 짝귀 중 옳은말을 한 사람을 모두 골라라. . https://wikidocs.net/8 | . (곤이) 해당 방법은 아나콘다를 이용하지 않고 파이썬을 설치하는 방법이다. . (철용) 그래서 이 방법으로는 가상환경을 만들 수 없겠군. . (아귀) 위 url에 제시된 방법으로 설치하면 항상 *.py을 만들어야만 파이썬코드를 실행할 수 있다는 단점이 있다. . (짝귀) 위 url은 IDE의 선택에 대하여 서술하고 있다. . 답: 곤이, 철용 . (2) 아래를 보고 적절한 설명을 한 사람을 골라라. . import pandas as pd pd? . Type: module String form: &lt;module &#39;pandas&#39; from &#39;/home/cgb2/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/__init__.py&#39;&gt; File: ~/anaconda3/envs/py39/lib/python3.9/site-packages/pandas/__init__.py Docstring: pandas - a powerful data analysis and manipulation library for Python ===================================================================== **pandas** is a Python package providing fast, flexible, and expressive data structures designed to make working with &quot;relational&quot; or &quot;labeled&quot; data both easy and intuitive. It aims to be the fundamental high-level building block for doing practical, **real world** data analysis in Python. Additionally, it has the broader goal of becoming **the most powerful and flexible open source data analysis / manipulation tool available in any language**. It is already well on its way toward this goal. Main Features - Here are just a few of the things that pandas does well: - Easy handling of missing data in floating point as well as non-floating point data. - Size mutability: columns can be inserted and deleted from DataFrame and higher dimensional objects - Automatic and explicit data alignment: objects can be explicitly aligned to a set of labels, or the user can simply ignore the labels and let `Series`, `DataFrame`, etc. automatically align the data for you in computations. - Powerful, flexible group by functionality to perform split-apply-combine operations on data sets, for both aggregating and transforming data. - Make it easy to convert ragged, differently-indexed data in other Python and NumPy data structures into DataFrame objects. - Intelligent label-based slicing, fancy indexing, and subsetting of large data sets. - Intuitive merging and joining data sets. - Flexible reshaping and pivoting of data sets. - Hierarchical labeling of axes (possible to have multiple labels per tick). - Robust IO tools for loading data from flat files (CSV and delimited), Excel files, databases, and saving/loading data from the ultrafast HDF5 format. - Time series-specific functionality: date range generation and frequency conversion, moving window statistics, date shifting and lagging. . (로이) pd?이 실행된 결과를 살펴보니 사용자가 pandas라는 이름의 패키지를 설치했거나 본인이 pandas라는 이름의 폴더를 만들어 ~/anaconda3/envs/py39/lib/python3.9/site-packages에 넣었다고 볼 수 있겠군. . (이서) 네, 따라서 앞으로 pandas 패지키에 포함된 모든 함수를 이용하기 위해서는 pandas. 를 앞에 붙이고 사용하시면 됩니다. 예를들어 pandas안의 concat()함수를 사용하고 싶다면 pandas.concat()과 같은 형식으로요. . (일권) 이서말도 맞지만 아래와 같이 선언한다면 pandas.concat() 대신에 그냥 concat() 만으로도 사용할 수 있어. . import pandas as pd from pd import concat . (현이) pd?의 실행결과 Docstring:이 있는것으로 보아 __init__.py상단에 아래와 같은 내용이 있음을 유추할 수 있어. . pandas - a powerful data analysis and manipulation library for Python ===================================================================== ... (중략) ... - Time series-specific functionality: date range generation and frequency conversion, moving window statistics, date shifting and lagging. . 답: 로이, 현이 . some notes . - 모든 문항은 부분점수 없이 채점합니다. . - 코드구현 I은 문제의 조건을 준수하여 구현해야 하는 유형입니다. 조건을 무시하고 구현할시 0점처리합니다. . 예를들어 문제 1-(1) 의 경우 [1,1,1,1,1,1,1,1,1,1] 와 같이 리스트를 선언하면 0점 처리됩니다. | . - 코드구현 II는 자유롭게 코드를 구현해도 괜찮은 유형입니다. . - 문제 3-(1)의 경우 영어로 된 url이 나올 수 있습니다. . - 실제시험은 예상유형의 문항수보다 많습니다. . - 예상유형과 똑같은 문제는 시험에 출제되지 않습니다. .",
            "url": "https://guebin.github.io/IP2022/2022/04/21/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EC%98%88%EC%83%81%EB%AC%B8%EC%A0%9C.html",
            "relUrl": "/2022/04/21/2022%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC-%EC%98%88%EC%83%81%EB%AC%B8%EC%A0%9C.html",
            "date": " • Apr 21, 2022"
        }
        
    
  
    
        ,"post15": {
            "title": "2021년 파이썬 입문 중간고사",
            "content": "1 &#45796;&#51020;&#51012; &#51069;&#44256; &#52280;&#51064;&#44163;&#51012; &#47784;&#46160; &#44264;&#46972;&#46972;. (10&#51216;) . (ㄱ) 딕셔너리는 key와 value가 하나의 쌍으로 되어 {}로 둘러싸여 있다. (ㄴ) `abs(-20)`의 실행결과는 `20`이다. (ㄷ) `[1]+[2]`의 실행결과는 `[3]` 이다. (ㄹ) `(1,)`의 자료형은 tuple이다. (ㅁ) 자료형이 `str`이면 각 원소를 쉽게 바꿀 수 있다. . 2 &#50500;&#47000;&#51032; &#49892;&#54665;&#44208;&#44284; &#51473; &#50732;&#48148;&#47480; &#44163;&#51008;? (35&#51216;) . (a) . a=1.0 b=2 type(a+b) . (ㄱ) int (ㄴ) float (ㄷ) bool (ㄹ) complex (ㅁ) str (ㅂ) list (ㅅ) tuple (ㅇ) dict . (b) . a=1 b=2 type(a==b) . (ㄱ) int (ㄴ) float (ㄷ) bool (ㄹ) complex (ㅁ) str (ㅂ) list (ㅅ) tuple (ㅇ) dict . (c) . a=1 b=2 type(int(a==b)) . (ㄱ) int (ㄴ) float (ㄷ) bool (ㄹ) complex (ㅁ) str (ㅂ) list (ㅅ) tuple (ㅇ) dict . (d) . type([1,2,3]) . (ㄱ) int (ㄴ) float (ㄷ) bool (ㄹ) complex (ㅁ) str (ㅂ) list (ㅅ) tuple (ㅇ) dict . (e) . a=1 type(a) . (ㄱ) int (ㄴ) float (ㄷ) bool (ㄹ) complex (ㅁ) str (ㅂ) list (ㅅ) tuple (ㅇ) dict . (f) . a=(1) type(a) . (ㄱ) int (ㄴ) float (ㄷ) bool (ㄹ) complex (ㅁ) str (ㅂ) list (ㅅ) tuple (ㅇ) dict . (g) . a=(1,) type(a) . (ㄱ) int (ㄴ) float (ㄷ) bool (ㄹ) complex (ㅁ) str (ㅂ) list (ㅅ) tuple (ㅇ) dict . 3 &#50500;&#47000;&#51032; &#53076;&#46300;&#47484; &#51096; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (25&#51216;) . a=[1,[2],2,[1]] def a_add(a,i,j): if type(a[i])==type(a[j]): rtn=a[i]+a[j] else: rtn=a[i],a[j] return rtn . (a) &#50500;&#47000;&#51032; &#52636;&#47141;&#44208;&#44284; &#51473; &#48148;&#47480; &#44163;&#51008;? . a[0]==a[2] . (ㄱ) True (ㄴ) False . (b) &#50500;&#47000;&#51032; &#52636;&#47141;&#44208;&#44284; &#51473; &#48148;&#47480; &#44163;&#51008;? . type(a[0])==type(a[2]) . (ㄱ) True (ㄴ) False . (c) &#50500;&#47000;&#51032; &#52636;&#47141;&#44208;&#44284;&#47484; &#50416;&#46972;. . a_add(a,0,2) . (d) &#50500;&#47000;&#51032; &#52636;&#47141;&#44208;&#44284;&#47484; &#50416;&#46972;. . a_add(a,1,3) . (e) &#50500;&#47000;&#51032; &#52636;&#47141;&#44208;&#44284;&#51473; &#51201;&#51208;&#54620; &#44163;&#51008;? . type(a_add(a,0,1)) . (ㄱ) int (ㄴ) float (ㄷ) bool (ㄹ) complex (ㅁ) str (ㅂ) list (ㅅ) tuple (ㅇ) dict . 4 &#50896;&#51452;&#50984;&#51012; &#52636;&#47141;&#54616;&#45716; &#48169;&#48277; &#51473; &#50732;&#48148;&#47480; &#44163;&#51012; &#47784;&#46160; &#44256;&#47476;&#49884;&#50724; (10&#51216;) . (ㄱ) import math math.pi (ㄴ) import math pi (ㄷ) from math import pi pi (ㄹ) from math import * pi . 5 &#50500;&#47000;&#51032; &#50640;&#47084;&#47700;&#49884;&#51648;&#44032; &#45208;&#50724;&#45716; (&#51096;&#47803;&#46108;) &#53076;&#46300;&#45716;? (10&#51216;) . (a) . TypeError: object of type &#39;float&#39; has no len() . (ㄱ) len(3.14) (ㄴ) len([3.14]) (ㄷ) len((3.14,)) (ㄹ) len(&#39;3.14&#39;) . (b) (a)&#51032; &#50640;&#47084;&#44032; &#45208;&#50724;&#45716; &#51060;&#50976;&#50640; &#45824;&#54616;&#50668; &#49444;&#47749;&#54616;&#46972;. . 6 &#50500;&#47000;&#50752; &#44057;&#51060; a&#47484; &#49440;&#50616;&#54616;&#50688;&#45796;&#44256; &#54616;&#51088;. (&#12593;)-(&#12601;) &#51473; &#50739;&#51008; &#49444;&#47749;&#51012; &#47784;&#46160; &#44264;&#46972;&#46972;. (10&#51216;) . a=&#39;guebin&#39; . (ㄱ) a의 자료형은 str이다. 즉 type(a)의 출력결과는 str이다. (ㄴ) len(a)의 실행결과는 1이다. (ㄷ) a[0]=&#39;G&#39;와 같은 방법으로 첫글자를 대문자로 바꿀 수 있다. (ㄹ) a*2의 실행결과는 &#39;guebinguebin&#39;이다. . 7 [&#50696;&#51228;&#53076;&#46300;]&#51032; &#44208;&#44284;&#47484; &#44288;&#52272;&#54616;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (10&#51216;) . ## 예제코드 ## a=[&#39;G&#39;,&#39;u&#39;,&#39;e&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;] del a[0] a ## 실행결과 [&#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . (a) &#50500;&#47000;&#53076;&#46300;&#51032; &#52636;&#47141;&#44208;&#44284;&#47484; &#50416;&#46972;. . a=[&#39;G&#39;,&#39;u&#39;,&#39;e&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;] del a[0] del a[0] . (b) &#50500;&#47000;&#53076;&#46300;&#51032; &#52636;&#47141;&#44208;&#44284; &#51473; &#50732;&#48148;&#47480; &#44163;&#51008;? . b=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;] del b[-1] b . (ㄱ) [&#39;1&#39;, &#39;2&#39;] (ㄴ) [&#39;2&#39;, &#39;3&#39;] (ㄷ) [&#39;1&#39;, &#39;3&#39;] (ㄹ) 에러메시지로 출력할 수 없음. . 8 &#45796;&#51020;&#51012; &#51069;&#44256; &#47932;&#51020;&#50640; &#45813;&#54616;&#46972;. (15&#51216;) . (a) &#50500;&#47000;&#45716; .append&#50640; &#45824;&#54620; &#49324;&#50857;&#50696;&#49884;&#51060;&#45796;. . ### .append 예시 a=[1,2] a.append(3) print(a) ### 실행결과 [1, 2, 3] . &#50948;&#51032; &#53076;&#46300;&#47484; &#52280;&#44256;&#54616;&#50668; &#50500;&#47000;&#51032; &#49892;&#54665;&#44208;&#44284;&#47484; &#50416;&#46972;. . x=[] for i in [0,1,2,3,4,5]: x.append(2**i) x . (b) &#47532;&#49828;&#53944; &#52980;&#54532;&#47532;&#54760;&#49496;&#51012; &#49324;&#50857;&#54616;&#50668; (a)&#50752; &#46041;&#51068;&#54620; &#52636;&#47141;&#44208;&#44284;&#47484; &#50619;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . (c) &#47532;&#49828;&#53944; &#52980;&#54532;&#47532;&#54760;&#49496;&#51012; &#49324;&#50857;&#54616;&#50668; &#50500;&#47000;&#51032; &#52636;&#47141;&#44208;&#44284;&#47484; &#50619;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . [&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;Y1&#39;,&#39;Y2&#39;,&#39;Y3&#39;] . 9 a,b&#50640; &#51200;&#51109;&#46108; &#46160; &#44050;&#51012; &#44368;&#54872;&#54616;&#44256; &#49910;&#45796;&#44256; &#54616;&#51088;. &#50500;&#47000;&#51032; ???&#50640; &#50508;&#47582;&#51008; &#45236;&#50857;&#51012; &#51201;&#51004;&#49884;&#50724;. (10&#51216;) . a=10 b=20 ??? a,b ## 실행결과 (20, 10) . 10 &#50500;&#47000;&#51032; &#53076;&#46300;&#50640; &#45824;&#54620; &#52636;&#47141;&#44208;&#44284;&#47484; &#50416;&#46972;. (10&#51216;) . idlist=[(&#39;guebin&#39;, &#39;202112345&#39;,&#39;M&#39;,&#39;Korea&#39;), (&#39;iu&#39;, &#39;202154321&#39;,&#39;F&#39;,&#39;Korea&#39;), (&#39;hodong&#39;, &#39;201812321&#39;,&#39;M&#39;,&#39;Korea&#39;)] for name, _, _, _ in idlist: print(name) . 11 &#47532;&#49828;&#53944;&#47484; &#54876;&#50857;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; &#48176;&#50676;&#51012; &#47564;&#46308;&#50632;&#45796;&#44256; &#54616;&#51088;. (15&#51216;) . a=[[11,12,13], [21,22,23], [31,32,33]] . (a) &#50500;&#47000;&#53076;&#46300;&#51032; &#49884;&#54665;&#44208;&#44284;&#47484; &#50416;&#46972;. . a[0][1]+a[1][2] . (b) &#50500;&#47000;&#53076;&#46300;&#51032; &#49884;&#54665;&#44208;&#44284;&#47484; &#50416;&#46972;. . a[0]+a[1] . (c) &#50500;&#47000;&#53076;&#46300;&#51032; &#49884;&#54665;&#44208;&#44284;&#47484; &#50416;&#46972;. . import numpy as np a=np.array(a) a[0]+a[1] . 12 &#50500;&#47000;&#50752; &#44057;&#51008; &#50672;&#47549;&#48169;&#51221;&#49885;&#51012; &#47564;&#51313;&#54616;&#45716; &#54644; $(w,x,y,z)$&#47484; &#54392;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. (20&#51216;) . $ begin{cases} x+y+z=3 w+y+z=3 w+x+z=3 w+x+y=3 end{cases}$ . 13 &#50500;&#47000;&#50752; &#44057;&#51008; &#54665;&#47148;&#51012; numpy&#47484; &#51060;&#50857;&#54616;&#50668; &#49440;&#50616;&#54664;&#45796;&#44256; &#54616;&#51088;. (15&#51216;) . import numpy as np A=np.array([[11,12,13,14,15], [21,22,23,24,25], [31,32,33,34,35]]) . (a) &#45796;&#51020; &#53076;&#46300;&#51032; &#49892;&#54665;&#44208;&#44284;&#47196; &#51201;&#51208;&#54620; &#44163;&#51008;? . A[1] . (ㄱ) array([11, 12, 13, 14, 15]) (ㄴ) array([21, 22, 23, 24, 25]) (ㄷ) array([11, 21, 31]) (ㄹ) array([12, 22, 32]) . (b) &#45796;&#51020; &#53076;&#46300;&#51032; &#49892;&#54665;&#44208;&#44284;&#47196; &#51201;&#51208;&#54620; &#44163;&#51008;? . A[1,:] . (ㄱ) array([11, 12, 13, 14, 15]) (ㄴ) array([21, 22, 23, 24, 25]) (ㄷ) array([11, 21, 31]) (ㄹ) array([12, 22, 32]) . (c) &#45796;&#51020; &#53076;&#46300;&#51032; &#49892;&#54665;&#44208;&#44284;&#47196; &#51201;&#51208;&#54620; &#44163;&#51008;? . A[np.ix_([0,1],[0,1])] . (ㄱ) array([[11, 12], [21, 22]]) (ㄴ) array([[11, 21], [12, 22]]) (ㄷ) array([11, 12, 21, 22]) (ㄹ) array([12, 22, 11, 12]) . 14 &#51201;&#45817;&#54620; &#44284;&#51221;&#51012; &#53685;&#54616;&#50668; &#50500;&#47000;&#50752; &#44057;&#51008; &#45936;&#51060;&#53552;&#47484; &#50619;&#50632;&#45796;&#44256; &#44032;&#51221;&#54616;&#51088;. (20&#51216;) . import pandas as pd #...적당한과정... df . age toeic gpa . 새로이 30.0 | 600 | 4.0 | . 이서 20.0 | 950 | 4.2 | . 일권 28.0 | 450 | 2.3 | . 현이 28.0 | 650 | 3.8 | . (a) &#52395; &#46160;&#50676;(age,toeic)&#50640; &#51217;&#44540;&#54616;&#45716; &#53076;&#46300;&#47484; &#50024;&#46972;. . (b) &#53664;&#51061;&#51216;&#49688;&#44032; 800&#51060;&#49345;&#51064; &#49324;&#46988;&#51012; &#48520;&#47084;&#50724;&#45716; &#53076;&#46300;&#47484; &#50024;&#46972;. . (c) &#49464;&#48264;&#51704; &#50676;(gpa)&#50640; &#51217;&#44540;&#54616;&#45716; &#53076;&#46300; &#51473; &#51201;&#51208;&#54620; &#44163;&#51012; &#47784;&#46160; &#44264;&#46972;&#46972;. . (ㄱ) df.loc[&#39;gpa&#39;] (ㄴ) df.iloc[:,2] (ㄷ) df.iloc[:,-1] (ㄹ) df.iloc[2] . (d) &#45208;&#51060;&#44032; 23&#48372;&#45796; &#47566;&#44256; &#53664;&#51061;&#51216;&#49688;&#44032; 635&#51060;&#54616; &#54617;&#51216;&#51060; 3.0 &#51060;&#49345;&#51064; &#49324;&#46988;&#51012; &#48520;&#47084;&#50724;&#45716; &#53076;&#46300;&#47484; &#51089;&#49457;&#54616;&#46972;. . 15 &#50500;&#47000;&#47484; &#48372;&#44256; &#51201;&#51208;&#54620; &#49444;&#47749;&#51012; &#54620; &#49324;&#46988;&#51012; &#47784;&#46160; &#44256;&#47476;&#46972;. (10&#51216;) . import vec vec? . Type: module String form: &lt;module &#39;vec&#39; from &#39;/home/cgb2/vec/__init__.py&#39;&gt; File: ~/vec/__init__.py Docstring: 이 패키지는 현재 길이가 2,3인 벡터의 연산만 지원하지만 추후 업데이트하여 더욱 발전할 예정 . (로이) import vec이 실행되는 것을 보니 (1) 사용자가 vec이라는 패키지를 설치했거나 (2) 사용자가 현재 작업중인 폴더에 vec.py파일을 만들었거나 (3) 사용자가 현재 작업중인 폴더 아래 vec이라는 폴더가 존재하는 경우등 중 하나라고 볼 수 있겠군. . (이서) 네, 그런데 vec?의 실행 결과중 File:을 확인해 보니 사용자가 작업중인 폴더아래 vec이라는 폴더가 있는것으로 판단됩니다. . (일권) 이서가 말한대로 File:을 확인해보니 사용자가 vec폴더에 __init__.py도 만들어 놓았음을 알수 있군. __init__.py는 import vec을 수행하면 암시적으로 실행된다고 했었지? . (현이) 그렇지, 그런데 사실 파일 이름이 꼭 __init__.py이어야 하는것은 아니야. . (수아) vec?의 실행결과 Docstring:이 있는것으로 보아 __init__.py상단에 아래와 같은 내용이 있음을 유추할 수 있어. . &#39;&#39;&#39; 이 패키지는 현재 길이가 2,3인 벡터의 연산만 지원하지만 추후 업데이트하여 더욱 발전할 예정 &#39;&#39;&#39; .",
            "url": "https://guebin.github.io/IP2022/2022/04/20/2021%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "relUrl": "/2022/04/20/2021%EB%85%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9E%85%EB%AC%B8-%EC%A4%91%EA%B0%84%EA%B3%A0%EC%82%AC.html",
            "date": " • Apr 20, 2022"
        }
        
    
  
    
        ,"post16": {
            "title": "시험관련 안내사항",
            "content": "&#49884;&#54744;&#50976;&#54805; . - 오픈북: 강의노트, 본인이 정리한 노트, 인터넷 검색 가능 . - 비대면: Zoom을 활용하여 응시 . &#49884;&#54744;&#49884;&#44036; . - 일시: LMS를 통해 공지한 날의 수업시간 . - 시험시간 중 처음 30분은 장비점검시간으로 활용함 (단, 모든 사람이 준비될 경우 30분을 기다리지 않고 시작) . 따라서 2시간 수업일 경우 실질적으로 문제를 풀고 답안을 제출할때 까지 쓸 수 있는 시간은 1시간30분입니다. | . &#49884;&#54744;&#49892; &#51077;&#51109; . - LMS $ to$ 강의대화 $ to$ Zoom 화상강의 바로 가기로 입장 . &#49884;&#54744;&#47928;&#51228; &#44277;&#44060;&#48169;&#49885; . - LMS에 주피터노트북 파일 업로드 + LMS 공지사항을 통하여 시험문제의 URL을 공개 . 주피터파일의 장점: URL보다 LMS의 주피터노트북이 더 빠르게 공개됨. | URL의 장점: 시험문제의 오류가 있을 경우 수정이후 URL에 반영됨. | . &#51228;&#52636; . - 답안지: LMS의 레포트 메뉴를 활용하여 답안지를 제출 (종료시간 이전에 미리 제출가능) . - 동영상: 시험시간동안 컴퓨터전체화면 녹화후 제출 . 듀얼모니터의 경우 작업표시줄이 나타나는 모니터를 녹화 | 아이패드와 동시사용시에는 아이패드도 함께 녹화 | . &#51456;&#48708;&#47932; . - 컴퓨터 및 노트북: 시험지 확인 및 문제풀이 용도 . - 핸드폰: Zoom을 통하여 주변상황을 및 컴퓨터 화면을 촬영하는 용도 . 중간에 핸드폰 및 노트북이 꺼지지 않도록 충전기를 준비한다. | . - 학생증 혹은 신분증 (본인확인용도) . &#49884;&#54744;&#51204; &#51456;&#48708;&#49324;&#54637; . - 시험준비시간 동안 핸드폰을 아래와 같이 배치하여 학생의 컴퓨터 화면 및 주변상황이 보이도록 함 . . 적절한 각도를 설정하기 어려운 경우 주변환경보다 컴퓨터의 화면이 잘 보이도록 설정할 것 | . - 학생증을 준비하여 시험 시작 직전에 본인의 얼굴과 학생증을 함께 촬영한다. (5초간) . &#50976;&#51032;&#49324;&#54637; . - 줌의 대화명은 이름과 학번을 모두 적는다. (예시: 최규빈_202143052) . 동명이인이 있을 수 있으므로 학번을 같이 적으세요 | . - 질문은 카카오톡 채널 혹은 줌의 채팅기능을 이용한다. . - Zoom에서 스피커 음소거를 하지 않는다. (전체 공지사항등이 있을때 음성으로 공지함) . - 핸드폰으로 Zoom참가 중 전화가 오면 거절하고 받지 않는다. (전화통화시 Zoom연결이 종료되므로 부정행위로 의심할 수 있음) . &#44592;&#53440; &#52280;&#44256;&#49324;&#54637; . - 핸드폰과 피씨를 이용하여 줌에 동시접속할 경우 . 최규빈_202143052_핸드폰 | 최규빈_202143052_컴퓨터 | . 와 같이 기기를 분리하여 적는다. . - 시험문제는 코랩으로 풀어도 무방하며 시험문제를 다운받아 개인 주피터노트북 등으로 풀어도 무방하다. . - 답안지 제출형식은 주피터 노트북파일을 권장한다. 하지만 풀이 및 코드를 알아볼 수 있는 어떠한 형식으로 제출하여도 무방하다. (ex: txt, hwp, pdf, html..) .",
            "url": "https://guebin.github.io/IP2022/2022/04/19/%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "relUrl": "/2022/04/19/%EC%8B%9C%ED%97%98%EA%B4%80%EB%A0%A8-%EC%95%88%EB%82%B4%EC%82%AC%ED%95%AD.html",
            "date": " • Apr 19, 2022"
        }
        
    
  
    
        ,"post17": {
            "title": "(7주차) 4월18일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/5) 메소드 도움말확인, hstack, vstack, append, ravel, flatten, 기타통계함수들, dtype, 브로드캐스팅 . - (2/5) 브로드캐스팅 . - (3/5) matplotlib . - (4/5) 시험유의사항 . - (5/5) 예상문제 및 학점 안내사항 . imports . import numpy as np . numpy &#44277;&#48512; 7&#45800;&#44228; . note 1: &#47700;&#49548;&#46300; &#46020;&#50880;&#47568; &#54869;&#51064;&#54616;&#44592; . - 파이썬에서 함수를 적용하는 2가지 방식 . np.sum(a) | a.sum() | . a=np.array([1,2,3,4,5]) a . array([1, 2, 3, 4, 5]) . a.sum() . 15 . np.sum(a) . 15 . - 넘파이에서 a.sum()에 대한 도움말은 보통 np.sum()에 자세히 나와있음. $ to$ np.sum()의 도움말을 확인하고 np.sum(a)와 a.sum()이 동일함을 이용하여 a.sum()의 사용법을 미루어 유추해야함. . a.sum? . Docstring: a.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True) Return the sum of the array elements over the given axis. Refer to `numpy.sum` for full documentation. See Also -- numpy.sum : equivalent function Type: builtin_function_or_method . np.sum? . Signature: np.sum( a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;, ) Docstring: Sum of array elements over a given axis. Parameters - a : array_like Elements to sum. axis : None or int or tuple of ints, optional Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis. .. versionadded:: 1.7.0 If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. dtype : dtype, optional The type of the returned array and of the accumulator in which the elements are summed. The dtype of `a` is used by default unless `a` has an integer dtype of less precision than the default platform integer. In that case, if `a` is signed then the platform integer is used while if `a` is unsigned then an unsigned integer of the same precision as the platform integer is used. out : ndarray, optional Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. keepdims : bool, optional If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array. If the default value is passed, then `keepdims` will not be passed through to the `sum` method of sub-classes of `ndarray`, however any non-default value will be. If the sub-class&#39; method does not implement `keepdims` any exceptions will be raised. initial : scalar, optional Starting value for the sum. See `~numpy.ufunc.reduce` for details. .. versionadded:: 1.15.0 where : array_like of bool, optional Elements to include in the sum. See `~numpy.ufunc.reduce` for details. .. versionadded:: 1.17.0 Returns - sum_along_axis : ndarray An array with the same shape as `a`, with the specified axis removed. If `a` is a 0-d array, or if `axis` is None, a scalar is returned. If an output array is specified, a reference to `out` is returned. See Also -- ndarray.sum : Equivalent method. add.reduce : Equivalent functionality of `add`. cumsum : Cumulative sum of array elements. trapz : Integration of array values using the composite trapezoidal rule. mean, average Notes -- Arithmetic is modular when using integer types, and no error is raised on overflow. The sum of an empty array is the neutral element 0: &gt;&gt;&gt; np.sum([]) 0.0 For floating point numbers the numerical precision of sum (and ``np.add.reduce``) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no ``axis`` is given. When ``axis`` is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python&#39;s ``math.fsum`` function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as ``float32``, numerical errors can become significant. In such cases it can be advisable to use `dtype=&#34;float64&#34;` to use a higher precision for the output. Examples -- &gt;&gt;&gt; np.sum([0.5, 1.5]) 2.0 &gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32) 1 &gt;&gt;&gt; np.sum([[0, 1], [0, 5]]) 6 &gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0) array([0, 6]) &gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1) array([1, 5]) &gt;&gt;&gt; np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1) array([1., 5.]) If the accumulator is too small, overflow occurs: &gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8) -128 You can also start the sum with a value other than zero: &gt;&gt;&gt; np.sum([10], initial=5) 15 File: ~/anaconda3/envs/py39/lib/python3.9/site-packages/numpy/core/fromnumeric.py Type: function . note 2: hstack, vstack . - hstack, vstack 를 쓰는 사람도 있다. . a=np.arange(6) b=-a . np.vstack([a,b]) . array([[ 0, 1, 2, 3, 4, 5], [ 0, -1, -2, -3, -4, -5]]) . np.stack([a,b],axis=0) . array([[ 0, 1, 2, 3, 4, 5], [ 0, -1, -2, -3, -4, -5]]) . np.hstack([a,b]) . array([ 0, 1, 2, 3, 4, 5, 0, -1, -2, -3, -4, -5]) . np.concatenate([a,b],axis=0) . array([ 0, 1, 2, 3, 4, 5, 0, -1, -2, -3, -4, -5]) . note 3: append . - 기능1: reshape(-1) + concat . a=np.arange(30).reshape(5,6) b= -np.arange(8).reshape(2,2,2) . a.shape, b.shape . ((5, 6), (2, 2, 2)) . np.append(a,b) . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 0, -1, -2, -3, -4, -5, -6, -7]) . np.concatenate([a.reshape(-1),b.reshape(-1)]) . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 0, -1, -2, -3, -4, -5, -6, -7]) . - 기능2: concat . a=np.arange(2*3*4).reshape(2,3,4) b=-a . a.shape,b.shape, np.append(a,b,axis=0).shape . ((2, 3, 4), (2, 3, 4), (4, 3, 4)) . a.shape,b.shape, np.append(a,b,axis=1).shape . ((2, 3, 4), (2, 3, 4), (2, 6, 4)) . a.shape,b.shape, np.append(a,b,axis=2).shape . ((2, 3, 4), (2, 3, 4), (2, 3, 8)) . - concat과의 차이? . a=np.arange(2*3*4).reshape(2,3,4) b=-a c=2*a . np.append(a,b,c,axis=0) . TypeError Traceback (most recent call last) Input In [123], in &lt;cell line: 1&gt;() -&gt; 1 np.append(a,b,c,axis=0) File &lt;__array_function__ internals&gt;:4, in append(*args, **kwargs) TypeError: _append_dispatcher() got multiple values for argument &#39;axis&#39; . np.concatenate([a,b,c],axis=0) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23]], [[ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]], [[ 0, 2, 4, 6], [ 8, 10, 12, 14], [ 16, 18, 20, 22]], [[ 24, 26, 28, 30], [ 32, 34, 36, 38], [ 40, 42, 44, 46]]]) . note 4: ravel, flatten . a=np.arange(2*3*4).reshape(2,3,4) a . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) . a.reshape(-1) . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . a.ravel() . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . a.flatten() . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . note 5: &#44592;&#53440; &#53685;&#44228;&#54632;&#49688;&#46308; . - 평균, 중앙값, 표준편차, 분산 . a = np.random.normal(loc=0,scale=2,size=(100,)) a . array([-1.12093037, 2.03228998, 0.97607763, -1.95129947, -1.49794935, -2.69582142, 6.26294142, 0.17772869, 0.88248101, -0.0987605 , -2.20172938, 1.57977467, -3.70228648, 3.62666243, 0.35655652, 2.24552797, 1.82730641, -0.27324478, 2.96368325, 2.36722536, 1.00283717, 2.25966997, 0.74019075, 1.19192351, 2.70918979, 1.56791667, -3.9192988 , 0.51262046, 2.1701658 , 1.45665188, -0.95216879, -0.78855745, -2.01741917, -0.93273601, -1.01042306, -0.03667253, 0.4746618 , -2.55669289, 1.10739444, 1.15177071, -2.96111607, -1.97698346, -1.62882279, -0.73025042, -4.41933873, 2.67699686, -1.49483629, 0.00726669, -0.91481464, -3.34965693, -1.53808928, 0.45192716, 0.62408358, 4.00499954, -0.44609797, -2.58265527, -3.66717305, 2.10773738, -0.51106569, 2.29246892, 2.79998629, -3.03791044, 1.89561133, 0.19501627, 0.72806721, -1.50778943, 0.42474352, 0.12223567, -1.04890662, -1.9739829 , -1.4261672 , -0.20406325, -0.23939128, 1.41477338, -2.25923024, 1.17742253, -2.00670917, 0.1468111 , -0.57698109, 3.52781535, 1.71060134, 2.31381344, -1.06125884, -1.73359866, 0.21638374, 0.92504343, 2.50727404, 1.3510571 , 0.62009821, -1.77908053, 1.85646061, 0.66264999, -1.64292395, -0.60274377, -1.1585586 , -0.66907802, 2.38660429, 1.41138093, -2.3059048 , -0.53353575]) . np.mean(a) . 0.04457872598775192 . np.median(a) . 0.13452338307274175 . np.std(a) . 1.957280879505603 . np.var(a) . 3.8309484412782266 . - corr matrix, cov matrix . np.random.seed(43052) x= np.random.randn(10000) y= np.random.randn(10000)*2 z= np.random.randn(10000)*0.5 . np.corrcoef([x,y,z]).round(2) . array([[ 1. , -0.01, 0.01], [-0.01, 1. , 0. ], [ 0.01, 0. , 1. ]]) . np.cov([x,y,z]).round(2) . array([[ 0.99, -0.02, 0. ], [-0.02, 4.06, 0. ], [ 0. , 0. , 0.25]]) . note 6: dtype . - np.array는 항상 dtype이 있다. . a = np.array([1,2,3]) a . array([1, 2, 3]) . a.dtype . dtype(&#39;int64&#39;) . a = np.array([1.0,2.0,3.0]) a . array([1., 2., 3.]) . a.dtype . dtype(&#39;float64&#39;) . - 같은 int라도 int16,int32,int64으로 나누어진다. . a = np.array([1,2,3],dtype=np.int32) a . array([1, 2, 3], dtype=int32) . a.dtype . dtype(&#39;int32&#39;) . - float도 float16, float32, float64가 있다. . a = np.array([1,2,3],dtype=np.float32) a . array([1., 2., 3.], dtype=float32) . - 데이터타입은 아래와 같은 방법으로 변환시킬 수 있다. . a = np.array([1,2,3],dtype=np.int32) a . array([1, 2, 3], dtype=int32) . a=a.astype(dtype=np.int64) a . array([1, 2, 3]) . a.dtype . dtype(&#39;int64&#39;) . - 문자열의 경우 . a = np.array([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) a . array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U1&#39;) . a = np.array([&#39;ab&#39;,&#39;b&#39;,&#39;c&#39;]) a . array([&#39;ab&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U2&#39;) . a = np.array([&#39;abasdf&#39;,&#39;b&#39;,&#39;c&#39;]) a . array([&#39;abasdf&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;&lt;U6&#39;) . - 문자열+숫자혼합 =&gt; 문자열로 통일 . a= np.array([&#39;a&#39;,1]) a . array([&#39;a&#39;, &#39;1&#39;], dtype=&#39;&lt;U21&#39;) . a= np.array([&#39;a&#39;,1.0]) a . array([&#39;a&#39;, &#39;1.0&#39;], dtype=&#39;&lt;U32&#39;) . - 숫자를 문자열로 전환 . a= np.array([1,2,3]) a . array([1, 2, 3]) . a.astype(np.str_) . array([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], dtype=&#39;&lt;U21&#39;) . note 7: &#48652;&#47196;&#46300;&#52880;&#49828;&#54021;&#44284; &#49884;&#44036;&#52769;&#51221; . (예비학습) . import time . t1=time.time() . t2=time.time() t2-t1 . 0.21341419219970703 . 예비학습끝 . (예제) x=[0,1,2,3,4] 인 벡터가 있다고 하자. (i,j)의 원소가 (x[i]-x[j])**2 을 의미하는 $5 times 5$ 매트릭스를 구하라. . (풀이1) . x=np.array(range(5)) x . array([0, 1, 2, 3, 4]) . dist = np.zeros([5,5]) dist . array([[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]]) . for i in range(5): for j in range(5): dist[i,j]=(x[i]-x[j])**2 . dist . array([[ 0., 1., 4., 9., 16.], [ 1., 0., 1., 4., 9.], [ 4., 1., 0., 1., 4.], [ 9., 4., 1., 0., 1.], [16., 9., 4., 1., 0.]]) . (풀이2) . x1=x.reshape(5,1).astype(dtype=np.float64) x2=x.reshape(1,5).astype(dtype=np.float64) . x1 . array([[0.], [1.], [2.], [3.], [4.]]) . x2 . array([[0., 1., 2., 3., 4.]]) . x1-x2 . array([[ 0., -1., -2., -3., -4.], [ 1., 0., -1., -2., -3.], [ 2., 1., 0., -1., -2.], [ 3., 2., 1., 0., -1.], [ 4., 3., 2., 1., 0.]]) . (i,j)th element = x[i]-x[j] | . (x1-x2)**2 . array([[ 0., 1., 4., 9., 16.], [ 1., 0., 1., 4., 9.], [ 4., 1., 0., 1., 4.], [ 9., 4., 1., 0., 1.], [16., 9., 4., 1., 0.]]) . . y=np.array(range(10000)) . dist = np.zeros([10000,10000]) dist . array([[0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], ..., [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.], [0., 0., 0., ..., 0., 0., 0.]]) . t1=time.time() for i in range(10000): for j in range(10000): dist[i,j]=(y[i]-y[j])**2 t2=time.time() t2-t1 . 37.53360199928284 . y1=y.reshape(10000,1).astype(np.float64) y2=y.reshape(1,10000).astype(np.float64) . t1=time.time() dist2=(y1-y2)**2 t2=time.time() t2-t1 . 0.1297893524169922 . (dist-dist2).sum() . 0.0 . matplotlib . import matplotlib.pyplot as plt . plt.plot . - 기본그림 . plt.plot([1,2,3],[3,4,5],&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f12887bd5e0&gt;] . plt.plot(np.array([1,2,3]),np.array([3,4,5]),&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f12886c6c10&gt;] . - 예제들 . t=np.linspace(-6,6,100) x=np.sin(t) y=np.cos(t) . plt.plot(t,x) . [&lt;matplotlib.lines.Line2D at 0x7f1288595e80&gt;] . plt.plot(t,y) . [&lt;matplotlib.lines.Line2D at 0x7f12885c2760&gt;] . plt.plot(t,x) plt.plot(t,y) . [&lt;matplotlib.lines.Line2D at 0x7f12882dc0d0&gt;] . plt.plot(t,x) plt.plot(t,y,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f128829bee0&gt;] . plt.plot(t,x) plt.plot(t,y,&#39;--&#39;) . [&lt;matplotlib.lines.Line2D at 0x7f1288268ca0&gt;] . plt.hist . X = np.random.randn(1000) Y = np.random.rand(1000) . plt.hist(X) . (array([ 23., 59., 134., 195., 233., 180., 111., 45., 14., 6.]), array([-2.50630325, -1.93388828, -1.3614733 , -0.78905833, -0.21664336, 0.35577162, 0.92818659, 1.50060157, 2.07301654, 2.64543152, 3.21784649]), &lt;BarContainer object of 10 artists&gt;) . plt.hist(Y) . (array([107., 95., 79., 104., 117., 106., 101., 110., 91., 90.]), array([0.00168942, 0.10132944, 0.20096946, 0.30060948, 0.4002495 , 0.49988951, 0.59952953, 0.69916955, 0.79880957, 0.89844958, 0.9980896 ]), &lt;BarContainer object of 10 artists&gt;) .",
            "url": "https://guebin.github.io/IP2022/2022/04/18/(7%EC%A3%BC%EC%B0%A8)-4%EC%9B%9418%EC%9D%BC.html",
            "relUrl": "/2022/04/18/(7%EC%A3%BC%EC%B0%A8)-4%EC%9B%9418%EC%9D%BC.html",
            "date": " • Apr 18, 2022"
        }
        
    
  
    
        ,"post18": {
            "title": "(7주차) 4월13일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/3) rand, randn . - (2/3) randint . - (3/3) choice, 통계분포, np.where/np.argwhere, 인덱싱고급, np.ix_ . import . import numpy as np . numpy&#44277;&#48512; 5&#45800;&#44228;: &#47004;&#45924;&#47784;&#46280; . np.random.rand() . - 0~1사이에서 10개의 난수 생성 . np.random.rand(10) . array([0.9762396 , 0.62290682, 0.65602078, 0.22890413, 0.01139937, 0.71156552, 0.22585515, 0.98642156, 0.20169783, 0.52544263]) . - 0~2사이에서 10개의 난수 생성 . np.random.rand(10)*2 . array([0.19486166, 1.31320638, 1.75920753, 0.03976132, 0.65443053, 0.98238346, 0.81586536, 1.26374209, 0.05189084, 1.53713552]) . - 1~2사이에서 10개의 난수 생성 . np.random.rand(10)+1 . array([1.14697821, 1.52687013, 1.10827739, 1.87820387, 1.81630002, 1.93842216, 1.30725718, 1.21386634, 1.9331912 , 1.29694134]) . - 1~3사이에서 10개의 난수 생성 . np.random.rand(10)*2+1 # 1~3 . array([2.10122574, 2.67412063, 2.70573365, 1.49312813, 2.72674064, 2.20040351, 2.26697979, 1.07834112, 2.6602285 , 1.60157633]) . np.random.randn() . - N(0,1)에서 10개 추출 . np.random.randn(10) # 표준정규분포에서 10개의 샘플 추출 . array([-0.40371384, 0.56295305, -1.03454983, -0.67628805, -0.89951532, -0.1925445 , 1.43684725, 0.34022492, 0.96763699, -2.0699127 ]) . - N(1,1)에서 10개 추출 . np.random.randn(10)+1 . array([ 0.69440765, -0.58892798, 1.86823224, 1.50473088, 1.56127732, 1.53295801, -0.44982257, 0.41660235, 0.50013233, 3.07135415]) . - N(0,4)에서 10개 추출 (평균이 0이고 분산이 4인 분포) . np.random.randn(10)*2 . array([ 0.48765347, -2.686622 , 6.03529241, 0.52181081, 5.31070099, -1.02246697, -0.3058778 , 0.16147941, -2.11923353, -2.55772141]) . - N(3,4)에서 10개 추출 . np.random.randn(10)*2+3 . array([6.20706555, 3.95308508, 7.02954382, 2.57838168, 3.40580485, 4.37254926, 3.94572032, 2.32058837, 3.74756129, 4.81608642]) . np.random.randint() . - [0,7)의 범위에서 하나의 정수를 랜덤으로 생성 . np.random.randint(7) # [0,7)의 범위에서 하나의 정수 생성 . 2 . - [0,7)의 범위에서 20개의 정수를 랜덤으로 생성 . np.random.randint(7,size=(20,)) # [0,7)의 범위에서 20개의 정수 생성 . array([5, 6, 6, 0, 6, 6, 2, 0, 3, 6, 2, 3, 2, 2, 6, 6, 5, 2, 3, 2]) . - [0,7)의 범위에서 (2,2) shape 으로 정수를 랜덤으로 생성 . np.random.randint(7,size=(2,2)) # [0,7)의 범위에서 (2,2) shape의 정수 생성 . array([[6, 4], [3, 1]]) . - 위와 같은 코드를 아래와 같이 구현가능 . np.random.randint(low=7,size=(5,5)) # [0,7)의 범위에서 (5,5) shape의 정수 생성 . array([[4, 1, 2, 0, 4], [5, 0, 1, 1, 3], [2, 1, 4, 6, 6], [4, 1, 6, 1, 5], [4, 2, 1, 3, 4]]) . - [10,20) 의 범위에서 (5,5) shape 정수를 랜덤으로 생성 . np.random.randint(low=10,high=20,size=(5,5)) # [10,20)의 범위에서 (5,5)shape의 정수생성 . array([[10, 13, 11, 15, 17], [10, 16, 15, 15, 11], [15, 14, 11, 19, 11], [10, 13, 13, 13, 14], [14, 19, 17, 13, 19]]) . - 의문: np.random.randint(low=7,size=(5,5)) 가 좀 이상하다. 사실 np.random.randint(high=7,size=(5,5))가 되어야 맞지 않는가? . -&gt; 저도 그렇게 생각하긴 하는데요, 구현이 이렇게 되어있습니다. 도움말 확인! . Return random integers from the &quot;discrete uniform&quot; distribution of the specified dtype in the &quot;half-open&quot; interval [`low`, `high`). If `high` is None (the default), then results are from [0, `low`). . np.random.choice() . - ver1 . np.random.choice(5,20) # [0,5)에서 20개를 뽑음, 중복허용 . array([1, 1, 4, 3, 0, 2, 4, 4, 4, 4, 0, 4, 2, 2, 2, 2, 2, 1, 4, 1]) . 이것은 np.random.randint(5,size=(20,)) 와 같은 코드임 | . - ver2 . np.random.choice([0,1,2,3],20) # [0,1,2,3]에서 20개를 뽑음, 중복허용 . array([1, 0, 0, 1, 3, 3, 0, 1, 0, 0, 3, 3, 0, 1, 2, 3, 2, 1, 2, 3]) . np.random.choice([&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;],20) . array([&#39;orange&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;banana&#39;], dtype=&#39;&lt;U6&#39;) . np.random.choice([&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;],2,replace=False) # 중복허용 X . array([&#39;banana&#39;, &#39;orange&#39;], dtype=&#39;&lt;U6&#39;) . &#53685;&#44228;&#48516;&#54252; . np.random.binomial(n=10,p=0.2,size=(5,)) # X1, ..., X5 ~ B(10,0.2) . array([0, 1, 4, 1, 3]) . np.random.normal(loc=10,scale=2,size=(5,)) # X1, ..., X5 ~ N(10,4) . array([ 8.33296606, 7.28476525, 10.53464049, 8.70471009, 8.54969039]) . np.radom.randn(5)*2 + 10와 같은코드 | . np.random.uniform(low=2,high=4,size=(5,)) # X1, ..., X5 ~ U(2,4) . array([3.77048793, 2.5993732 , 2.93630494, 2.43154214, 3.63709163]) . np.random.rand(5)*2+2와 같은 코드 | . np.random.poisson(lam=5,size=(5,)) # X1,...,X5 ~ Poi(5) . array([4, 9, 4, 5, 0]) . numpy&#44277;&#48512; 6&#45800;&#44228;: &#44592;&#53440; &#50976;&#50857;&#54620; &#44592;&#48376;&#44592;&#45733;&#46308; . np.where, np.argwhere . - 1차원 . a=np.array([0,0,0,1,0]) a . array([0, 0, 0, 1, 0]) . np.where(a==1) # 조건 a==1을 만족하는 인덱스를 출력하라! . (array([3]),) . np.argwhere(a==1) . array([[3]]) . - 2차원 . np.random.seed(43052) a=np.random.randn(12).reshape(3,4) a . array([[ 0.38342049, 1.0841745 , 1.14277825, 0.30789368], [ 0.23778744, 0.35595116, -1.66307542, -1.38277318], [-1.92684484, -1.4862163 , 0.00692519, -0.03488725]]) . np.where(a&lt;0) # 조건을 만족하는 인덱스가 (1,2), (1,3), (2,0), (2,1), (2,3) 이라는 의미 . (array([1, 1, 2, 2, 2]), array([2, 3, 0, 1, 3])) . np.argwhere(a&lt;0) # 조건을 만족하는 인덱스가 (1,2), (1,3), (2,0), (2,1), (2,3) 이라는 의미 . array([[1, 2], [1, 3], [2, 0], [2, 1], [2, 3]]) . a[np.where(a&lt;0)] # 조건을 만족하는 인덱스가 모두 출력 =&gt; 1차원 array로 출력 . array([-1.66307542, -1.38277318, -1.92684484, -1.4862163 , -0.03488725]) . a[np.argwhere(a&lt;0)] # 출력불가능 . IndexError Traceback (most recent call last) Input In [133], in &lt;cell line: 1&gt;() -&gt; 1 a[np.argwhere(a&lt;0)] IndexError: index 3 is out of bounds for axis 0 with size 3 . a[np.argwhere(a&lt;0)[0][0],np.argwhere(a&lt;0)[0][1]] # 어거지로 출력할수는 있음 . -1.6630754187023522 . - np.where의 특수기능 . np.random.seed(43052) a=np.random.randn(12).reshape(3,4) a . array([[ 0.38342049, 1.0841745 , 1.14277825, 0.30789368], [ 0.23778744, 0.35595116, -1.66307542, -1.38277318], [-1.92684484, -1.4862163 , 0.00692519, -0.03488725]]) . np.where(a&lt;0,0,a) # a&lt;0을 체크 =&gt; 조건에 맞으면 0 =&gt; 조건에 안맞으면 a . array([[0.38342049, 1.0841745 , 1.14277825, 0.30789368], [0.23778744, 0.35595116, 0. , 0. ], [0. , 0. , 0.00692519, 0. ]]) . np.where(a&lt;0,0,1) # a&lt;0을 체크 =&gt; 조건에 맞으면 0 =&gt; 조건에 안맞으면 1 . array([[1, 1, 1, 1], [1, 1, 0, 0], [0, 0, 1, 0]]) . - 요약 . np.where: 인덱스의 좌표를 읽는 가독성은 떨어짐. 그런데 조건에 맞는 원소를 출력하거나 처리하는 (특수기능) 목적으로는 좋은 함수 | np.argwhere: 인덱스의 좌표를 읽는 가독성은 좋은 편임. 그런데 조건에 맞는 원소를 출력하거나 처리하는 기능은 떨어짐 | . &#51064;&#45937;&#49905;&#44256;&#44553; . - 원래 a는 2d array . a=np.arange(12).reshape(3,4) a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . - 경우1: 인덱싱 결과가 1d array로 나올수 있음 . a[0,:] # 인덱싱의 결과 축의 갯수가 바뀐다! 2d array -&gt; 1d array . array([0, 1, 2, 3]) . - 경우2: 물론 인덱싱 결과가 2d array로 나올 수도 있음 . a[[0,1],:] # 이것은 축의 숫자가 유지된다. 2d array -&gt; 2d array . array([[0, 1, 2, 3], [4, 5, 6, 7]]) . - 경우1의 상황에서도 축의 갯수를 유지하면서 인덱싱하려면? . a[[0],:] # 이번에는 인덱싱의 결과 축의 갯수가 유지된다! 2d array -&gt; 2d array . array([[0, 1, 2, 3]]) . a[:,[0]] # . array([[0], [4], [8]]) . - 미묘한 차이를 이해할것 . a[0,:], a[[0],:] . (array([0, 1, 2, 3]), array([[0, 1, 2, 3]])) . a[:,0], a[:,[0]] . (array([0, 4, 8]), array([[0], [4], [8]])) . np.ix_ . - 아래의 인덱싱을 비교하자. . a=np.arange(12).reshape(3,4) a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . a[0:2,0:2] . array([[0, 1], [4, 5]]) . a[[0,1],0:2] . array([[0, 1], [4, 5]]) . a[0:2,[0,1]] . array([[0, 1], [4, 5]]) . - 언뜻 생각하면 위의 결과와 a[[0,1],[0,1]]는 결과가 동일할 것 같다. . a[[0,1],[0,1]] . array([0, 5]) . 실제로는 [a[0,0],a[1,1]]이 array로 나옴 | . - 사실 np.where에서 이미 관찰하였음 . a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . np.where(a % 5 ==0) . (array([0, 1, 2]), array([0, 1, 2])) . a[np.where(a % 5 ==0)] . array([ 0, 5, 10]) . a[[0, 1, 2],[0, 1, 2]] . array([ 0, 5, 10]) . - a[[0,1],[0,1]]이 a[0:2,0:2]를 의미하게 하려면 아래와 같이 하면 된다. . a[np.ix_([0,1],[0,1])] # 유용해보이지만 생각보다 잘 쓰이는건 아님 . array([[0, 1], [4, 5]]) . &#49689;&#51228; . np.random.uniform(low=1.3,high=1.7,size=(10,)) . array([1.42531485, 1.54567744, 1.44735207, 1.33217747, 1.48856969, 1.47329978, 1.38976795, 1.30469965, 1.66634909, 1.65330027]) . 위와 같은코드를 np.random.rand()를 이용하여 구현하라. .",
            "url": "https://guebin.github.io/IP2022/2022/04/13/(7%EC%A3%BC%EC%B0%A8)-4%EC%9B%9413%EC%9D%BC.html",
            "relUrl": "/2022/04/13/(7%EC%A3%BC%EC%B0%A8)-4%EC%9B%9413%EC%9D%BC.html",
            "date": " • Apr 13, 2022"
        }
        
    
  
    
        ,"post19": {
            "title": "(6주차) 4월11일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/6) 2차원 배열과 연립1차 방정식, @의 유연성, 차원 . - (2/6) concat . - (3/6) stack . - (4/6) sum, mean, std, max, min, prod . - (5/6) argmax, argmin, cumsum, cumprod, diff . - (6/6) 숙제설명 . imports . import numpy as np . numpy&#44277;&#48512; 3&#45800;&#44228;: &#52264;&#50896; . 2&#52264;&#50896; &#48176;&#50676;&#44284; &#50672;&#47549; 1&#52264; &#48169;&#51221;&#49885; . - 아래의 연립방정식 고려 . $ begin{cases} y+z+w = 3 x+z+w = 3 x+y+w = 3 x+y+z = 3 end{cases}$ . - 행렬표현? . $ begin{bmatrix} 0 &amp; 1 &amp; 1 &amp; 1 1 &amp; 0 &amp; 1 &amp; 1 1 &amp; 1 &amp; 0 &amp; 1 1 &amp; 1 &amp; 1 &amp; 0 end{bmatrix} begin{bmatrix} x y z w end{bmatrix} = begin{bmatrix} 3 3 3 3 end{bmatrix}$ . - 풀이 . A = np.array([[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]]) A . array([[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) . b= np.array([3,3,3,3]).reshape(4,1) b . array([[3], [3], [3], [3]]) . np.linalg.inv(A) @ b . array([[1.], [1.], [1.], [1.]]) . - 다른풀이 . b를 아래와 같이 만들어도 된다. . b=np.array([3,3,3,3]) b . array([3, 3, 3, 3]) . b.shape # b.shape은 길이가 1인 튜플로 나온다. . (4,) . np.linalg.inv(A) @ b . array([1., 1., 1., 1.]) . @&#51032; &#50976;&#50672;&#49457; . - 엄밀하게는 아래의 행렬곱이 가능하다. . (2,2) @ (2,1) =&gt; (2,1) | (1,2) @ (2,2) =&gt; (1,2) | . A = np.array([1,2,3,4]).reshape(2,2) b = np.array([1,2]).reshape(2,1) A@b . array([[ 5], [11]]) . A.shape, b.shape, (A@b).shape . ((2, 2), (2, 1), (2, 1)) . A = np.array([1,2,3,4]).reshape(2,2) b = np.array([1,2]).reshape(1,2) b@A . array([[ 7, 10]]) . A.shape, b.shape, (b@A).shape . ((2, 2), (1, 2), (1, 2)) . - 당연히 아래는 성립안한다. . A = np.array([1,2,3,4]).reshape(2,2) b = np.array([1,2]).reshape(2,1) b@A . ValueError Traceback (most recent call last) Input In [22], in &lt;cell line: 3&gt;() 1 A = np.array([1,2,3,4]).reshape(2,2) 2 b = np.array([1,2]).reshape(2,1) -&gt; 3 b@A ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 2 is different from 1) . A = np.array([1,2,3,4]).reshape(2,2) b = np.array([1,2]).reshape(1,2) A@b . ValueError Traceback (most recent call last) Input In [23], in &lt;cell line: 3&gt;() 1 A = np.array([1,2,3,4]).reshape(2,2) 2 b = np.array([1,2]).reshape(1,2) -&gt; 3 A@b ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 1 is different from 2) . - 아래는 어떨까? 계산가능할까? $ to$ 모두 계산가능! . (2,) @ (2,2) = (2,) | (2,2) @ (2,) = (2,) | . A = np.array([1,2,3,4]).reshape(2,2) b = np.array([1,2]) A@b . array([ 5, 11]) . A.shape, b.shape, (A@b).shape . ((2, 2), (2,), (2,)) . b를 마치 (2,1)처럼 해석하여 행렬곱하고 결과는 다시 (2,) 로 만든것 같다. | . b@A . array([ 7, 10]) . A.shape, b.shape, (b@A).shape . ((2, 2), (2,), (2,)) . 이때는 $b$를 마치 (1,2)처럼 해석하여 행렬곱하고 결과는 다시 (2,)로 만든것 같다. | . - 아래는 어떠할까? . b1 = np.array([1,2,3,4]) b2 = np.array([1,2,3,4]) b1@b2 . 30 . b1.shape, b2.shape, (b1@b2).shape . ((4,), (4,), ()) . (1,4) @ (4,1) = (1,1) 로 생각 | . - 즉 위는 아래와 같이 해석하고 행렬곱한것과 결과가 같다. . b1 = np.array([1,2,3,4]).reshape(1,4) b2 = np.array([1,2,3,4]).reshape(4,1) b1@b2 . array([[30]]) . b1.shape, b2.shape, (b1@b2).shape . ((1, 4), (4, 1), (1, 1)) . - 때로는 (4,1) @ (1,4)와 같은 계산결과를 얻고 싶을 수 있는데 이때는 차원을 명시해야함 . b1 = np.array([1,2,3,4]).reshape(4,1) b2 = np.array([1,2,3,4]).reshape(1,4) b1@b2 . array([[ 1, 2, 3, 4], [ 2, 4, 6, 8], [ 3, 6, 9, 12], [ 4, 8, 12, 16]]) . &#52264;&#50896; . - 넘파이배열의 차원은 .shape 으로 확인가능 . - 아래는 모두 미묘하게 다르다. . a=np.array(3.14) # 스칼라, 0d array a, a.shape . (array(3.14), ()) . a=np.array([3.14]) # 벡터, 1d array a, a.shape . (array([3.14]), (1,)) . a=np.array([[3.14]]) # 매트릭스, 2d array a, a.shape . (array([[3.14]]), (1, 1)) . a=np.array([[[3.14]]]) # 텐서, 3d array a, a.shape . (array([[[3.14]]]), (1, 1, 1)) . numpy&#44277;&#48512; 4&#45800;&#44228;: &#52629; . np.concatenate . - 기본예제 . a=np.array([1,2]) b=-a . np.concatenate([a,b]) . array([ 1, 2, -1, -2]) . - 응용 . a=np.array([1,2]) b=-a c=np.array([3,4,5]) . np.concatenate([a,b,c]) . array([ 1, 2, -1, -2, 3, 4, 5]) . 여기까진 딱히 칸캐터네이트의 메리트가 없어보임 | 리스트였다면 a+b+c 하면 되는 기능이니까? | . - 2d array에 적용해보자. . a=np.arange(4).reshape(2,2) b=-a . np.concatenate([a,b]) . array([[ 0, 1], [ 2, 3], [ 0, -1], [-2, -3]]) . - 옆으로 붙일려면? . np.concatenate([a,b],axis=1) . array([[ 0, 1, 0, -1], [ 2, 3, -2, -3]]) . - 위의 코드에서 axis=1 이 뭐지? axis=0,2 등을 치면 결과가 어떻게 될까? . np.concatenate([a,b],axis=0) . array([[ 0, 1], [ 2, 3], [ 0, -1], [-2, -3]]) . 이건 그냥 np.concatenate([a,b])와 같다. | np.concatenate([a,b])는 np.concatenate([a,b],axis=0)의 생략버전이군? | . np.concatenate([a,b],axis=2) . AxisError Traceback (most recent call last) Input In [65], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b],axis=2) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis 2 is out of bounds for array of dimension 2 . 이런건 없다. | . - axis의 의미가 뭔지 궁금함. 좀 더 예제를 살펴보자. . a=np.array(range(2*3*4)).reshape(2,3,4) a . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) . b=-a b . array([[[ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . np.concatenate([a,b],axis=0) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23]], [[ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . np.concatenate([a,b],axis=1) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23], [-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . np.concatenate([a,b],axis=2) . array([[[ 0, 1, 2, 3, 0, -1, -2, -3], [ 4, 5, 6, 7, -4, -5, -6, -7], [ 8, 9, 10, 11, -8, -9, -10, -11]], [[ 12, 13, 14, 15, -12, -13, -14, -15], [ 16, 17, 18, 19, -16, -17, -18, -19], [ 20, 21, 22, 23, -20, -21, -22, -23]]]) . 이번에는 axis=2까지 된다? | . np.concatenate([a,b],axis=3) . AxisError Traceback (most recent call last) Input In [75], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b],axis=3) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis 3 is out of bounds for array of dimension 3 . axis=3까지는 안된다? | . - 뭔가 나름의 방식으로 합쳐지는데 원리가 뭘까? . (분석1) np.concatenate([a,b],axis=0) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape, b.shape, np.concatenate([a,b],axis=0).shape . ((2, 3, 4), (2, 3, 4), (4, 3, 4)) . 첫번째차원이 바뀌었다 =&gt; 첫번째 축이 바뀌었다 =&gt; axis=0 (파이썬은 0부터 시작하니까!) | . (분석2) np.concatenate([a,b],axis=1) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape, b.shape, np.concatenate([a,b],axis=1).shape . ((2, 3, 4), (2, 3, 4), (2, 6, 4)) . 두번째차원이 바뀌었다 =&gt; 두번째 축이 바뀌었다 =&gt; axis=1 | . (분석3) np.concatenate([a,b],axis=2) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape, b.shape, np.concatenate([a,b],axis=2).shape . ((2, 3, 4), (2, 3, 4), (2, 3, 8)) . 세번째차원이 바뀌었다 =&gt; 세번째 축이 바뀌었다 =&gt; axis=2 | . (분석4) np.concatenate([a,b],axis=3) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . a.shape, b.shape, np.concatenate([a,b],axis=3).shape . AxisError Traceback (most recent call last) Input In [95], in &lt;cell line: 1&gt;() -&gt; 1 a.shape, b.shape, np.concatenate([a,b],axis=3).shape File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis 3 is out of bounds for array of dimension 3 . 네번째차원이 없다 =&gt; 네번째 축이 없다 =&gt; axis=3으로 하면 에러가 난다. | . (보너스1) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . np.concatenate([a,b],axis=-1) . array([[[ 0, 1, 2, 3, 0, -1, -2, -3], [ 4, 5, 6, 7, -4, -5, -6, -7], [ 8, 9, 10, 11, -8, -9, -10, -11]], [[ 12, 13, 14, 15, -12, -13, -14, -15], [ 16, 17, 18, 19, -16, -17, -18, -19], [ 20, 21, 22, 23, -20, -21, -22, -23]]]) . a.shape, b.shape, np.concatenate([a,b],axis=-1).shape . ((2, 3, 4), (2, 3, 4), (2, 3, 8)) . 마지막 차원이 바뀌었다 =&gt; 마지막 축이 바뀌었다 =&gt; axis = -1 | . (보너스2) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . np.concatenate([a,b],axis=-2) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23], [-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . a.shape, b.shape, np.concatenate([a,b],axis=-2).shape . ((2, 3, 4), (2, 3, 4), (2, 6, 4)) . 마지막에서 2번째 차원이 바뀌었다 =&gt; 마지막에서 2번째 축이 바뀌었다 =&gt; axis = -2 | . (보너스3) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . np.concatenate([a,b],axis=-3) . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23]], [[ 0, -1, -2, -3], [ -4, -5, -6, -7], [ -8, -9, -10, -11]], [[-12, -13, -14, -15], [-16, -17, -18, -19], [-20, -21, -22, -23]]]) . a.shape, b.shape, np.concatenate([a,b],axis=-3).shape . ((2, 3, 4), (2, 3, 4), (4, 3, 4)) . 마지막에서 3번째 차원이 바뀌었다 =&gt; 마지막에서 3번째 축이 바뀌었다 =&gt; axis = -3 | . (보너스3) . a=np.array(range(2*3*4)).reshape(2,3,4) b=-a . np.concatenate([a,b],axis=-4) . AxisError Traceback (most recent call last) Input In [115], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b],axis=-4) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis -4 is out of bounds for array of dimension 3 . 마지막에서 4번째 차원은 없다 =&gt; 마지막에서 4번째 축이 없다 =&gt; axis = -4는 에러가 난다. | . - 0차원은 축이 없으므로 concatenate를 쓸 수 없다. . a= np.array(1) b= np.array(-1) . a.shape, b.shape . ((), ()) . np.concatenate([a,b]) . ValueError Traceback (most recent call last) Input In [127], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b]) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) ValueError: zero-dimensional arrays cannot be concatenated . - 꼭 a,b가 같은 차원일 필요는 없다. . a=np.array(range(4)).reshape(2,2) b=np.array(range(2)).reshape(2,1) . np.concatenate([a,b],axis=1) . array([[0, 1, 0], [2, 3, 1]]) . a.shape, b.shape, np.concatenate([a,b],axis=1).shape . ((2, 2), (2, 1), (2, 3)) . np.stack . - 혹시 아래가 가능할까? . (3,) 결합 (3,) =&gt; (3,2) | . a=np.array([1,2,3]) b=-a . a,b . (array([1, 2, 3]), array([-1, -2, -3])) . np.concatenate([a,b],axis=1) . AxisError Traceback (most recent call last) Input In [151], in &lt;cell line: 1&gt;() -&gt; 1 np.concatenate([a,b],axis=1) File &lt;__array_function__ internals&gt;:5, in concatenate(*args, **kwargs) AxisError: axis 1 is out of bounds for array of dimension 1 . 불가능 | . - 아래와 같이 하면 해결가능 . a=np.array([1,2,3]).reshape(3,1) b=-a . a,b . (array([[1], [2], [3]]), array([[-1], [-2], [-3]])) . np.concatenate([a,b],axis=1) . array([[ 1, -1], [ 2, -2], [ 3, -3]]) . 분석: (3) (3) =&gt; (3,1) (3,1) =&gt; (3,1) concat (3,1) | . - 위의 과정을 줄여서 아래와 같이 할 수 있다. . a=np.array([1,2,3]) b=-a . np.stack([a,b],axis=1) . array([[ 1, -1], [ 2, -2], [ 3, -3]]) . - 아래도 가능 . np.stack([a,b],axis=0) . array([[ 1, 2, 3], [-1, -2, -3]]) . - 분석해보고 외우자 . (분석1) . a=np.array([1,2,3]) b=-a . a.shape, b.shape, np.stack([a,b],axis=0).shape . ((3,), (3,), (2, 3)) . (3) (3) =&gt; 첫 위치에 축을 추가 (axis=0) =&gt; (1,3) (1,3) =&gt; (2,3) | . (분석2) . a=np.array([1,2,3]) b=-a . a.shape, b.shape, np.stack([a,b],axis=1).shape . ((3,), (3,), (3, 2)) . (3) (3) =&gt; 두 위치에 축을 추가 (axis=1) =&gt; (3,1) (3,1) =&gt; (3,2) | . - 고차원예제 . a=np.arange(3*4*5).reshape(3,4,5) b=-a . a.shape, b.shape . ((3, 4, 5), (3, 4, 5)) . np.stack([a,b],axis=0).shape # (3,4,5) =&gt; (1,3,4,5) // 첫 위치에 축이 추가되고 스택 . (2, 3, 4, 5) . np.stack([a,b],axis=1).shape # (3,4,5) =&gt; (3,1,4,5) // 두번째 위치에 축이 추가되고 스택 . (3, 2, 4, 5) . np.stack([a,b],axis=2).shape # (3,4,5) =&gt; (3,4,1,5) // 세번째 위치에 축이 추가되고 스택 . (3, 4, 2, 5) . np.stack([a,b],axis=3).shape # (3,4,5) =&gt; (3,4,5,1) // 네번째 위치에 축이 추가되고 스택 . (3, 4, 5, 2) . np.stack([a,b],axis=-1).shape # axis=-1 &lt;=&gt; axis=3 . (3, 4, 5, 2) . np.stack([a,b],axis=-2).shape # axis=-2 &lt;=&gt; axis=2 . (3, 4, 2, 5) . np.concatenate 는 축의 총 갯수를 유지하면서 결합, np.stack은 축의 갯수를 하나 증가시키면서 결합 . sum . - 1차원 . a = np.array([1,2,3]) a . array([1, 2, 3]) . a.sum() . 6 . a.sum(axis=0) . 6 . - 2차원 . a=np.array(range(6)).reshape(2,3) a . array([[0, 1, 2], [3, 4, 5]]) . a.sum() # 전체합 . 15 . a.sum(axis=0) . array([3, 5, 7]) . a.sum(axis=1) . array([ 3, 12]) . - 2차원 결과 분석 . a.shape, a.sum(axis=0).shape . ((2, 3), (3,)) . 첫번째 축이 삭제됨 =&gt; axis=0 | . a.shape, a.sum(axis=1).shape . ((2, 3), (2,)) . 두번째 축이 삭제됨 =&gt; axis=1 | . - 연습 . a=np.array(range(10)).reshape(5,2) a . array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]) . (문제1) 1열의 합, 2열의 합을 계산하고 싶다면? . (풀이) 차원이 (5,2) =&gt; (2,) 로 나와야 한다. (그럼 첫번째 축이 삭제되어야 하네?) . a.sum(axis=0) . array([20, 25]) . (문제2) 1행의 합, 2행의 합, ... , 5행의 합을 계산하고 싶다면? . (풀이) 차원이 (5,2) =&gt; (5,)로 나와야 한다. (그럼 두번째 축이 삭제되어야 하네?) . a.sum(axis=1) . array([ 1, 5, 9, 13, 17]) . (문제3) a의 모든원소의 합을 계산하고 싶다면? . (풀이) 차원이 (5,2) =&gt; () 로 나와야 한다. (첫번째축, 두번째축이 모두 삭제되어야 하네?) . a.sum(axis=(0,1)) . 45 . a.sum() # 즉 a.sum(axis=(0,1))이 디폴트값임 . 45 . mean, std, max, min, prod . - 모두 sum이랑 유사한 논리 . a=np.array(range(10)).reshape(5,2) a . array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]]) . a.mean(axis=0), a.std(axis=0), a.max(axis=0), a.min(axis=0), a.prod(axis=0) . (array([4., 5.]), array([2.82842712, 2.82842712]), array([8, 9]), array([0, 1]), array([ 0, 945])) . a.mean(axis=1), a.std(axis=1), a.max(axis=1), a.min(axis=1), a.prod(axis=1) . (array([0.5, 2.5, 4.5, 6.5, 8.5]), array([0.5, 0.5, 0.5, 0.5, 0.5]), array([1, 3, 5, 7, 9]), array([0, 2, 4, 6, 8]), array([ 0, 6, 20, 42, 72])) . - 참고로 std는 분포를 n으로 나눈다. . a=np.array([1,2,3,4]) a.std() . 1.118033988749895 . np.sqrt(sum((a-a.mean())**2)/4) . 1.118033988749895 . - 분모를 n-1로 나눌려면? . a=np.array([1,2,3,4]) a.std(ddof=1) . 1.2909944487358056 . np.sqrt(sum((a-a.mean())**2)/3) . 1.2909944487358056 . argmax, argmin . - 1차원 . a= np.array([1,-2,3,10,4]) a . array([ 1, -2, 3, 10, 4]) . a.argmax() # 가장 큰 값이 위치한 원소의 인덱스를 리턴 . 3 . a.argmin() # 가장 작은 값이 위치한 원소의 인덱스를 리턴 . 1 . - 2차원 . np.random.seed(43052) a=np.random.randn(4*5).reshape(4,5) a . array([[ 0.38342049, 1.0841745 , 1.14277825, 0.30789368, 0.23778744], [ 0.35595116, -1.66307542, -1.38277318, -1.92684484, -1.4862163 ], [ 0.00692519, -0.03488725, -0.34357323, 0.70895648, -1.55100608], [ 1.34565583, -0.05654272, -0.83017342, -1.46395159, -0.35459593]]) . a.argmin(), a.min() . (8, -1.9268448358915802) . a.argmax(), a.max() . (15, 1.3456558341738827) . a.argmin(axis=0), a.argmin(axis=1) . (array([2, 1, 1, 1, 2]), array([4, 3, 4, 3])) . a.argmax(axis=0), a.argmax(axis=1) . (array([3, 0, 0, 2, 0]), array([2, 0, 3, 0])) . cumsum, cumprod . - 1차원 . a=np.array([1,2,3,4]) a . array([1, 2, 3, 4]) . a.cumsum() . array([ 1, 3, 6, 10]) . a.cumprod() . array([ 1, 2, 6, 24]) . - 2차원 . a=np.array(range(3*4)).reshape(3,4) a . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) . a.cumsum(axis=0), a.cumsum(axis=1) . (array([[ 0, 1, 2, 3], [ 4, 6, 8, 10], [12, 15, 18, 21]]), array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38]])) . a.cumprod(axis=0), a.cumprod(axis=1) . (array([[ 0, 1, 2, 3], [ 0, 5, 12, 21], [ 0, 45, 120, 231]]), array([[ 0, 0, 0, 0], [ 4, 20, 120, 840], [ 8, 72, 720, 7920]])) . diff . - 1차차분 . a=np.array([1,2,4,6,7]) a . array([1, 2, 4, 6, 7]) . np.diff(a) . array([1, 2, 2, 1]) . - 2차차분 . np.diff(np.diff(a)) . array([ 1, 0, -1]) . - prepend, append . a=np.array([1,2,4,6,7]) a . array([1, 2, 4, 6, 7]) . np.diff(a,prepend=100) #np.diff(np.array([100]+a.tolist()) ) . array([-99, 1, 2, 2, 1]) . [1,2,4,6,7] -&gt; [100,1,2,3,4,6] -&gt; np.diff | . np.diff(a,append=100) #np.diff(np.array(a.tolist()+[100]) ) . array([ 1, 2, 2, 1, 93]) . (예제) a=[1,2,4,6,7]의 앞에 1을 추가하여 차분하라. . np.diff(a,prepend=a[0]) #np.diff(a,prepend=1) . array([0, 1, 2, 2, 1]) . (예제) a=[1,2,4,6,7]의 뒤에 7을 추가하여 차분하라. . np.diff(a,append=a[-1]) #np.diff(a,append=7) . array([1, 2, 2, 1, 0]) . - 2차원 array의 차분 . a=np.arange(24).reshape(4,6) a . array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]]) . np.diff(a,axis=0) . array([[6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6]]) . np.diff(a,axis=1) . array([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) . (숙제) . a=np.arange(24).reshape(4,6) a . array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]]) . 에서 axis=1 옵션으로 np.diff를 적용하여 (4,5) array를 만들고 왼쪽열에 1이 포함된 column을 추가하여 최종 결과가 아래와 같이 되도록 하라. . array([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]) .",
            "url": "https://guebin.github.io/IP2022/2022/04/11/(6%EC%A3%BC%EC%B0%A8)-4%EC%9B%9411%EC%9D%BC.html",
            "relUrl": "/2022/04/11/(6%EC%A3%BC%EC%B0%A8)-4%EC%9B%9411%EC%9D%BC.html",
            "date": " • Apr 11, 2022"
        }
        
    
  
    
        ,"post20": {
            "title": "(5주차) 4월6일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/5) 넘파이공부 1단계: 선언, 기본연산 브로드캐스팅, 기타수학연산지원 . - (2/5) 넘파이공부 2단계: 인덱싱1차원, 인덱싱2차원 . - (3/5) 넘파이공부 2단계: 1차원 배열의 선언 . - (4/5) 넘파이공부 2단계: reshape . - (5/5) 넘파이공부 2단계: 2차원 배열의 선언, 랜덤으로 배열 생성, 행렬관련기능 . import . import numpy as np . &#45336;&#54028;&#51060; &#44277;&#48512; 1&#45800;&#44228; . &#49440;&#50616; . a=np.array([1,2,3]) # list를 만들고 ndarray화 시킴 l=[1,2,3] . &#44592;&#48376;&#50672;&#49328; &#48652;&#47196;&#46300;&#52880;&#49828;&#54021; . a+1 ## [1,2,3] + 1 = [2,3,4] . array([2, 3, 4]) . l+1 . TypeError Traceback (most recent call last) Input In [16], in &lt;cell line: 1&gt;() -&gt; 1 l+1 TypeError: can only concatenate list (not &#34;int&#34;) to list . a*2 . array([2, 4, 6]) . l*2 . [1, 2, 3, 1, 2, 3] . a/2 . array([0.5, 1. , 1.5]) . l/2 . TypeError Traceback (most recent call last) Input In [24], in &lt;cell line: 1&gt;() -&gt; 1 l/2 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . a**2 . array([1, 4, 9]) . l**2 . TypeError Traceback (most recent call last) Input In [26], in &lt;cell line: 1&gt;() -&gt; 1 l**2 TypeError: unsupported operand type(s) for ** or pow(): &#39;list&#39; and &#39;int&#39; . a%2 # %2 = 2로 나눈 나머지를 리턴 a=[1,2,3] . array([1, 0, 1]) . l%2 . TypeError Traceback (most recent call last) Input In [35], in &lt;cell line: 1&gt;() -&gt; 1 l%2 TypeError: unsupported operand type(s) for %: &#39;list&#39; and &#39;int&#39; . &#44592;&#53440;&#49688;&#54617;&#50672;&#49328;&#51648;&#50896; . np.sqrt(a), np.sqrt(l) . (array([1. , 1.41421356, 1.73205081]), array([1. , 1.41421356, 1.73205081])) . np.log(a), np.log(l) . (array([0. , 0.69314718, 1.09861229]), array([0. , 0.69314718, 1.09861229])) . np.exp(a), np.exp(l) . (array([ 2.71828183, 7.3890561 , 20.08553692]), array([ 2.71828183, 7.3890561 , 20.08553692])) . np.sin(a), np.sin(l) . (array([0.84147098, 0.90929743, 0.14112001]), array([0.84147098, 0.90929743, 0.14112001])) . &#45336;&#54028;&#51060; &#44277;&#48512; 2&#45800;&#44228; . &#51064;&#45937;&#49905; 1&#52264;&#50896; . - 선언 . l=[11,22,33,44,55,66] a=np.array(l) . - 인덱스로 접근 . l[0],l[1],l[2],l[3],l[-2],l[-1] . (11, 22, 33, 44, 55, 66) . a[0],a[1],a[2],a[3],a[-2],a[-1] . (11, 22, 33, 44, 55, 66) . - : 이용 (슬라이싱) . l[2:4] # index 2에서 시작, index 4는 포함하지 않음 . [33, 44] . a[2:4] . array([33, 44]) . - 정수배열에 의한 인덱싱 . a . array([11, 22, 33, 44, 55, 66]) . a[[0,2,4]] # index=0, index=2, index=4 에 해당하는 원소를 뽑고 싶다 . array([11, 33, 55]) . l[[0,2,4]] # 리스트는 불가능 . TypeError Traceback (most recent call last) Input In [67], in &lt;cell line: 1&gt;() -&gt; 1 l[[0,2,4]] TypeError: list indices must be integers or slices, not list . - 부울값에 의한 인덱싱 . a . array([11, 22, 33, 44, 55, 66]) . a[[True,False,True,False,True,False]] . array([11, 33, 55]) . 응용하면? . a &lt; 33 . array([ True, True, False, False, False, False]) . a[a&lt;33] . array([11, 22]) . 리스트는 불가능 . l&lt;33 # 여기에서부터 불가능 . TypeError Traceback (most recent call last) Input In [79], in &lt;cell line: 1&gt;() -&gt; 1 l&lt;33 TypeError: &#39;&lt;&#39; not supported between instances of &#39;list&#39; and &#39;int&#39; . l[[True,False,True,False,True,False]] # 이것도 불가능 . TypeError Traceback (most recent call last) Input In [78], in &lt;cell line: 1&gt;() -&gt; 1 l[[True,False,True,False,True,False]] TypeError: list indices must be integers or slices, not list . &#51064;&#45937;&#49905; 2&#52264;&#50896; . - 중첩리스트와 2차원 np.array 선언 . A = [[1,2,3,4],[-1,-2,-3,-4],[5,6,7,8],[-5,-6,-7,-8]] A2 = np.array(A) . A2 . array([[ 1, 2, 3, 4], [-1, -2, -3, -4], [ 5, 6, 7, 8], [-5, -6, -7, -8]]) . A . [[1, 2, 3, 4], [-1, -2, -3, -4], [5, 6, 7, 8], [-5, -6, -7, -8]] . - A의 원소 인덱싱 . A[0][0] # (1,1)의 원소 . 1 . A[1][2] # (2,3)의 원소 . -3 . A[-1][0] # (4,1)의 원소 . -5 . - A2의 원소 인덱싱 . A2[0][0] # (1,1)의 원소 . 1 . A2[1][2] # (2,3)의 원소 . -3 . A2[-1][0] # (4,1)의 원소 . -5 . - A2에서만 되는 기술 (넘파이에서 제시하는 신기술, R에서는 기본적으로 쓰던것, 이중list는 불가능) . A2[0,0] # (1,1)의 원소 . 1 . A2[1,2] # (2,3)의 원소 . -3 . A2[-1,0] # (4,1)의 원소 . -5 . - 정수배열에 의한 인덱싱 &amp; 슬라이싱! . A2 . array([[ 1, 2, 3, 4], [-1, -2, -3, -4], [ 5, 6, 7, 8], [-5, -6, -7, -8]]) . A2[0,0:2] # 1행1열, 1행2열 . array([1, 2]) . A2[0,:] # 1행 . array([1, 2, 3, 4]) . A2[0] # 1행 . array([1, 2, 3, 4]) . A2[[0,2],:] # 1행, 3행 . array([[1, 2, 3, 4], [5, 6, 7, 8]]) . A2[[0,2]] # 1행, 3행 . array([[1, 2, 3, 4], [5, 6, 7, 8]]) . A2[:,0] # 1열 . array([ 1, -1, 5, -5]) . A2[:,[0]] # 1열 . array([[ 1], [-1], [ 5], [-5]]) . A2[:,[0,2]] # 1열, 3열 . array([[ 1, 3], [-1, -3], [ 5, 7], [-5, -7]]) . A2[0:2,[0,2]] # 1행~2행 // 1열,3열 . array([[ 1, 3], [-1, -3]]) . 1&#52264;&#50896; &#48176;&#50676;&#51032; &#49440;&#50616; . - 리스트나 튜플을 선언하고 형변환 . np.array((1,2,3)) # 튜플-&gt;넘파이어레이 . array([1, 2, 3]) . np.array([1,2,3]) # 리스트 -&gt;넘파이어레이 . array([1, 2, 3]) . - range()를 이용해서 선언하고 형변환 . np.array(range(10)) # range(10) -&gt; 넘파이어레이 . array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . - np.zeros, np.ones . np.zeros(3) . array([0., 0., 0.]) . np.ones(4) . array([1., 1., 1., 1.]) . - np.linspace . np.linspace(0,1,12) # 0에서 시작하고 1에서 끝남 (양끝점 모두 포함) . array([0. , 0.09090909, 0.18181818, 0.27272727, 0.36363636, 0.45454545, 0.54545455, 0.63636364, 0.72727273, 0.81818182, 0.90909091, 1. ]) . len(np.linspace(0,1,12)) # 길이는 12 . 12 . - np.arange . np.arange(5) # np.array(range(5)) . array([0, 1, 2, 3, 4]) . np.arange(1,6) # np.array(range(1,6)) . array([1, 2, 3, 4, 5]) . reshape . - reshape: ndarray의 특수한 기능 . a=np.array([11,22,33,44,55,66]) a ## 길이가 6인 벡터 . array([11, 22, 33, 44, 55, 66]) . a.reshape(2,3) ## (2,3) matrix 라고 생각해도 무방 . array([[11, 22, 33], [44, 55, 66]]) . note: reshape은 a자체를 변화시키는것은 아님 . a # a는 그대로 있음 . array([11, 22, 33, 44, 55, 66]) . b= a.reshape(2,3) # a를 reshape한 결과를 b에 저장 b . array([[11, 22, 33], [44, 55, 66]]) . a # a는 여전히 그대로 있음 . array([11, 22, 33, 44, 55, 66]) . - 다시 b를 a처럼 바꾸고 싶다 . b . array([[11, 22, 33], [44, 55, 66]]) . b.reshape(6) # b는 (2,3) matrix , 그런데 이것을 길이가 6인 벡터로 만들고 싶다. . array([11, 22, 33, 44, 55, 66]) . - reshape with -1 . a=np.arange(24) # np.array(range(24)) a . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . a.reshape(2,-1) . array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]]) . a.reshape(3,-1) . array([[ 0, 1, 2, 3, 4, 5, 6, 7], [ 8, 9, 10, 11, 12, 13, 14, 15], [16, 17, 18, 19, 20, 21, 22, 23]]) . a.reshape(4,-1) . array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]]) . a.reshape(5,-1) . ValueError Traceback (most recent call last) Input In [188], in &lt;cell line: 1&gt;() -&gt; 1 a.reshape(5,-1) ValueError: cannot reshape array of size 24 into shape (5,newaxis) . a.reshape(6,-1) . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]) . a.reshape(7,-1) . ValueError Traceback (most recent call last) Input In [190], in &lt;cell line: 1&gt;() -&gt; 1 a.reshape(7,-1) ValueError: cannot reshape array of size 24 into shape (7,newaxis) . a.reshape(8,-1) . array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14], [15, 16, 17], [18, 19, 20], [21, 22, 23]]) . a.reshape(12,-1) . array([[ 0, 1], [ 2, 3], [ 4, 5], [ 6, 7], [ 8, 9], [10, 11], [12, 13], [14, 15], [16, 17], [18, 19], [20, 21], [22, 23]]) . b= a.reshape(12,-1) b . array([[ 0, 1], [ 2, 3], [ 4, 5], [ 6, 7], [ 8, 9], [10, 11], [12, 13], [14, 15], [16, 17], [18, 19], [20, 21], [22, 23]]) . b.reshape(-1) # b를 다시 길이가 24인 벡터로! . array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . 2&#52264;&#50896; &#48176;&#50676;&#51032; &#49440;&#50616; . np.zeros((3,3)) . array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) . np.ones((3,3)) . array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) . np.eye(3) . array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) . np.diag([1,2,3,-1]) . array([[ 1, 0, 0, 0], [ 0, 2, 0, 0], [ 0, 0, 3, 0], [ 0, 0, 0, -1]]) . &#47004;&#45924;&#51004;&#47196; &#48176;&#50676; &#49373;&#49457; . np.random.randn(10) # 표쥰정규분포에서 10개를 뽑음 . array([ 0.27184979, -0.4540305 , 0.24538219, -3.11389327, 1.06478234, 0.12051154, 0.01503231, -0.06744028, 2.30710253, 0.78840453]) . np.random.rand(10) # 0~1사이에서 10개를 뽑음 . array([0.67729671, 0.19584606, 0.4564896 , 0.9308976 , 0.49080792, 0.03410752, 0.47480477, 0.44519947, 0.20608611, 0.85576604]) . np.random.randn(4).reshape(2,2) # 표준정규분포에서 4개를 뽑고 (2,2) ndarray로 형태변환 . array([[-0.97378852, 0.5250826 ], [-0.97400213, -0.59600022]]) . np.random.rand(4).reshape(2,2) # 0~1 4개를 뽑고 (2,2) ndarray로 형태변환 . array([[0.03708309, 0.56122376], [0.80934488, 0.65723348]]) . &#54665;&#47148;&#44288;&#47144;&#44592;&#45733; . A=np.arange(4).reshape(2,2) A . array([[0, 1], [2, 3]]) . A.T # .T는 전치행렬을 구해줌 . array([[0, 2], [1, 3]]) . np.linalg.inv(A) # np.linalg.inv는 역행렬을 구해주는 함수 . array([[-1.5, 0.5], [ 1. , 0. ]]) . A @ np.linalg.inv(A) # @는 행렬곱을 수행 . array([[1., 0.], [0., 1.]]) . &#49689;&#51228; . A=np.array(range(6)) A # 길이가 6인 벡터 . array([0, 1, 2, 3, 4, 5]) . 위와 같이 길이가 6인 벡터 A를 (2,3) ndarray로 변경 (reshape를 이용) . &#52280;&#44256; . - 혹시 행렬을 처음 보시는 학생이 있다면 아래주소의 영상에서 1-4를 학습하시면 됩니다. (1-5까지 있는데 1-4까지만 보시면됩니다) 혹은 스스로 학습하셔도 무방합니다. . https://guebin.github.io/IR2021/2021/10/29/(A2)-%EB%A7%A4%ED%8A%B8%EB%A6%AD%EC%8A%A4.html | . - 행렬을 알고 있다면 위의 주소의 영상은 skip 하셔도 무방합니다. .",
            "url": "https://guebin.github.io/IP2022/2022/04/06/(6%EC%A3%BC%EC%B0%A8)-4%EC%9B%946%EC%9D%BC.html",
            "relUrl": "/2022/04/06/(6%EC%A3%BC%EC%B0%A8)-4%EC%9B%946%EC%9D%BC.html",
            "date": " • Apr 6, 2022"
        }
        
    
  
    
        ,"post21": {
            "title": "(5주차) 4월4일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/7) intro . - (2/7) import 사용방법, 도움말 작성기능 . - (3/7) import 사용시 주의점 . - (4/7) import 고급 . - (5/7) site-packages 1 . - (6/7) site-packages 2 . - (7/7) 모듈, 패키지, 라이브러리, 숙제설명 . intro . - 현재 파이썬은 길이가 2인 벡터의 덧셈을 지원하지 않음 . a=[1,2] b=[3,4] a+b . [1, 2, 3, 4] . - 아래와 같은 기능을 구현하는 함수를 만들고 싶음 . [1,2], [3,4] -&gt; [4,6] . - 구현 . def vec2_add(a,b): return [a[0]+b[0], a[1]+b[1]] . - test . a=[1,2] b=[3,4] . vec2_add(a,b) . [4, 6] . make myfuns.py . - 생각해보니까 vec2_add는 내가 앞으로 자주 쓸 기능임 . - 그런데 현재 사용방법으로는 내가 노트북파일을 새로 만들떄마다 def vec2_add(a,b): 와 같은 형태로 vec2_add를 매번 정의해줘야 하는 불편한이 있다. . &#54644;&#44208;1 . - 자주 사용하는 함수를 myfuns.py에 저장한다. . # myfuns.py def vec2_add(a,b): return [a[0]+b[0], a[1]+b[1]] . - %run myfuns를 실행 . 준비: &quot;00&quot; -&gt; 커널재시작 . %run myfuns . vec2_add([1,2],[3,4]) . [4, 6] . &#54644;&#44208;2 . - 자주 사용하는 함수를 myfuns.py에 저장한다. . # myfuns.py def vec2_add(a,b): return [a[0]+b[0], a[1]+b[1]] . - import myfuns를 이용 . (준비) &quot;00&quot; -&gt; 커널재시작 . import myfuns . a=[1,2] b=[3,4] myfuns.vec2_add(a,b) . [4, 6] . import &#44592;&#48376; . &#49324;&#50857;&#48169;&#48277; . - 사용방법1 . 준비: &quot;00&quot; -&gt; 커널재시작 . import myfuns . myfuns.vec2_add([1,2],[3,4]) . [4, 6] . myfuns.vec2_add 의 의미: myfuns.py 라는 파일안에 vec2_add라는 함수가 있음. 그것을 실행하라. | .의 의미: 상위.하위의 개념! | . (주의) 아래와 같이 사용불가능 하다. . vec2_add([1,2],[3,4]) . NameError Traceback (most recent call last) Input In [3], in &lt;cell line: 1&gt;() -&gt; 1 vec2_add([1,2],[3,4]) NameError: name &#39;vec2_add&#39; is not defined . - 사용방법2 . 준비: &quot;00&quot; -&gt; 커널재시작 . from myfuns import vec2_add . vec2_add([1,2],[3,4]) . [4, 6] . (주의) 이 경우는 오히려 아래가 불가능함 . myfuns.vec2_add([1,2],[3,4]) # myfuns안의 vec2_add만 임포트했지 myfuns자체를 임포트 한것은 아님 . NameError Traceback (most recent call last) Input In [6], in &lt;cell line: 1&gt;() -&gt; 1 myfuns.vec2_add([1,2],[3,4]) NameError: name &#39;myfuns&#39; is not defined . - 사용방법3 . 준비: &quot;00&quot; -&gt; 커널재시작 . import myfuns from myfuns import vec2_add . myfuns.vec2_add([1,2],[3,4]) . [4, 6] . vec2_add([1,2],[3,4]) . [4, 6] . - 사용방법4 . 준비: &quot;00&quot; -&gt; 커널재시작 . from myfuns import vec2_add, vec2_sub . vec2_add([1,2],[3,4]) . [4, 6] . vec2_sub([1,2],[3,4]) . [-2, -2] . - 사용방법5 . 준비: &quot;00&quot; -&gt; 커널재시작 . from myfuns import * #*는 all의 의미 . vec2_add([1,2],[3,4]) . [4, 6] . vec2_sub([1,2],[3,4]) . [-2, -2] . - 사용방법6 . 준비: &quot;00&quot; -&gt; 커널재시작 . import myfuns as mf . mf.vec2_add([1,2],[3,4]) . [4, 6] . mf.vec2_sub([1,2],[3,4]) . [-2, -2] . (오히려 아래는 실행불가능) . myfuns.vec2_add([1,2],[3,4]) . NameError Traceback (most recent call last) Input In [4], in &lt;cell line: 1&gt;() -&gt; 1 myfuns.vec2_add([1,2],[3,4]) NameError: name &#39;myfuns&#39; is not defined . myfuns.vec2_sub([1,2],[3,4]) . NameError Traceback (most recent call last) Input In [5], in &lt;cell line: 1&gt;() -&gt; 1 myfuns.vec2_sub([1,2],[3,4]) NameError: name &#39;myfuns&#39; is not defined . - 잘못된 사용방법1 . 준비: &quot;00&quot; -&gt; 커널재시작 . import myfuns as mf from mf import vec2_add . ModuleNotFoundError Traceback (most recent call last) Input In [1], in &lt;cell line: 2&gt;() 1 import myfuns as mf -&gt; 2 from mf import vec2_add ModuleNotFoundError: No module named &#39;mf&#39; . - 사용방법7 . 준비: &quot;00&quot; -&gt; 커널재시작 . import myfuns as mf from myfuns import vec2_add . mf.vec2_add([1,2],[3,4]) . [4, 6] . vec2_add([1,2],[3,4]) . [4, 6] . - 사용방법8 . 준비: &quot;00&quot; -&gt; 커널재시작 . import myfuns as mf from myfuns import vec2_add as add . mf.vec2_add([1,2],[3,4]) . [4, 6] . vec2_add([1,2],[3,4]) . NameError Traceback (most recent call last) Input In [3], in &lt;cell line: 1&gt;() -&gt; 1 vec2_add([1,2],[3,4]) NameError: name &#39;vec2_add&#39; is not defined . add([1,2],[3,4]) . [4, 6] . &#46020;&#50880;&#47568; &#51089;&#49457;&#44592;&#45733; . - mf란 무엇인가? . 준비: &quot;00&quot; -&gt; 커널재시작 . import myfuns as mf . mf . &lt;module &#39;myfuns&#39; from &#39;/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py&#39;&gt; . mf? . Type: module String form: &lt;module &#39;myfuns&#39; from &#39;/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py&#39;&gt; File: ~/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py Docstring: &lt;no docstring&gt; . type(mf) . module . mf의 타입은 모듈이라고 나옴, 현재 단계에서는 무엇인지 알기 어려움 | . - Docstring의 내용을 채울 수 있을까? . 준비1: myfuns.py 파일을 아래와 같이 수정한다. . 준비2: &quot;00&quot; -&gt; 커널재시작 . import myfuns as mf . mf? . Type: module String form: &lt;module &#39;myfuns&#39; from &#39;/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py&#39;&gt; File: ~/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py Docstring: 이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다. . &#51452;&#51032;&#51216; . - myfuns.py는 최초 한번만 import 된다. . 준비: &quot;00&quot; -&gt; 커널재시작 . import myfuns . myfuns.vec2_add([1,2],[3,4]) . [4, 6] . myfuns.py파일을 열고 함수를 아래와 같이 바꾸자. . &quot;&quot;&quot;이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다.&quot;&quot;&quot; def vec2_add(a,b): print(&quot;이것은 myfuns.py에 정의된 함수입니다&quot;) return [a[0]+b[0], a[1]+b[1]] def vec2_sub(a,b): return [a[0]-b[0], a[1]-b[1]] . 다시 myfuns를 로드하고 myfuns.vec2_add 를 실행하여 보자. . import myfuns . myfuns.vec2_add([1,2],[3,4]) . [4, 6] . 바뀐내용이 적용되지 않는다. . 커널을 다시 시작하고 임포트해보자. . &quot;00&quot; -&gt; 커널재시작 . import myfuns . myfuns.vec2_add([1,2],[3,4]) . 이것은 myfuns.py에 정의된 함수입니다 . [4, 6] . - myfuns.py는 주피터노트북파일과 같은 폴더에 존재해야 한다. . 준비1: &quot;00&quot; -&gt; 커널재시작 . 준비2: myfuns.py을 복사하여 다른 폴더로 이동. 예를들면 IP0403 폴더를 만들고 그 폴더안에 myfuns.py파일을 복사해서 붙여넣은뒤에 파일이름을 myfuns2.py 로 변경. . import myfuns # 주피터노트북파일과 같은 폴더에 있는 myfuns는 잘 로드되지만 . import myfuns2 # 주피터노트북파일과 다른 폴더에 있는 myfuns2는 그렇지 않다. . ModuleNotFoundError Traceback (most recent call last) Input In [4], in &lt;cell line: 1&gt;() -&gt; 1 import myfuns2 ModuleNotFoundError: No module named &#39;myfuns2&#39; . - IP0403 폴더에 있는 myfuns2.py를 실행하기 위해서는 아래와 같이 할 수 있다. . 준비: &quot;00&quot; -&gt; 커널재시작 . from IP0403 import myfuns2 . myfuns2.vec2_add([1,2],[3,4]) . 이것은 myfuns2.py에 정의된 함수입니다 . [4, 6] . - 아래도 가능하다. . 준비: &quot;00&quot; -&gt; 커널재시작 . from IP0403.myfuns2 import vec2_add as add . add([1,2],[3,4]) . 이것은 myfuns2.py에 정의된 함수입니다 . [4, 6] . 참고로 아래는 모두 정의되지 않음 . IP0403.myfuns2.vec2_add([1,2],[3,4]) . NameError Traceback (most recent call last) Input In [3], in &lt;cell line: 1&gt;() -&gt; 1 IP0403.myfuns2.vec2_add([1,2],[3,4]) NameError: name &#39;IP0403&#39; is not defined . myfuns2.vec2_add([1,2],[3,4]) . NameError Traceback (most recent call last) Input In [4], in &lt;cell line: 1&gt;() -&gt; 1 myfuns2.vec2_add([1,2],[3,4]) NameError: name &#39;myfuns2&#39; is not defined . vec2_add([1,2],[3,4]) . NameError Traceback (most recent call last) Input In [5], in &lt;cell line: 1&gt;() -&gt; 1 vec2_add([1,2],[3,4]) NameError: name &#39;vec2_add&#39; is not defined . import &#44256;&#44553; . &#54260;&#45908;&#50752; &#54632;&#44760; &#49324;&#50857;&#54624;&#49884; . - 언뜻 생각하면 아래가 가능할 것 같다. . import IP0403 IP0403.myfuns2.vec2_add([1,2],[3,4]) . - 하지만 불가능하다. . 준비: &quot;00&quot; -&gt; 커널재시작 . import IP0403 . 되는거아냐? | . IP0403.myfuns2.vec2_add([1,2],[3,4]) . AttributeError Traceback (most recent call last) Input In [2], in &lt;cell line: 1&gt;() -&gt; 1 IP0403.myfuns2.vec2_add([1,2],[3,4]) AttributeError: module &#39;IP0403&#39; has no attribute &#39;myfuns2&#39; . 여기서 불가능하다. | . - (암기) IP0403 폴더안에 __init__.py라는 파일을 만들고 내용에 아래와 같이 쓰면 가능하다. . # ./IP0403/__init__.py from . import myfuns2 . 준비1: 위의 지침을 따른다. . 준비2: &quot;00&quot; -&gt; 커널재시작 . import IP0403 . IP0403.myfuns2.vec2_add([1,2],[3,4]) . 이것은 myfuns2.py에 정의된 함수입니다 . [4, 6] . 컴퓨터 상식 . .: 현재폴더를 의미 | ..: 상위폴더를 의미 | ./myfuns.py: 현재폴더안에 있는 myfuns.py를 의미 | ./IP0403/myfuns2.py: 현재폴더만에 IP0403폴더안의 myfuns2.py 파일을 의미 | ../myfuns.py: 현재폴더보다 한단계상위폴더에 있는 myfuns.py를 의미 | cd ./IP0403: 현재폴더안에 있는 IP0403폴더로 이동해라. (cd IP0403으로 줄여쓸 수 있음) | cd .. 현재폴더보다 한단계 상위폴더로 이동하라. | . 따라서 from . import myfuns2는 현재폴더에서 myfuns2를 찾아서 임포트 하라는 의미로 해석가능 . - 의미상으로 보면 아래가 실행가능할듯 한데 불가능하다. . from . import myfuns . ImportError Traceback (most recent call last) Input In [3], in &lt;cell line: 2&gt;() 1 #import myfuns -&gt; 2 from . import myfuns ImportError: attempted relative import with no known parent package . site-packages (&#49892;&#49845;&#44552;&#51648;) . - 의문: 왜 현재폴더에 numpy.py라든가 numpy라는 이름의 폴더가 없는데도 import 가능한지? . 준비: &quot;00&quot; -&gt; 커널재시작 . import numpy as np . import IP0403 as ip . ip? . Type: module String form: &lt;module &#39;IP0403&#39; from &#39;/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/IP0403/__init__.py&#39;&gt; File: ~/Dropbox/07_lectures/IP2022/_notebooks/IP0403/__init__.py Docstring: &lt;no docstring&gt; . np? . Type: module String form: &lt;module &#39;numpy&#39; from &#39;/home/cgb3/anaconda3/envs/py310/lib/python3.10/site-packages/numpy/__init__.py&#39;&gt; File: ~/anaconda3/envs/py310/lib/python3.10/site-packages/numpy/__init__.py Docstring: NumPy ===== Provides 1. An array object of arbitrary homogeneous items 2. Fast mathematical operations over arrays 3. Linear Algebra, Fourier Transforms, Random Number Generation How to use the documentation - Documentation is available in two forms: docstrings provided with the code, and a loose standing reference guide, available from `the NumPy homepage &lt;https://www.scipy.org&gt;`_. We recommend exploring the docstrings using `IPython &lt;https://ipython.org&gt;`_, an advanced Python shell with TAB-completion and introspection capabilities. See below for further instructions. The docstring examples assume that `numpy` has been imported as `np`:: &gt;&gt;&gt; import numpy as np Code snippets are indicated by three greater-than signs:: &gt;&gt;&gt; x = 42 &gt;&gt;&gt; x = x + 1 Use the built-in ``help`` function to view a function&#39;s docstring:: &gt;&gt;&gt; help(np.sort) ... # doctest: +SKIP For some objects, ``np.info(obj)`` may provide additional help. This is particularly true if you see the line &#34;Help on ufunc object:&#34; at the top of the help() page. Ufuncs are implemented in C, not Python, for speed. The native Python help() does not know how to view their help, but our np.info() function does. To search for documents containing a keyword, do:: &gt;&gt;&gt; np.lookfor(&#39;keyword&#39;) ... # doctest: +SKIP General-purpose documents like a glossary and help on the basic concepts of numpy are available under the ``doc`` sub-module:: &gt;&gt;&gt; from numpy import doc &gt;&gt;&gt; help(doc) ... # doctest: +SKIP Available subpackages doc Topical documentation on broadcasting, indexing, etc. lib Basic functions used by several sub-packages. random Core Random Tools linalg Core Linear Algebra Tools fft Core FFT routines polynomial Polynomial tools testing NumPy testing tools f2py Fortran to Python Interface Generator. distutils Enhancements to distutils with support for Fortran compilers support and more. Utilities test Run numpy unittests show_config Show numpy build configuration dual Overwrite certain functions with high-performance SciPy tools. Note: `numpy.dual` is deprecated. Use the functions from NumPy or Scipy directly instead of importing them from `numpy.dual`. matlib Make everything matrices. __version__ NumPy version string Viewing documentation using IPython -- Start IPython with the NumPy profile (``ipython -p numpy``), which will import `numpy` under the alias `np`. Then, use the ``cpaste`` command to paste examples into the shell. To see which functions are available in `numpy`, type ``np.&lt;TAB&gt;`` (where ``&lt;TAB&gt;`` refers to the TAB key), or use ``np.*cos*?&lt;ENTER&gt;`` (where ``&lt;ENTER&gt;`` refers to the ENTER key) to narrow down the list. To view the docstring for a function, use ``np.cos?&lt;ENTER&gt;`` (to view the docstring) and ``np.cos??&lt;ENTER&gt;`` (to view the source code). Copies vs. in-place operation -- Most of the functions in `numpy` return a copy of the array argument (e.g., `np.sort`). In-place versions of these functions are often available as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``. Exceptions to this rule are documented. . - 추측: ~/anaconda3/envs/py310/lib/python3.10/site-packages/를 찾아가보자. 그곳에 numpy폴더가 있을 것이다. . !ls ~/anaconda3/envs/py310/lib/python3.10/site-packages | grep numpy . numpy numpy-1.22.2.dist-info . - 추측2: ~/anaconda3/envs/py310/lib/python3.10/site-packages/에 내가 자주 쓰는 기능을 폴더로 만들어서 모아두면 어디서든지 import 할 수 있다. . !mkdir ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin # guebin 폴더 생성 . !cp ./myfuns.py ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin # 현폴더에 있는 myfuns.py를 아까만든 guebin 폴더로 복사 . from guebin import myfuns . myfuns? . Type: module String form: &lt;module &#39;guebin.myfuns&#39; from &#39;/home/cgb3/anaconda3/envs/py310/lib/python3.10/site-packages/guebin/myfuns.py&#39;&gt; File: ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin/myfuns.py Docstring: 이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다. . !rm ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin -rf # guebin 폴더삭제 . - 추측3: guebin이 사라진 상태에서는 from guebin import myfuns 이 동작하지 않을 것이다. . 준비: &quot;00&quot; -&gt; 커널재시작 . from guebin import myfuns . ModuleNotFoundError Traceback (most recent call last) Input In [1], in &lt;cell line: 1&gt;() -&gt; 1 from guebin import myfuns ModuleNotFoundError: No module named &#39;guebin&#39; . - 추측4: ~/anaconda3/envs/py310/lib/python3.10/site-packages/에서 numpy를 지운다면 numpy를 import할 수 없다. . 준비: &quot;00&quot; -&gt; 커널재시작 . import numpy as np . ModuleNotFoundError Traceback (most recent call last) Input In [1], in &lt;cell line: 1&gt;() -&gt; 1 import numpy as np ModuleNotFoundError: No module named &#39;numpy&#39; . - 추측5: !pip install numpy를 하면 다시 폴더가 생길 것이다. . !pip uninstall numpy -y . Found existing installation: numpy 1.22.2 Uninstalling numpy-1.22.2: Successfully uninstalled numpy-1.22.2 . !pip install numpy . Collecting numpy Downloading numpy-1.22.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (16.8 MB) |████████████████████████████████| 16.8 MB 11.4 MB/s eta 0:00:01 Installing collected packages: numpy Successfully installed numpy-1.22.3 . &#47784;&#46280;, &#54056;&#53412;&#51648;, &#46972;&#51060;&#48652;&#47084;&#47532;? . - 모듈의 개념은 아까 살펴본것과 같다. (import를 하여 생기게 되는 오브젝트) . - 교수님들: 모듈이 모이면 패키지라고 부른다. 그리고 라이브러리는 패키지보다 큰 개념이다. . - 그런데 구분이 모호하다. . import numpy as np . type(np) . module . - python에서의 numpy의 type은 모듈 . - 그런데 numpy package 라고 검색하면 검색이 된다. . - 심지어 numpy library 라고 해도 검색가능 . - 내생각: 넘파이모듈, 넘파이패키지, 넘파이라이브러리 다 맞는 말임 . &#49689;&#51228; . myfuns.py 도움말 만드는 예제에서 . 이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다 . 대신에 . 이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다. (학번: 2022-43052) . 와 같이 출력되도록 하고 스크린샷 제출 .",
            "url": "https://guebin.github.io/IP2022/2022/04/03/(5%EC%A3%BC%EC%B0%A8)-4%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2022/04/03/(5%EC%A3%BC%EC%B0%A8)-4%EC%9B%942%EC%9D%BC.html",
            "date": " • Apr 3, 2022"
        }
        
    
  
    
        ,"post22": {
            "title": "(4주차) 3월23일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 파이썬이 어려웠던 이유 . - (2/8) 1세대 프로그래머 . - (3/8) 1세대 프로그래머의 삶 with python . - (4/8) 1세대 프로그래머의 삶 with ipython . - (5/8) 2세대 프로그래머, 3세대 프로그래머 (1) . - (6/8) 3세대 프로그래머(2), 4세대 프로그래머 . - (7/8) 5세대 프로그래머 . - (8/8) 다양한 개발환경 구축방법 다시 리뷰, 숙제설명 . &#54028;&#51060;&#50028;&#51060; &#50612;&#47140;&#50912;&#45912; &#51060;&#50976; . - 파이썬 배우는 초보자에게 가장 어려운것! . 선생님마다 설치하는 방법이 모두 다름 | . - 왜 저렇게 설치방법이 다른가? 왜 다른 방법으로 각각 파이썬을 실행하는가? 이런것이 너무 어려움 . 방법1: 파이썬프로그램 다운로드 -&gt; 시작버튼 눌러서 설치 | 방법2: 아나콘다 설치 (그럼 자동으로 파이썬이 설치됨) | 방법3: 아나콘다 설치 + 가상환경 | ... | . - 심지어 실행하는것도 다름 . 방법1: 파이썬 프롬프트 | 방법2: .py를 이용하여 실행? | 방법3: IDLE | 방법4: 파이참 | 방법5: 스파이더 | 방법6: Visual Studio Code | 방법7: 주피터노트북, 주피터랩 가상환경을 만들어서 해라.. | 아나콘다 네비게이터에 주피터가 있다.. | . | ... | . - 머리아프니까 collab을 쓰라는 사람도 있음. 아니면 도커이미지를 줄테니까 그걸 쓰라는 사람도 있음. AWS를 쓰라는 사람도 있음.. $ to$ 이게 더 머리아픔 . - 핵심: 그냥 (1) 컴퓨터에 (2) 파이썬을 깔아서 (3) 실행하는 것임 . - 의문: 그런데 방법이 왜이렇게 많은가? 엑셀처럼 프로그램 설치하고 아이콘 더블클릭하면 끝나는 식으로 만들어야 하는것 아닌가? . &#44060;&#48156;&#54872;&#44221; &#44396;&#52629;&#48169;&#48277;&#51060; &#47566;&#51008; &#51060;&#50976;? . - 파이썬 개발환경 구축은 수많은 방법이 있다. . - 이는 마치 라면의 레시피를 검색하면 수많은 방법이 나오는것과 유사함. . 방법1: 스프를 먼저 넣고 끓인다음 라면을 넣어야 합니다. | 방법2: 양은냄비에 물넣고 물이 끊으면 라면과 스프를 같이 넣고 마지막에 계란을 넣는다. | 방법3: 먹다남은 삼겹살을 후라이팬에 볶은다음에 물을 붓고 라면을 넣는다. | 방법4: 용기에 라면+스프+뜨거운물 랩을 씌운뒤에 젓가락으로 구멍을 뚫고 전자렌지에 돌린다. | ... | . - 우리는 모든 방법을 나열할 순 없지만 모든 방법을 이해할 수 있다. 왜냐하면 라면을 끓이는 공통적인 맥락을 우리는 알고 있으니까 . - 파이썬을 설치하는 다양한 방법 역시 공통맥락을 파악하면 이해하기 쉽다. . - 제목적: 파이썬을 설치하고 실행하는 공통맥락을 설명하고 싶음 . - 설치하는 방법이 다양한 이유? 파이썬이 인기있음 + 다양한 방법을 설치를 하면 각자의 장점이 뚜렷해서 . 1&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672; . python . - 윈도우에서 anaconda prompt 실행 -&gt; python . (base) C: Users python&gt;python Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt;&gt;&gt; [1,2,3]+[4] [1, 2, 3, 4] &gt;&gt;&gt; a=[1,2,3]+[4] &gt;&gt;&gt; a [1, 2, 3, 4] . - 2개를 실행할 수도 있음. (두 환경은 각각 서로 독립적인 파이썬, 변수가 공유되지 않음) $ star$ . - 아쉬운점: `?list&#39;와 같이 도움말 기능이 동작하지 않음 . &gt; &gt;&gt; ?list File &quot;&lt;stdin&gt;&quot;, line 1 ?list ^ SyntaxError:invalid syntax&gt;&gt;&gt; . ipython . - 윈도우에서 anaconda prompt 실행 -&gt; ipython . (base) C: Users python&gt;ipython Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] Type &#39;copyright&#39;, &#39;credits&#39; or &#39;license&#39; for more information IPython 7.29.0 -- An enhanced Interactive Python. Type &#39;?&#39; for help. In [1]: a=[1,2,3] In [2]: a Out[2]: [1, 2, 3] In [3]: a+[4] Out[3]: [1, 2, 3, 4] . - ?list가 가능 . In [4]: ?list Init signature: list(iterable=(), /) Docstring: Built-in mutable sequence. If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified. Type: type Subclasses: _HashedSeq, StackSummary, DeferredConfigList, SList, _ImmutableLineList, FormattedText, NodeList, _ExplodedList, Stack, _Accumulator, ... . - 색깔이 알록달록해서 문법을 보기 편하다. (구문강조) . 1&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;&#51032; &#49334; with python . - 1부터 10까지 합을 구하는 프로그램을 만들고 싶음 . - 시도1: python을 키고 아래와 같이 실행 . (base) C: Users python&gt;python Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information. &gt; &gt;&gt; total = 0 &gt;&gt;&gt; for i in range(10):... total=total+i... &gt;&gt;&gt; total 45 &gt;&gt;&gt; . - 반성: 정답은 55인데 45가 출력되었다! $ to$ range(10)을 range(1,11)으로 바꿔야겠다! . - 시도2: range(1,11)을 바꿔야겠다고 생각하고 다시 입력하다가 오타가 발생 . &gt; &gt;&gt; total =0 &gt;&gt;&gt; for i in range(1,11):... total = totla +i... . 앗 totla이라고 잘못쳤다. | . - 반성: 다음에는 정신을 똑바로 차려야겠다. . - 불편한점: ... 다.. . 1&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;&#51032; &#49334; with ipython . - ipython을 사용한 프로그래머는 좀더 상황이 낫다 . (base) C: Users python&gt;ipython Python 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] Type &#39;copyright&#39;, &#39;credits&#39; or &#39;license&#39; for more information IPython 7.29.0 -- An enhanced Interactive Python. Type &#39;?&#39; for help. In [1]: total = 0 In [2]: for i in range(1,11): ...: total = total + i ...: In [3]: total Out[3]: 55 . 편한점1: 자동으로 들여쓰기가 되어서 편함 | 편한점2: 화살표를 이용해서 for문을 쓰는 도중에 위아래로 이동가능 | 불편한점1: 화살표로 이동할수는 있는데 마우스로는 이동할 수 없다. | 불편한점2: 내가 작성한 코드를 관리하기 어렵다. | . 2&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;: &#47700;&#47784;&#51109; + anconda prompt&#47484; &#51060;&#50857; (.py&#47484; &#51060;&#50857;&#54620; python&#54876;&#50857;) . - 메모장을 키고 아래의 내용을 적는다. . total = 0 for i in range(1,11): total = total + i print(total) . - 파일이름을 mysum.py로 저장한다. . - anaconda prompt에서 mysum.py파일이 저장된 폴더로 이동 -&gt; 실행 . (base) C: Users python&gt;cd Desktop (base) C: Users python Desktop&gt;dir C 드라이브의 볼륨에는 이름이 없습니다. 볼륨 일련 번호: 9AFD-A05F C: Users python Desktop 디렉터리 2022-03-27 오전 11:32 &lt;DIR&gt; . 2022-03-27 오전 11:32 &lt;DIR&gt; .. 2022-03-27 오전 12:01 2,306 Chrome.lnk 2022-03-26 오후 08:32 2,332 Microsoft Edge.lnk 2022-03-27 오전 11:33 71 mysum.py 3개 파일 4,709 바이트 2개 디렉터리 743,643,467,776 바이트 남음 (base) C: Users python Desktop&gt;python mysum.py 55 (base) C: Users python Desktop&gt; . - 소감 . 편한점1: 마우스를 이용하여 이동가능 | 편한점2: 내가 작업한 내용은 바탕화면의 메모장에 저장이 되어있음 | 아쉬운점: ipython의 장점은 활용못함 (구문강조, 도움말기능) | . 3&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;: &#47700;&#47784;&#51109; + ipython . - 전체적인 개발방식 . 메모장: 코드를 편집, 저장 | ipython: anaconda prompt처럼 메모장의 코드를 실행하고 결과를 확인 + 구문강조, 도움말확인기능 등을 이용하여 짧은 코드를 빠르게 작성 | . - 기능 . ipython에서 !python mysum.py를 입력하면 anaconda prompt에서 python mysum.py를 입력한 것과 같은 효과 | ipython에서 %run mysum을 입력하면 메모장에서 mysum.py에 입력된 내용을 복사해서 ipython에 붙여넣어 실행한것과 같은 효과 | . 4&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;: IDE(&#53685;&#54633;&#44060;&#48156;&#54872;&#44221;)&#47484; &#49324;&#50857; . - 메모장과 ipython을 하나로 통합한 프로그램이 등장! . jupyter notebook, jupyter lab | spyder | idle | VScode | ... | . - 주피터의 트릭 (실제로 주피터는 ipython에 기생할 뿐 아무런 역할도 안해요) . (1) 주피터를 실행 . (2) 새노트북을 생성 (파이썬으로 선택) . 컴퓨터는 내부적으로 ipython을 실행하고 그 ipython이랑 여러분이 방금만든 그 노트북과 연결 | . (3) 처음보이는 cell에 1+1을 입력 -&gt; 쉬프트엔터 -&gt; 결과2가 출력 . 처음보이는 cell하나 = 자동으로 열린 하나의 메모장 | cell 1+1을 입력 = 메모장에 1+1을 적음 | 쉬프트+엔터후 결과2를 출력 = cell의 내용을 복사 -&gt; ipython에 붙여넣음 -&gt; ipython 계산된 결과를 복사 -&gt; cell로 돌아와 붙여넣기 | . (4) 새로운 cell을 추가하고 2+2을 입력 -&gt; 쉬프트엔터 -&gt; 결과4가 출력 . 새로운 cell을 추가 = 새로운 메모장 추가 | cell 2+2을 입력 = 새로운 메모장에 2+2를 적음 | 쉬프트+엔터후 결과4를 출력 = cell의 내용을 복사 -&gt; ipython에 붙여넣음 -&gt; ipython 계산된 결과를 복사 -&gt; cell로 돌아와 붙여넣기 | . - 중요한 사실들 . IDE는 내부적으로 연산을 수행하는 능력이 없다. (생각해볼것: 왜 R을 꼭 설치하고 Rstudio를 설치해야 했을까?) | 주피터에서 커널을 재시작한다는 의미는 메모장이 열린채로 ipython을 껐다가 다시 실행한다는 의미 | 주피터는 단순히 &#39;메모장의 내용을 복사하여 붙여넣는 기계&#39;라고 볼 수 있다. 이렇게 생각하면 주피터는 꼭 ipython에 연결할 이유는 없다. 실제로 주피터에 R을 연결해서 쓸 수 있다. 즉 하나의 IDE가 여러개의 언어와 연결될 수 있다. | Jupyterlab이라는 프로그램은 크롬에 있는 내용과 ipython간의 통신을 제어하는 프로그램일 뿐이다. | . 5&#49464;&#45824; &#54532;&#47196;&#44536;&#47000;&#47672;: &#44032;&#49345;&#52980;&#54504;&#53552;(anaconda), &#50896;&#44201;&#52980;&#54504;&#53552;(server), &#53364;&#46972;&#50864;&#46300;&#52980;&#54504;&#53552;(colab)&#51032; &#44060;&#45392; &#46321;&#51109; . - 지금까지는 ipython이 실행되는 컴퓨터와 크롬이 실행되는 컴퓨터가 동일하다는 전제였음. . - 생각해보니까 어차피 ipython이 실행된 컴퓨터에서 내가 크롬에 입력한 명령 &quot;전달&quot;되기만 하면 되므로 꼭 같은 컴퓨터일 필요는 없다. . &#47784;&#45944;1: &#50896;&#44201;&#52980;&#54504;&#53552; . - 준비상태 . 전북대컴퓨터: ipython을 실행 + 이 컴퓨터는 인터넷 연결이 되어있어야함 | 우리집노트북: 크롬실행 + 이 컴퓨터도 인터넷이 연결되어 있어야함 | . - 명령입력 . 우리집노트북 크롬에서 1+1을 입력하고 쉬프트 엔터를 누름 | . - 우리집노트북 -&gt; 전북대컴퓨터 . 우리집 노트북의 내부의 어떤프로그램은 1+1이라는 명령을 복사하여 카카오톡으로 전북대 컴퓨터에 전달 | 전북대 컴퓨터의 내부의 어떤프로그램은 1+1이라는 명령을 카톡으로 받아서 그것을 ipython에게 전달 | . - 전북대컴퓨터 -&gt; 우리집노트북 . 전북대컴퓨터 내부의 ipython은 2라는 출력결과를 계산함 | 전북대컴퓨터 내부의 어떤프로그램은 계산결과를 카톡으로 우리집 노트북에 알려줌 | 나는 우리집 노트북에서 계산결과를 받아볼 수 있다. | . &#47784;&#45944;2: &#50896;&#44201;&#52980;&#54504;&#53552; + &#44032;&#49345;&#52980;&#54504;&#53552; . - 준비상태 . 성능좋은 전북대 컴퓨터 1개 | 내 노트북 1개 (그냥 싸고 가벼운거) | 대학원생 아이패드 1개 (그냥 싸고 가벼운거) | . - 아이디어 . 성능좋은 전북대 컴퓨터를 논리적으로 3개로 분리 $ to$ 이를 각각 (base) (py39jl17) (py38r40) 컴퓨터라고 하자. | 나는 (py39jl17)에 접속하여 파이썬 3.9와 줄리아 1.7을 설치한뒤 실습한다. | 대학원생은 (py38r40)에 접속하여 파이썬 3.8과 R 4.0을 설치하고 실습한다. | (base)는 예비용으로 아무것도 설치안한 깨끗한 상태 유지 | 내가 뭘 실수해서 (py39jl17)컴퓨터가 망가졌으나 (py38r40)은 아무 타격없다. | 나는 (py39jl17)를 삭제하고 (base)로 부터 다시 새로운 컴퓨터를 복사하여 (py39jl17)을 다시 만든다. | . &#47784;&#45944;3: &#44032;&#49345;&#52980;&#54504;&#53552; . - 여러분들 사례 . 여러분들의 컴퓨터는 (base), (py39) 2개의 컴퓨터로 나누어져 있음 | 여러분들이 (py39)에만 주피터랩을 설치 | (py39)에 있는 ipython과 여러분의 크롬창이 서로 통신하면서 실습 | 장점: 서로 다른 환경에 서로다른 파이썬과 R등을 설치할 수 있다. $ to$ 패키지간의 충돌이 최소화 (파이썬 입문 수업을 듣고, 이후에 파이썬을 이용하는 어떤수업을 들음) | . &#47784;&#45944;4: &#53364;&#46972;&#50864;&#46300; . - 사례1 . 성능이 그저그런 컴퓨터 27개 | 대학원생을 포함하여 쓸 사람은 5명 | 한사람당 27/5(=5.4)대의 컴퓨터식 할당 | . - 사례2: 구글코랩 . 구글에 여러가지 성능을 가진 컴퓨터가 $n$대 있음 | $m$명의 사람이 $n$대의 컴퓨터에 접속 | 적당히 컴퓨터 자언을 분배하여 사용 | . &#50836;&#50557; &#48143; &#51221;&#47532; . - 결국 (1) 컴퓨터에 (2) 파이썬을 설치하고 (3) 실행하는 과정은 생각보다 다양한 선택의 조합이 가능하다. . (1) 그냥 내 노트북에 파이썬을 설치할지? 내 노트북안에 가상컴퓨터를 만들고 거기에 파이썬을 설치할지? 학교의 데스크탑에 파이썬을 설치하고 쓸지? 설치를 안하고 구글컴퓨터에 설치된 파이썬을 난 쓰기만 할지? . (2) python설치할지? ipython를 설치할지? 어차피 가상환경을 쓸꺼니가 anaconda를 설치할지? 아니면 코랩쓸꺼니까 설치안할지? . (3) 어떤 IDE를 쓸지? IDE를 쓰지 않을지? 내가 IDE를 직접구성해서 만들지? . 하지만 공통적으로 관통하는 원리가 있다 . &#49689;&#51228; . - 주피터랩에서 &#39;myprod.py&#39;파일을 만들고 1부터 5까지의 곱을 계산하는 코드를 작성후 %run myprod를 실행하여 출력결과를 확인 .",
            "url": "https://guebin.github.io/IP2022/2022/03/28/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9428%EC%9D%BC.html",
            "relUrl": "/2022/03/28/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9428%EC%9D%BC.html",
            "date": " • Mar 28, 2022"
        }
        
    
  
    
        ,"post23": {
            "title": "(4주차) 3월23일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) 딕셔너리 연산, 메소드 . - (2/4) 딕셔너리 연산, 메소드 (2) . - (3/4) 딕셔너리 고급 . - (4/4) 집합 . &#46357;&#49492;&#45320;&#47532; . &#50672;&#49328; . - 하나있어요.. . score = {&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . &#39;guebin&#39; in score . True . &#39;iu&#39; in score . True . &#39;hynn&#39; in score . False . - in은 사실 다른자료형도 가능했음 . (관찰1) . &#39;a&#39; in &#39;guebin&#39; . False . &#39;b&#39; in &#39;guebin&#39; . True . &#39;c&#39; in &#39;guebin&#39; . False . (관찰2) . tpl = 1,2,3 tpl . (1, 2, 3) . 1 in tpl . True . 4 in tpl . False . (관찰3) . score = [[&#39;guebin&#39;,49],[&#39;iu&#39;,80],[&#39;hynn&#39;,99]] score . [[&#39;guebin&#39;, 49], [&#39;iu&#39;, 80], [&#39;hynn&#39;, 99]] . [&#39;guebin&#39;,49] in score . True . - in연산자가 dict형에 사용되면 key를 기준으로 True, False를 판단한다. . &#47700;&#49548;&#46300; . (get) . score = {&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . score.get(&#39;guebin&#39;) . 49 . 아래와 같은 기능 . score[&#39;guebin&#39;] . 49 . 미묘한 차이점이 존재함 . score[&#39;hynn&#39;] # hynn이 없어서 키에러 출력, 그런 key는 없다.. . KeyError Traceback (most recent call last) Input In [17], in &lt;cell line: 1&gt;() -&gt; 1 score[&#39;hynn&#39;] KeyError: &#39;hynn&#39; . score.get(&#39;hynn&#39;) # hynn이 없으면 아무것도 출력안함 . (keys,values,items) . - .keys()는 딕셔너리의 키를 리턴한다. . score = {&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . _keys=score.keys() _keys . dict_keys([&#39;guebin&#39;, &#39;iu&#39;]) . type(_keys) # 리턴된 자료형은 이상한것임 . dict_keys . list(_keys) # 아무튼 그 이상한 자료형도 리스트화 가능 . [&#39;guebin&#39;, &#39;iu&#39;] . - .values()는 딕셔너리의 값들을 리턴한다. . _values =score.values() _values . dict_values([49, 80]) . type(_values) . dict_values . list(_values) . [49, 80] . - .items()는 딕셔너리의 (키,값)을 리턴한다. . _items = score.items() _items . dict_items([(&#39;guebin&#39;, 49), (&#39;iu&#39;, 80)]) . type(_items) . dict_items . list(_items) . [(&#39;guebin&#39;, 49), (&#39;iu&#39;, 80)] . - for문에서의 dict . (예시1) . for i in score.keys(): print(i) . guebin iu . for i in score: print(i) . guebin iu . 딕셔너리 그자체도 for문에 넣을 수 있다. | i에는 value가 삭제되어 들어간다. (즉 key만) | 결과를 보면 score대신에 score.keys()와 list(score)를 넣었을때와 결과가 같다. | . . Note: list(score) 하면 key만 리턴된다. . (예시2) . for i in score.values(): print(i) . 49 80 . (예시3) . for k in score.items(): print(k) . (&#39;guebin&#39;, 49) (&#39;iu&#39;, 80) . (예시4) . for i,j in score.items(): print(i,j) . guebin 49 iu 80 . (예시5) . for i,j in score.items(): print(i + &#39;의 중간고사 점수는 %s점 입니다.&#39; % j) . guebin의 중간고사 점수는 49점 입니다. iu의 중간고사 점수는 80점 입니다. . [보충학습] 문자열 새치기 . &#39;제 이름은 %s입니다&#39; % &#39;최규빈&#39; . &#39;제 이름은 최규빈입니다&#39; . %는 새치기연산자임. %s는 새치기하는 자리라고 생각 | . 보충학습끝 . &#46357;&#49492;&#45320;&#47532; &#44256;&#44553; . &#53412;&#45716; &#47928;&#51088;&#50676;&#47564; &#44032;&#45733;&#54620; &#44163;&#51060; &#50500;&#45768;&#45796;. . - 정수키 . score = {0:49, 1:80, 2:99} # key를 0,1,2로 score . {0: 49, 1: 80, 2: 99} . - 인덱싱은? . score[0] # 키로 인덱싱을 하고 있는데 마치 원소의 위치로 인덱싱을 하는 기분 . 49 . - 그럼 혹시 이것도? . score[:2] . TypeError Traceback (most recent call last) Input In [79], in &lt;cell line: 1&gt;() -&gt; 1 score[:2] TypeError: unhashable type: &#39;slice&#39; . score[-1] # 이것도 될리가 없죠.. . KeyError Traceback (most recent call last) Input In [81], in &lt;cell line: 1&gt;() -&gt; 1 score[-1] KeyError: -1 . &#53412;&#47196;&#44032;&#45733;&#54620;&#44163;? &#47928;&#51088;&#50676;, &#49707;&#51088;&#44050;, &#53916;&#54540; . score = {(&#39;guebin&#39;,0): 10, (&#39;guebin&#39;,1): 20, (&#39;guebin&#39;,2):49} # 0은 출석점수, 1은 레포트 점수, 2는 중간고사 점수 score . {(&#39;guebin&#39;, 0): 10, (&#39;guebin&#39;, 1): 20, (&#39;guebin&#39;, 2): 49} . score[(&#39;guebin&#39;,0)] . 10 . score[&#39;guebin&#39;,2] . 49 . score[(&#39;guebin&#39;,3)] = 99 # 규빈의 기말고사 점수를 추가 . score . {(&#39;guebin&#39;, 0): 10, (&#39;guebin&#39;, 1): 20, (&#39;guebin&#39;, 2): 49, (&#39;guebin&#39;, 3): 99} . 문자열, 숫자값, 튜플의 공통점? 불변객체 | . &#52280;&#44256; (&#48520;&#48320;&#54805;&#44284; &#44032;&#48320;&#54805;) . (인트형은 불변) . a=1 a,id(a) . (1, 140554269835504) . a=2 a,id(a) . (2, 140554269835536) . (문자열도 불변) . a=&#39;guebin&#39; a,id(a) . (&#39;guebin&#39;, 140553659148336) . a=&#39;Guebin&#39; a,id(a) . (&#39;Guebin&#39;, 140553649883440) . (리스트는 가변) . a=list(&#39;guebin&#39;) a,id(a) . ([&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;], 140553645841408) . a[0]=&#39;G&#39; . a,id(a) . ([&#39;G&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;], 140553645841408) . &#51665;&#54633; . &#49440;&#50616; . a={&#39;notebook&#39;,&#39;desktop&#39;} . &#50896;&#49548;&#52628;&#52636; . - 일단 인덱스로는 못합니다. . a={&#39;notebook&#39;,&#39;desktop&#39;} a[0] . TypeError Traceback (most recent call last) Input In [132], in &lt;cell line: 2&gt;() 1 a={&#39;notebook&#39;,&#39;desktop&#39;} -&gt; 2 a[0] TypeError: &#39;set&#39; object is not subscriptable . - 딱히 하는 방법이 없어요.. 그리고 이걸 하는 의미가 없어요.. (원소에 접근해서 뭐하려고??) . &#50896;&#49548;&#52628;&#44032; . - 이건 의미가 있죠 . a={&#39;notebook&#39;,&#39;desktop&#39;} a . {&#39;desktop&#39;, &#39;notebook&#39;} . a.add(&#39;ipad&#39;) a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . a.add(&#39;notebook&#39;) # 이미 원소로 있는건 추가되지 않음. a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . &#50896;&#49548;&#49325;&#51228; . a={&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . a.remove(&#39;notebook&#39;) . a . {&#39;desktop&#39;, &#39;ipad&#39;} . &#50672;&#49328; . - in 연산자 . a={&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} a . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . &#39;notebook&#39; in a . True . 참고로 in연산자는 집합에서만 쓰는것은 아님 | . - 합집합, 교집합, 차집합 . day1 = {&#39;notebook&#39;,&#39;desktop&#39;} day2 = {&#39;notebook&#39;,&#39;ipad&#39;} . day1 | day2 # 합집합 . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . day1 &amp; day2 # 교집합 . {&#39;notebook&#39;} . day1 - day2 # 차집합 . {&#39;desktop&#39;} . day2 - day1 # 차집합 . {&#39;ipad&#39;} . - 부분집합 . day1 = {&#39;notebook&#39;, &#39;desktop&#39;} day2 = day1 | {&#39;ipad&#39;} . day1 &lt; day2 # day1는 day2의 부분집합인가? . True . day2 &lt; day1 . False . &#47700;&#49548;&#46300; . - 합집합 . day1 = {&#39;notebook&#39;, &#39;desktop&#39;} day2 = {&#39;notebook&#39;,&#39;ipad&#39;} . day1.union(day2) . {&#39;desktop&#39;, &#39;ipad&#39;, &#39;notebook&#39;} . - 나머지 메소드는 스스로 찾아보세요 . for&#47928; . day1 = {&#39;notebook&#39;, &#39;desktop&#39;} day2 = {&#39;notebook&#39;,&#39;ipad&#39;} . for i in day1|day2: print(i) . ipad notebook desktop . &#49689;&#51228; . 길이가 4인 집합을 두개만들고 공통원소를 2개로 설정한뒤 합집합을 구하는 코드를 작성하라. .",
            "url": "https://guebin.github.io/IP2022/2022/03/23/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9423%EC%9D%BC.html",
            "relUrl": "/2022/03/23/(4%EC%A3%BC%EC%B0%A8)-3%EC%9B%9423%EC%9D%BC.html",
            "date": " • Mar 23, 2022"
        }
        
    
  
    
        ,"post24": {
            "title": "(3주차) 3월21일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/7) 튜플을 쓰는 이유 . - (2/7) 인덱스고급: 스트라이딩 (1) . - (3/7) 인덱스고급: 스트라이딩 (2) . - (4/7) 컴프리헨션고급 (if문이 포함된 컴프리헨션) . - (5/7) 함수고급 (조건부리턴), len함수 . - (6/7) summary of str/list/tupel, 딕셔너리 (모티브, 선언, 원소추출, 원소추가, 원소변경, 삭제) . - (7/7) 숙제설명 . some minor comments: str, list, tuple . (&#47532;&#49828;&#53944;&#44032; &#50500;&#45768;&#44256;) &#53916;&#54540;&#51012; &#50416;&#45716; &#51060;&#50976; . - 책의 설명 (이 설명이 꼭 파이썬에 한정되는 것은 아님. 모든 언어에 존재하는 불변형 객체에 적용가능한 설명) . 실수방지 | 빠르다, 다중작업에 유리하다, 여러사람과 작업하기에 유리하다, 깊은복사/얕은복사시 원하지않는 오류(side effect이라고 함)를 방지할 수 있다, 메모리관리에도 유리함... | 느낌: 불변형은 기능제한이 있는데 가볍고 빠른, 가변형은 기능은 풍부하지만 약간 느리고 무거운 느낌임 (불변형:라면사리, 가변형:라면) | . - 내 설명 . 튜플의 장점은 소괄호의 생략에 있음 (이것은 파이썬과 줄리아만 가능) | 이것이 언패킹구문과 결합하여 어마무시한 가독성을 제공 | . def mycal(a,b): return a+b, a-b, a*b, a/b #여러개의 값을 리턴하는듯 보임. -&gt; 사실은 길이가 4인 튜플 1개를 리턴 . mycal(2,3) . (5, -1, 6, 0.6666666666666666) . _, _, mulrslt, _ = mycal(2,3) # 병렬할당 . mulrslt . 6 . - 의문: 왜 튜플만 괄호를 생략할 수 있지? . - 내망상 . 튜플을 먼저 만들고, 괄호를 생략하는 문법을 추가한것은 아닐것임 | 원래 괄호없이 컴마만 대충찍어서 선언가능한 아주간단한 타입의 벡터형을 만들고 싶었을 것임. | 왜? 괄호없는 벡터를 만들고 + 언패킹을 사용하면 여러가지 구문들이 엄청나게 간단해짐. | 컴마컴마로 선언하는 벡터는 한 두번 쓰고 버리는 경우가 많으며 대부분 이름도 필요없음 $ to$ 원소에 접근해서 sorting하여 순서를 바꾸고 싶다던가 원소를 추가할 이유가 없음 $ to$ 비싼 가변형으로 만들 이유가 없다는 것.. | 우리가 필요한것: 데이터가 벡터의 형태로 모여있기만 하면 된다! | . - 다른사람들 의견 (컴공과 인터뷰) . 튜플 + 언패킹에 충격 $ to$ 파이썬 편하더라.. | . &#51064;&#45937;&#49905;&#44256;&#44553; (&#49828;&#53944;&#46972;&#51060;&#46377;) . - 스트라이딩 [start:stop:step] . lst = list(&#39;abcdefgh&#39;) lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst[0:8:2] . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . - 생략 . lst[::2] . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . lst[0::2] . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . lst[:8:2] . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . - 예제: 짝수/홀수 원소 추출 . lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst[::2] # 1,3,5,7, ... . [&#39;a&#39;, &#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . lst[1::2] # 2,4,6,8, ... . [&#39;b&#39;, &#39;d&#39;, &#39;f&#39;, &#39;h&#39;] . - step = -1 이면? . lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst[::-1] . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . reverse와 같은 기능 | . (reverse)와 비교 . 관찰1: reverse 메소드는 리스트 자체를 변화시킴 . lst = list(&#39;abcdefgh&#39;) lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst.reverse() #리버스는 lst . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . 관찰2: [::-1]는 리스트는 변화시키지 않음 . lst = list(&#39;abcdefgh&#39;) lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . lst[::-1] . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . lst . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] . - 사실 -step은 쓰는 것이 조금 까다롭다. . (예제) 처음과 끝을 생략하지 않고 아래와 동일한 효과를 주는 코드를 만들어 보자. . lst = list(&#39;abcdefgh&#39;) lst[::-1] . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . (풀이) . 결국 lst[?:?:-1]의 꼴에서 적당히 ?의 값을 채우면 된다. . lst[-1::-1] # 일단 첫 시작은 제일 마지막 원소 . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . lst[-1:0:-1] # 앗 마지막 인덱스는 포함 안되는거였지? . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;] . lst[-1:-1:-1] # 앗 마지막 인덱스는 포함 안되는거였지? . [] . 잠깐 인덱스를 생각해보자. . a b c d e f g h . 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | . -8 | -7 | -6 | -5 | -4 | -3 | -2 | -1 | . lst[-1:-9:-1] # 아.. . [&#39;h&#39;, &#39;g&#39;, &#39;f&#39;, &#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] . (예제) . lst[2::2] . [&#39;c&#39;, &#39;e&#39;, &#39;g&#39;] . lst[-2::-2] . [&#39;g&#39;, &#39;e&#39;, &#39;c&#39;, &#39;a&#39;] . lst[-2:2:2] . [] . lst[2:2:2] . [] . lst[2:2:-2] . [] . 결론: -step을 자주 쓰진 말자? . &#52980;&#54532;&#47532;&#54760;&#49496; &#44256;&#44553; (if&#47928;&#51060; &#54252;&#54632;&#46108; &#52980;&#54532;&#47532;&#54760;&#49496;) . - 예제: 제곱수중에서 12로 나누어 떨어지는 수만 원소로 가지는 리스트를 만들고 싶다. . 제곱수: 1,4,9,16,25,36, ... | 12로 나누어 떨어지는 수: 36, ... | . (예비학습) . 12 % 4 # %는 나머지를 계산하는 연산자, 12를 4로 나누면 나머지가 0 . 0 . 12 % 5 # %는 나머지를 계산하는 연산자, 12를 5로 나누면 나머지가 2 . 2 . (풀이1) . lst = [] for i in range(1,101): if (i**2 % 12 == 0): lst.append(i**2) . lst . [36, 144, 324, 576, 900, 1296, 1764, 2304, 2916, 3600, 4356, 5184, 6084, 7056, 8100, 9216] . (풀이2) . [i**2 for i in range(1,101) if (i**2 % 12 == 0)] . [36, 144, 324, 576, 900, 1296, 1764, 2304, 2916, 3600, 4356, 5184, 6084, 7056, 8100, 9216] . &#54632;&#49688;&#44256;&#44553; (&#51312;&#44148;&#48512;&#47532;&#53556;) . - 홀수/짝수를 판별하는 함수 만들기 1 . def test(a): if a % 2 ==0: return &#39;even&#39; else: return &#39;odd&#39; . test(1) . &#39;odd&#39; . test(2) . &#39;even&#39; . test(3) . &#39;odd&#39; . test(4) . &#39;even&#39; . [test(a) for a in range(1,11)] . [&#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;] . - 홀수/짝수를 판별하는 함수 만들기 2 . def test(a): return &#39;even&#39; if a%2 ==0 else &#39;odd&#39; . test(3) . &#39;odd&#39; . [test(a) for a in range(1,11)] . [&#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;, &#39;odd&#39;, &#39;even&#39;] . len&#54632;&#49688; . - 0차원 자료형은 len함수가 동작하지 않음 . a=1 len(a) . TypeError Traceback (most recent call last) Input In [44], in &lt;cell line: 2&gt;() 1 a=1 -&gt; 2 len(a) TypeError: object of type &#39;int&#39; has no len() . a=True len(a) . TypeError Traceback (most recent call last) Input In [45], in &lt;cell line: 2&gt;() 1 a=True -&gt; 2 len(a) TypeError: object of type &#39;bool&#39; has no len() . a=3.14 len(a) . TypeError Traceback (most recent call last) Input In [46], in &lt;cell line: 2&gt;() 1 a=3.14 -&gt; 2 len(a) TypeError: object of type &#39;float&#39; has no len() . . Note: 이것이 어떠한 수학적인 의미를 가지거나 0차원의 본질적진리를 뜻하는 것은 안미. R에서는 1,3.14,TRUE의 길이가 1로 존재함. . - 1차원 자료형은 len함수가 동작 . a=&#39;guebin&#39; len(a) . 6 . a=[1,2,3,4,5,6] len(a) . 6 . a=1,2,3,4,5,6 len(a) . 6 . a=range(10) len(a) . 10 . - 길이가 1인 1차원 자료형과 0차원 자료형은 다른것임 . a=&#39;g&#39; len(a) . 1 . a=[1] len(a) . 1 . a=(1,) len(a) . 1 . a=range(1) len(a) . 1 . - 길이가 0인 1차원 자료형도 존재함 . a=&#39;&#39; len(a) . 0 . a=[] len(a) . 0 . a=() len(a) . 0 . a=range(0) len(a) . 0 . summary: str, list, tuple . - str, list, tuple은 모두 시퀀스형이라는 공통점이 있다. $ to$ 원소의 위치번호로 인덱싱이 가능 . lst = [1,2,3,4] . lst[0] # 위치번호=0 . 1 . lst[-1] # 위치번호=-1 . 4 . - str, list, tuple은 차이점도 존재함. 잠깐 정리해보자. . 시퀀스형의 카테고리 . 컨테니어형: list, tuple | 균일형: str | 가변형: list | 불변형: tuple, str | . 표로 정리하면 . 컨테니어형 균일형 . 가변형 | list | . | . 불변형 | tuple | str | . - 시퀀스형이 아닌 1차원 자료형도 있을까? 원소의 위치번호로 인덱싱이 불가능한 자료형 . - 왜 이런게 필요할까? . 벡터에서 원소를 뽑는것은 정보의 모임에서 정보를 검색하는 것과 같다. | 정보를 순서대로 나열한뒤에 그 순서를 이용하여 검색하는 방법은 유용하다. | 하지만 경우에 따라서는 키워드를 기억해서 그 키워드를 바탕으로 정보에 접근하는 방법이 유용할 수 있다. | . 카카오톡 대화내용검색 . (상황1) 오늘아침에 와이프가 뭔가를 카톡으로 부탁했었음. 그런데 그 뭔가가 기억안남. . (상황2) 개강전에 동료교수와 함께 저녁약속을 카톡으로 잡았었음. 그런데 그게 언제인지 기억안남. . (상황3) 오늘아침 동료교수와 함께 점심약속을 카톡으로 잡았었음. 그런데 그 장소가 기억나지 않음. . - 순서대로 정리된 자료를 검색할때는 시퀀스형이 유리하다. 그런데 키워드로 검색하고 싶을 경우는 딕셔너리 타입이 유리하다. . &#46357;&#49492;&#45320;&#47532; . &#49440;&#50616; . - 방법1 . score={&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . type(score) . dict . - 방법2 . score=dict(guebin=49, iu=80) score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . type(score) . dict . - 방법3 . _lst = [[&#39;guebin&#39;,49],[&#39;iu&#39;,80]] _lst . [[&#39;guebin&#39;, 49], [&#39;iu&#39;, 80]] . dict(_lst) . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . - 방법4 . _tpl = (&#39;guebin&#39;,49), (&#39;iu&#39;,80) _tpl . ((&#39;guebin&#39;, 49), (&#39;iu&#39;, 80)) . dict(_tpl) . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . &#50896;&#49548;&#52628;&#52636; . score = {&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . guebin의 점수를 추출하고 싶다면? . score[0] # 이렇게 뽑는것이 아니고! . KeyError Traceback (most recent call last) Input In [71], in &lt;cell line: 1&gt;() -&gt; 1 score[0] KeyError: 0 . score[&#39;guebin&#39;] . 49 . - 리스트로 저장했다면? . score=[[&#39;guebin&#39;,49],[&#39;iu&#39;,80]] score . [[&#39;guebin&#39;, 49], [&#39;iu&#39;, 80]] . guebin의 점수를 추출하고 싶다면? . (방법1) . score[0][1] # guebin의 점수를 출력하란 의미 . 49 . (방법2) . _keys = [score[i][0] for i in range(len(score))] # 리스트컴프리헨션 _keys . [&#39;guebin&#39;, &#39;iu&#39;] . [score[i][1] for i in range(len(score)) if score[i][0] ==&#39;guebin&#39; ] . [49] . 어지럽죠? | . &#50896;&#49548;&#52628;&#44032;, &#48320;&#44221;, &#49325;&#51228; . score={&#39;guebin&#39;:49, &#39;iu&#39;:80} score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80} . - 원소에 접근 . score[&#39;guebin&#39;] . 49 . - 추가 . score[&#39;hynn&#39;] = 99 # 추가 score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 80, &#39;hynn&#39;: 99} . - 변경 . score[&#39;iu&#39;] = 99 # 변경 score . {&#39;guebin&#39;: 49, &#39;iu&#39;: 99, &#39;hynn&#39;: 99} . - 삭제 . (방법1) . score={&#39;guebin&#39;:49, &#39;iu&#39;:80, &#39;hynn&#39;:99} del score[&#39;guebin&#39;] score . {&#39;iu&#39;: 80, &#39;hynn&#39;: 99} . (방법2) . score={&#39;guebin&#39;:49, &#39;iu&#39;:80, &#39;hynn&#39;:99} score.pop(&#39;guebin&#39;) . 49 . score . {&#39;iu&#39;: 80, &#39;hynn&#39;: 99} . - 참고로 리스트였다면 이러한 삭제작업역시 비효율적이었을 것임 . score = [[&#39;guebin&#39;,49],[&#39;iu&#39;,80],[&#39;hynn&#39;,99]] score . [[&#39;guebin&#39;, 49], [&#39;iu&#39;, 80], [&#39;hynn&#39;, 99]] . score = [[key,val] for key,val in score if key != &#39;guebin&#39;] score . [[&#39;iu&#39;, 80], [&#39;hynn&#39;, 99]] . (숙제) 길이가 4인 dictionary를 생성 . len 함수를 이용하여 길이를 측정 | key를 이용하여 각 원소에 접근하여 보기 | .",
            "url": "https://guebin.github.io/IP2022/2022/03/21/(3%EC%A3%BC%EC%B0%A8)-3%EC%9B%9421%EC%9D%BC.html",
            "relUrl": "/2022/03/21/(3%EC%A3%BC%EC%B0%A8)-3%EC%9B%9421%EC%9D%BC.html",
            "date": " • Mar 21, 2022"
        }
        
    
  
    
        ,"post25": {
            "title": "(3주차) 3월16일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/2) 튜플, 슬기롭게 튜플 사용하기 (1) . - (2/2) 슬기롭게 튜플 사용하기 (2) . &#53916;&#54540; . &#47532;&#49828;&#53944; vs &#53916;&#54540; . - 컨테이너형타입이라는 점, 그리고 연산 및 인덱싱을 하는 방법은 리스트와 같음 . 차이점1: [] 대신에 ()를 사용한다. | 차이점2: 불변형이다. (원소의 값을 바꿀 수 없음) | 차이점3: 하나의 원소를 선언할 때는 (1,)와 같이 해야 한다. | 차이점4: 의미가 명확할때는 튜플의 ()를 생략가능하다. | . - 컨테이너형이라는 것이 무슨의미? . a=(4,6,&#39;pencil&#39;, 3.2+4.6j, [3,4]) . type(a[2]) . str . type(a[3]) . complex . - 불변형이라는 것은 무슨의미? . a[2] = &#39;Pencil&#39; . TypeError Traceback (most recent call last) Input In [13], in &lt;cell line: 1&gt;() -&gt; 1 a[2] = &#39;Pencil&#39; TypeError: &#39;tuple&#39; object does not support item assignment . 참고로 a를 튜플이 아니라 리스트로 선언하면 값이 잘 바뀐다. . a=[4,6,&#39;pencil&#39;, 3.2+4.6j, [3,4]] . a[2] . &#39;pencil&#39; . a[2]=&#39;Pencil&#39; . a . [4, 6, &#39;Pencil&#39;, (3.2+4.6j), [3, 4]] . - 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야 함. . [1]+[2,3,4] . [1, 2, 3, 4] . (1,)+(2,3,4) . (1, 2, 3, 4) . - 마지막차이점! 의미가 명확할때 튜플의 괄호는 생략가능하다. (이게 중요합니다) . a=1,2 a . (1, 2) . 의미가 명확할때 생략해야함 . 1,2 + 3,4,5 . (1, 5, 4, 5) . (1,2) + (3,4,5) . (1, 2, 3, 4, 5) . &#49440;&#50616; . - 소괄호를 이용 . a=(1,2,3) a . (1, 2, 3) . type(a) . tuple . - 생략가능하다는 점이 포인트 . a=1,2,3 a . (1, 2, 3) . type(a) . tuple . - 원소가 하나인 튜플을 만들고 싶다면? . a=(1,) a . (1,) . &#50672;&#49328; . - 리스트와 동일 . (1,2)+(3,4,5) . (1, 2, 3, 4, 5) . (1,2)*2 . (1, 2, 1, 2) . &#51064;&#45937;&#49905; . - 리스트와 동일 . a=(1,2,3,-4,-5) a . (1, 2, 3, -4, -5) . a[-1] . -5 . a[-3:] . (3, -4, -5) . &#53916;&#54540;&#44256;&#44553; . &#53916;&#54540;&#51012; &#50780; &#48520;&#48320;&#54805;&#51004;&#47196; &#47564;&#46308;&#50632;&#51012;&#44620;? . 책의설명: 실수로 값을 변경할 수 있도록 방지할 수 있다. | shallow copy / deep copy 를 막을 수 있는 무기 | . &#53916;&#54540;&#51012; &#49836;&#44592;&#47213;&#44172; &#49324;&#50857;&#54616;&#45716; &#48169;&#48277; ($ star star star star star$) . - 예제: 여러변수를 동시에 출력하고 싶을 경우 (다중출력?) . 변수를 아래와 같이 선언하였다고 하자. . a=1 b=2 c=3 . 선언된 값을 확인하려면? . a . 1 . b . 2 . c . 3 . 튜플을 이용하면? . a,b,c # 괄호하나 생략하는것이 이렇게 편하다.. . (1, 2, 3) . - 예제: 다중할당1 (여러개의 변수를 동시에 선언하고 싶을 경우) . name, age, sex, height, weight = &#39;Tom&#39;, 20, &#39;M&#39;, 180, 70 . name, age, sex, height, weight . (&#39;Tom&#39;, 20, &#39;M&#39;, 180, 70) . height . 180 . - 예제: 다중할당2, 위도와 경도 . coor = (37,127) # 서울 coor . (37, 127) . lat, long = coor . lat . 37 . long . 127 . - 잠깐만: 다중할당은 꼭 튜플에서만 가능한가? . 그건 아니다... . [x,y,z] = [1,2,3] x,y,z # 다중출력 . (1, 2, 3) . [x,y] = &#39;hi&#39; x,y . (&#39;h&#39;, &#39;i&#39;) . 튜플과 같이 사용하면 가독성이 극대화 (그래서 다중할당은 거의 튜플과 세트로 사용함) . x,y,z = 1,2,3 x,y,z # 다중출력 . (1, 2, 3) . x,y = &#39;hi&#39; x,y . (&#39;h&#39;, &#39;i&#39;) . - 예제: 임시변수 사용없이 두 변수의 값을 교환 . a=10 b=20 . a,b = b,a . a . 20 . b . 10 . - 예제: for문과 튜플 . lst = [[&#39;guebin&#39;, 202112345, &#39;M&#39;], [&#39;iu&#39;,202254321, &#39;F&#39;], [&#39;hodong&#39;, 202011223, &#39;M&#39;]] lst . [[&#39;guebin&#39;, 202112345, &#39;M&#39;], [&#39;iu&#39;, 202254321, &#39;F&#39;], [&#39;hodong&#39;, 202011223, &#39;M&#39;]] . for i in lst: print(i) . [&#39;guebin&#39;, 202112345, &#39;M&#39;] [&#39;iu&#39;, 202254321, &#39;F&#39;] [&#39;hodong&#39;, 202011223, &#39;M&#39;] . for name,studentid,sex in lst: print(name) . guebin iu hodong . for name,studentid,sex in lst: print(name,sex) . guebin M iu F hodong M . - 예제: for문과 튜플, dummy variable _ . for name,studentid,sex in lst: print(studentid) . 202112345 202254321 202011223 . for _,studentid,_ in lst: print(studentid) . 202112345 202254321 202011223 . for _,_,sex in lst: print(sex) . M F M . for name,_,sex in lst: print(name,sex) . guebin M iu F hodong M . for name,_ in lst: print(name) . ValueError Traceback (most recent call last) Input In [88], in &lt;cell line: 1&gt;() -&gt; 1 for name,_ in lst: 2 print(name) ValueError: too many values to unpack (expected 2) . for name,*args in lst: print(name) . guebin iu hodong . - 예제: 튜플과 언패킹연산자 * . head, body, *tail = range(1,11) head, body, tail . (1, 2, [3, 4, 5, 6, 7, 8, 9, 10]) . head1,head2, *body, tail1,tail2,tail3 = range(1,11) head1,head2, body, tail1,tail2,tail3 . (1, 2, [3, 4, 5, 6, 7], 8, 9, 10) . *head, body, tail = range(1,11) head, body, tail . ([1, 2, 3, 4, 5, 6, 7, 8], 9, 10) . (관찰) . 그러고 보니까.. . head1,head2, body, tail1,tail2,tail3 = (1, 2, [3,4,5,6,7], 8, 9, 10) head1,head2, *body, tail1,tail2,tail3 = (1, 2, 3,4,5,6,7, 8, 9, 10) . 이렇다는 거잖아? . *를 붙이면 1차원 자료구조가 풀린다..? . *[1,2,3] . Input In [103] *[1,2,3] ^ SyntaxError: can&#39;t use starred expression here . print([1,2,3]) . [1, 2, 3] . print(*[1,2,3]) ## 이런 느낌이란 말이지.. . 1 2 3 . - 예제: 함수의 입력으로 *args를 넣을때 . [예비학습] 함수 벼락치기 . def myadd(a,b): return a+b . myadd(3,-3) . 0 . 벼락치기 끝 . 예제시작: 두점 사이의 거리를 구하는 함수를 만들어 보자. . 점 $p=(p_x,p_y)$와 $q=(q_x,q_y)$의 거리는 $ sqrt{(p_x-q_x)^2+(p_y-q_y)^2}$이다. 이것을 계산하는 프로그램을 만들자. . import numpy as np def dist(px,py,qx,qy): return np.sqrt((px-qx)**2 + (py-qy)**2) . p=(0,3) q=(4,0) dist(p,q) . TypeError Traceback (most recent call last) Input In [119], in &lt;cell line: 3&gt;() 1 p=(0,3) 2 q=(4,0) -&gt; 3 dist(p,q) TypeError: dist() missing 2 required positional arguments: &#39;qx&#39; and &#39;qy&#39; . (방법1) . px,py = (0,3) qx,qy = (4,0) dist(px,py,qx,qy) . 5.0 . (방법2) . def dist2(p,q): px,py = p qx,qy = q return np.sqrt((px-qx)**2 + (py-qy)**2) ### 이건 나쁜 생각이에요.. # def dist2(p,q): # px=p[0] # py=p[1] # qx=q[0] # qy=q[1] # return np.sqrt((px-qx)**2 + (py-qy)**2) . p=(0,3) q=(4,0) dist2(p,q) . 5.0 . (방법3) . dist(*p,*q) # 입력을 *(px,py), *(qx,qy) 형태로 넣기도하고.. . 5.0 . dist(px,py,qx,qy) # 입력을 px,py,qx,qy 형태로 넣기도하고.. . 5.0 . (숙제) 원소로 자기학번을 포함하는 튜플을 만들어서 제출 (길이가 1인 튜플을 만들어서 제출) .",
            "url": "https://guebin.github.io/IP2022/2022/03/16/(3%EC%A3%BC%EC%B0%A8)-3%EC%9B%9416%EC%9D%BC.html",
            "relUrl": "/2022/03/16/(3%EC%A3%BC%EC%B0%A8)-3%EC%9B%9416%EC%9D%BC.html",
            "date": " • Mar 16, 2022"
        }
        
    
  
    
        ,"post26": {
            "title": "(2주차) 3월14일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 리스트의 선언 및 연산 (1) . - (2/8) 리스트의 선언 및 연산 (2) ; 넘파이패키지 . - (3/8) 컨테이너형객체, 가변객체 . - (4/8) 리스트자료형의 메소드 . - (5/8) 중첩리스트; for문 (1) . - (6/8) for문 (2) . - (7/8) 리스트컴프리헨션 . - (8/8) 숙제설명 . list . &#49440;&#50616; . - 리스트의 선언 . a=[11,22] a . [11, 22] . type(a) . list . - 비어있는 리스트의 선언 . a=[] # 방법1 a . [] . a=list() # 방법2 a . [] . &#50672;&#49328; . - 더하기연산 . a=[11,12] b=[12,13] . a . [11, 12] . b . [12, 13] . a+b . [11, 12, 12, 13] . 우리의 예상과 다른 결과가 나옴 $ to$ 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있지 않음. | . - 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음. . a=[1,2,3] b=1 a+b . TypeError Traceback (most recent call last) Input In [9], in &lt;module&gt; 1 a=[1,2,3] 2 b=1 -&gt; 3 a+b TypeError: can only concatenate list (not &#34;int&#34;) to list . - 뺄셈은 정의되지 않음 . a=[1,2] b=[1,2] a-b . TypeError Traceback (most recent call last) Input In [10], in &lt;module&gt; 1 a=[1,2] 2 b=[1,2] -&gt; 3 a-b TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . - 곱하기는 정의가능 . a=[1,2] . 2*a # a+a . [1, 2, 1, 2] . - 나눗셈은 정의되지 않음 . a=[1,2,1,2] a/2 . TypeError Traceback (most recent call last) Input In [13], in &lt;module&gt; 1 a=[1,2,1,2] -&gt; 2 a/2 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . - 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄셈과 나눗셈이 원소의 삭제를 의미하는것은 아님 . a=[1,2,3] a-[3] # 이런건 없다 . TypeError Traceback (most recent call last) Input In [14], in &lt;module&gt; 1 a=[1,2,3] -&gt; 2 a-[3] TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . a=[1,2,1,2,1,2] a/3 # 이런건 없다 . TypeError Traceback (most recent call last) Input In [15], in &lt;module&gt; 1 a=[1,2,1,2,1,2] -&gt; 2 a/3 TypeError: unsupported operand type(s) for /: &#39;list&#39; and &#39;int&#39; . - 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, * 를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까? . (예제) . a=[1,2] b=[3,4] . a+b = [4,6] 이 되도록 하려면? . (풀이1) . a[0]+b[0] # a의 첫번째 원소를 추출, b의 첫번째 원소를 추출, 둘을 더함 . 4 . a[1]+b[1] # a의 두번째 원소를 추출, b의 두번째 원소를 추출, 둘을 더함 . 6 . [a[0]+b[0],a[1]+b[1]] . [4, 6] . 풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1] 은 각각 인트형임. 인트형은 + 연산이 가능했음. . (풀이2) . numpy 패키지 (파이썬의 여러 수치연산들을 담당하는 라이브러리) . 이러한 벡터연산은 누구나 필요로 하는 연산임. | 내가 아니더라도 누군가가 프로그램화 해놓았을 것임. | 그 누군가가 자신이 만든 코드를 잘 정리하여 무료로 배포했을 수도 있음. (패키지를 배포한다고 표현) | 그 패키지를 우리는 가져와서 설치한뒤 사용하기만 하면된다. | . 패키지를 설치하는 방법 . !pip install numpy # 최신버전을 설치함 | !conda install -c conda-forge numpy -y # 안전한 버전을 설치함 | . 설치된 패키지를 사용하는 방법 . import numpy 한뒤에 numpy.??로 기능을 사용 | import numpy as np 한뒤에 np.??로 기능을 사용 | . import numpy ## 설치한패키지를 쓰겠다고 선언함 . a=[1,2] b=[3,4] . aa=numpy.array(a) bb=numpy.array(b) # aa,bb는 리스트가 아니라 넘파이 어레이, # numpy.array()는 numpy패키지에서 제공하는 array함수를 쓰겠다는 의미. . aa+bb . array([4, 6]) . 이런것도 가능 . 2*aa . array([2, 4]) . 2*aa+1 . array([3, 5]) . 2*aa+1+bb . array([6, 9]) . (풀이3) . import numpy as np ## 설치한 numpy라는 패키지를 쓰겠음. 그런데 numpy말고 np라는 이름으로 쓰겠음 . a=[1,2] b=[3,4] np.array(a)+np.array(b) . array([4, 6]) . &#51064;&#45937;&#49905; . - str형과 동일한 방식 . a=[11,22,33,44,55] # 0 -4 -3 -2 -1 . a[-2:] # 끝의 2개의 원소를 뽑음 . [44, 55] . list &#44256;&#44553; . &#53080;&#53580;&#51060;&#45320;&#54805; &#44061;&#52404;, &#44032;&#48320;&#44061;&#52404; . - 리스트의 원소는 int, float 따위만 가능한 것이 아니다. (리스트는 컨테이너형 객체이므로) . lst = [1,3.14,True,&#39;a&#39;,[1,2], (1,2),{&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:27},{1,2,3}] . lst . [1, 3.14, True, &#39;a&#39;, [1, 2], (1, 2), {&#39;name&#39;: &#39;iu&#39;, &#39;age&#39;: 27}, {1, 2, 3}] . 각 원소의 타입을 알아보자. . type(lst[0]) . int . type(lst[1]) . float . type(lst[2]) . bool . type(lst[3]) . str . type(lst[4]) . list . type(lst[5]) . tuple . type(lst[6]) . dict . type(lst[7]) . set . - str은 컨테이너형이 아니다. . &#39;abcd&#39;[2] . &#39;c&#39; . str의 모든 원소는 문자임 | . - 리스트의 원소를 수정할 수 있다. (리스트는 가변객체이므로) . a=[11,22,33] a . [11, 22, 33] . a[0] . 11 . a[0]=111 . a . [111, 22, 33] . - 원소수정은 당연한 기능같은데 이것이 불가능한 경우도 있다. . (가능한경우) . a=[&#39;g&#39;,&#39;u&#39;,&#39;e&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;] a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . a[0] . &#39;g&#39; . a[0]=&#39;G&#39; . a . [&#39;G&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . (불가능한경우) . a=&#39;guebin&#39; a . &#39;guebin&#39; . a[0] . &#39;g&#39; . a[0]=&#39;G&#39; . TypeError Traceback (most recent call last) Input In [109], in &lt;module&gt; -&gt; 1 a[0]=&#39;G&#39; TypeError: &#39;str&#39; object does not support item assignment . - 리스트 원소 삭제 . (예제) . 아래와 같이 문자로 된 리스트를 선언하자. . a=[&#39;g&#39;,&#39;u&#39;,&#39;e&#39;,&#39;b&#39;,&#39;i&#39;,&#39;n&#39;] a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 사실 더 쉽게 선언할 수 있음 . a= &#39;guebin&#39; # string으로 a를 선언 a= list(a) # list(a)를 통하여 str을 ㅣist로 변환 -&gt; 그 결과를 a에 다시 저장 a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 첫번째 원소를 삭제하고 싶다면? . del a[0] . a . [&#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . 이 상태에서 다시 첫번쨰 원소를 삭제한다면? . del a[0] . a . [&#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . - 리스트의 원소 추가 . (예제) 비어있는 리스트를 만들고 원소 0,1,2를 차례로 추가하여 보자. . (풀이1) . a=[] a . [] . a= a + [0] a . [0] . a= a + [1] a . [0, 1] . a= a + [2] a . [0, 1, 2] . (풀이2) . a=[] a . [] . a += [0] a . [0] . a += [1] a . [0, 1] . a += [2] a . [0, 1, 2] . 암기법: 중복되는 변수를 지우고 연산자의 순서를 바꾼다. | . (풀이3) 리스트 특화기능(=메소드)를 이용 . a=[] a . [] . a.append(0) a . [0] . a.append(1) a . [0, 1] . a.append(2) a . [0, 1, 2] . - a+[4]와 a.append(4)의 차이점은? . (관찰1) . a=[1,2,3] a+[4] ## 리스트 a와 리스트 [4]의 연산결과를 알려줘 . [1, 2, 3, 4] . a ## a는 그대로임. 변화없음 . [1, 2, 3] . (관찰2) . a=[1,2,3] a.append(4) . a ## a자체가 변화함 . [1, 2, 3, 4] . 비슷해보이지만 굉장히 미묘한 차이가 있음 . a.append(4): a에 4를 append하라 $ to$ a가 변함 . a+[4]: a와 4를 연산하라 . &#47700;&#49548;&#46300; (&#47532;&#49828;&#53944; &#51088;&#47308;&#54805;&#50640; &#53945;&#54868;&#46108; &#53945;&#49688;&#54620; &#54632;&#49688;&#46308;) . (append) . a=[1,2,3,4] a.append? . Signature: a.append(object, /) Docstring: Append object to the end of the list. Type: builtin_function_or_method . a.append(5) a . [1, 2, 3, 4, 5] . (clear) . a=[1,2,3,4] a.clear? . Signature: a.clear() Docstring: Remove all items from list. Type: builtin_function_or_method . a.clear() a . [] . (copy) . a=[1,2,3,4] a.copy? . Signature: a.copy() Docstring: Return a shallow copy of the list. Type: builtin_function_or_method . b=a.copy() b . [1, 2, 3, 4] . (count) . a=[1,1,2,3,3,4,4,4] a.count? . Signature: a.count(value, /) Docstring: Return number of occurrences of value. Type: builtin_function_or_method . a.count(1) . 2 . a.count(2) . 1 . a.count(3) . 2 . a.count(4) . 3 . (extend) . a=[1,2,3,4] b=[-1,-2,-3,-4] . a.extend(b) a . [1, 2, 3, 4, -1, -2, -3, -4] . a=[1,2,3,4] b=[-1,-2,-3,-4] . a.append(b) . a . [1, 2, 3, 4, [-1, -2, -3, -4]] . (index) . a=[11,22,&#39;a&#39;,True, 22,&#39;a&#39;] a.index? . Signature: a.index(value, start=0, stop=9223372036854775807, /) Docstring: Return first index of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a.index(11) . 0 . a.index(22) . 1 . a.index(&#39;a&#39;) . 2 . a.index(True) . 3 . (insert) . a=[1,2,3] a.insert? . Signature: a.insert(index, object, /) Docstring: Insert object before index. Type: builtin_function_or_method . a.insert(1,88) a . [1, 88, 2, 3] . (pop) . a=[&#39;a&#39;,1,2,&#39;d&#39;] a.pop? . Signature: a.pop(index=-1, /) Docstring: Remove and return item at index (default last). Raises IndexError if list is empty or index is out of range. Type: builtin_function_or_method . a.pop() # index=-1 이므로 마지막원소가 나타남 . &#39;d&#39; . a # a는 마지막 원소가 사라진 상태 . [&#39;a&#39;, 1, 2] . a.pop(0) # index=0 이므로 첫번쨰 원소가 나타남 . &#39;a&#39; . a # a에는 첫번째 원소가 사라진 상태 . [1, 2] . (remove) . a=[&#39;a&#39;,2,3,&#39;d&#39;] a.remove? . Signature: a.remove(value, /) Docstring: Remove first occurrence of value. Raises ValueError if the value is not present. Type: builtin_function_or_method . a.remove(&#39;d&#39;) . a . [&#39;a&#39;, 2, 3] . a.remove(&#39;a&#39;) . a . [2, 3] . (reverse) . a=[1,2,3,4] a.reverse? . Signature: a.reverse() Docstring: Reverse *IN PLACE*. Type: builtin_function_or_method . a.reverse() a . [4, 3, 2, 1] . (sort) . a=[1,3,2,4] a.sort? . Signature: a.sort(*, key=None, reverse=False) Docstring: Sort the list in ascending order and return None. The sort is in-place (i.e. the list itself is modified) and stable (i.e. the order of two equal elements is maintained). If a key function is given, apply it once to each list item and sort them, ascending or descending, according to their function values. The reverse flag can be set to sort in descending order. Type: builtin_function_or_method . a.sort() a . [1, 2, 3, 4] . (다른예제들) . a=list(&#39;guebin&#39;) a . [&#39;g&#39;, &#39;u&#39;, &#39;e&#39;, &#39;b&#39;, &#39;i&#39;, &#39;n&#39;] . a.sort() a . [&#39;b&#39;, &#39;e&#39;, &#39;g&#39;, &#39;i&#39;, &#39;n&#39;, &#39;u&#39;] . a.sort(reverse=True) a . [&#39;u&#39;, &#39;n&#39;, &#39;i&#39;, &#39;g&#39;, &#39;e&#39;, &#39;b&#39;] . &#51473;&#52393;&#47532;&#49828;&#53944; . A=[[1,2,3],[4,5,6],[7,8,9]] A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . - A는 아래와 같은 매트릭스로 이해할 수 있다 . $ bf{A}= begin{bmatrix} 1 &amp; 2 &amp; 3 4 &amp; 5 &amp; 6 7 &amp; 8 &amp; 9 end{bmatrix} $ . - A에서 (2,1)의 원소를 뽑고싶다 = 4를 뽑고싶다 . A[1,0] . TypeError Traceback (most recent call last) Input In [279], in &lt;module&gt; -&gt; 1 A[1,0] TypeError: list indices must be integers or slices, not tuple . 실패 | . A[1][0] . 4 . 성공 | . - 성공의 이유를 분석해보자. . A . [[1, 2, 3], [4, 5, 6], [7, 8, 9]] . A[1] . [4, 5, 6] . A[1][0] . 4 . - 매트릭스는 아니지만 매트릭스 같음! . 1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함 | . &#47532;&#49828;&#53944;&#52980;&#54532;&#47532;&#54760;&#49496;($ star star star$) . - 리스트 컴프리헨션을 이해하기 전에 for문에 대하여 알아보자. . [예비학습] for문 벼락치기 . 프로그램안에서 반복해서 무엇인가를 하고싶다 $ to$ for . for i in [0,1,2,3]: ## 반복실행계획 print(i) ## 반복실행할내용, 탭을이용하여 들여쓰기해야한다. . 0 1 2 3 . (예제) 1,2,3,4의 합을 for문을 이용하여 구해보자. . _sum = 0 for i in [1,2,3,4]: _sum = _sum + i . _sum . 10 . _sum = 0 i=1 _sum = _sum + i ## 1 &lt;= 0+1 i=2 _sum = _sum + i ## 3 &lt;= 1+2 i=3 _sum = _sum + i ## 6 &lt;= 3+3 i=4 _sum = _sum + i ## 10 &lt;= 6+4 . _sum . 10 . 예비학습끝 . - 예제: $2^0, 2^1, 2^2, 2^3$를 원소로 가지는 리스트를 생성하라. . (풀이1) 직접입력 . x= [2**0, 2**1, 2**2, 2**3] x . [1, 2, 4, 8] . (풀이2) for문을 이용함 . x=[] for i in [0,1,2,3]: x.append(2**i) . x . [1, 2, 4, 8] . (풀이3) for문을 이용함 . x=[] for i in [0,1,2,3]: x = x+[2**i] . x . [1, 2, 4, 8] . (풀이4) for문을 이용함 . x=[] for i in [0,1,2,3]: x += [2**i] . x . [1, 2, 4, 8] . (풀이5) 리스트컴프리헨션을 이용한 풀이 . x= [2**i for i in [0,1,2,3]] x . [1, 2, 4, 8] . - 리스트컴프리헨션의 문법 암기방법 . 집합에서 조건제시법을 연상 | $ {2^0,2^1,2^2,2^3 }= {2^i: i in {0,1,2,3 } }$ | . - 리스트컴프리헨션이란? . 리스트를 매우 효율적으로 만드는 테크닉 | for문에 비하여 가지고 있는 장점: (1) 코드가 간결하다 (2) 빠르다 | . - 예제: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;SSSS&#39;,&#39;PPPP&#39;,&#39;AAAA&#39;,&#39;MMMM&#39;] . [&#39;SSSS&#39;, &#39;PPPP&#39;, &#39;AAAA&#39;, &#39;MMMM&#39;] . (풀이) . [i*4 for i in &#39;SPAM&#39;] . [&#39;SSSS&#39;, &#39;PPPP&#39;, &#39;AAAA&#39;, &#39;MMMM&#39;] . - 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;Y1&#39;,&#39;Y2&#39;,&#39;Y3&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . (풀이) . [i+j for i in &#39;XY&#39; for j in &#39;123&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . - 예제: 리스트컴프리헨션을 이용하여 통계1,...,통계5,수학1,...,수학5를 만들어라. . (풀이) . [x+y for x in [&#39;stat&#39;,&#39;math&#39;] for y in &#39;12345&#39;] . [&#39;stat1&#39;, &#39;stat2&#39;, &#39;stat3&#39;, &#39;stat4&#39;, &#39;stat5&#39;, &#39;math1&#39;, &#39;math2&#39;, &#39;math3&#39;, &#39;math4&#39;, &#39;math5&#39;] . $ {xy : x in {stat,math }, y in {1,2,3,4,5 } }$ | . (다른풀이) 참고로 for문을 쓰면 좀 복잡해진다. . _lst = [] for x in [&#39;stat&#39;,&#39;math&#39;]: for y in &#39;12345&#39;: _lst = _lst + [x+y] . _lst . [&#39;stat1&#39;, &#39;stat2&#39;, &#39;stat3&#39;, &#39;stat4&#39;, &#39;stat5&#39;, &#39;math1&#39;, &#39;math2&#39;, &#39;math3&#39;, &#39;math4&#39;, &#39;math5&#39;] . - 예제: &#39;jbnu&#39;를 이용하여 아래와 같은 리스트를 만들어라. (리스트컴프리헨션을 이용할것) . [&#39;j&#39;,&#39;b&#39;,&#39;n&#39;,&#39;u&#39;] . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . (다른풀이) 아래와 같이 풀면 된다는것은 알고 있음 . list(&#39;jbnu&#39;) . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . (풀이) . [x for x in &#39;jbnu&#39;] . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . - 예제: x에는 무엇이 있을까? . (경우1) . x=1 lst = [] for x in &#39;jbnu&#39;: lst = lst + [x] lst . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . x . &#39;u&#39; . (경우2) . x=1 lst = [x for x in &#39;jbnu&#39;] lst . [&#39;j&#39;, &#39;b&#39;, &#39;n&#39;, &#39;u&#39;] . x . 1 . 진짜 미묘하게 다르죠? | . - 예제: [X1,X2,X3,...,X100]와 같은 리스트를 만들어보라. . (풀이) . [&#39;X&#39;+str(i) for i in [1,2,3,4]] ## 이걸 4까지가 아니라 100까지 써야함 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;] . [&#39;X&#39;+str(i) for i in 1:100] . Input In [432] [&#39;X&#39;+str(i) for i in 1:100] ^ SyntaxError: invalid syntax . [예비학습] . range(0,10) . range(0, 10) . 이게뭐야? | . _tmp = range(0,10) _tmp? . Type: range String form: range(0, 10) Length: 10 Docstring: range(stop) -&gt; range object range(start, stop[, step]) -&gt; range object Return an object that produces a sequence of integers from start (inclusive) to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. These are exactly the valid indices for a list of 4 elements. When step is given, it specifies the increment (or decrement). . 우리가 아는 범위에서는 모르겠음.. 이런게 있나보다 하고 넘어가야 하겠음 | . list(range(0,10)) # 0을 포함, 10을 미포함 . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 이게 중요한것임. range(0,10)를 리스트화시키면 [0,1,2,...,9] 와 같은 리스트를 얻을 수 있음. | . list(range(10)) # 0은 생략가능 . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . list(range(2,10)) # 2는 포함, 10은 미포함 . [2, 3, 4, 5, 6, 7, 8, 9] . list(range(1,10,2)) # 2는 포함, 10은 미포함 . [1, 3, 5, 7, 9] . 예비학습 끝 . [&#39;X&#39;+str(i) for i in list(range(1,13))] ## 출력결과가 너무 기니까 101대신에 13으로 변경 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;, &#39;X5&#39;, &#39;X6&#39;, &#39;X7&#39;, &#39;X8&#39;, &#39;X9&#39;, &#39;X10&#39;, &#39;X11&#39;, &#39;X12&#39;] . (아래와 같은 풀이도 가능) . [&#39;X&#39;+str(i) for i in range(1,13)] ## 출력결과가 너무 기니까 101대신에 13으로 변경 . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;X4&#39;, &#39;X5&#39;, &#39;X6&#39;, &#39;X7&#39;, &#39;X8&#39;, &#39;X9&#39;, &#39;X10&#39;, &#39;X11&#39;, &#39;X12&#39;] . (딴생각) 생각해보니까 for문 뒤에 올수 있는것이 무엇인지 생각하는것도 흥미로울듯 . for i in &#39;1234&#39;: print(i) . 1 2 3 4 . for i in [1,2,3,4]: print(i) . 1 2 3 4 . for i in (1,2,3,4): # (1,2,3,4)는 튜플 print(i) . 1 2 3 4 . for i in {1,2,3,4}: # {1,2,3,4}는 set print(i) . 1 2 3 4 . for i in {&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:28}: #{&#39;name&#39;:&#39;iu&#39;,&#39;age&#39;:28} 는 딕셔너리 print(i) . name age . for i in range(1,5): print(i) . 1 2 3 4 . (숙제) . 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;X1&#39;,&#39;X2X2&#39;,&#39;X3X3X3&#39;,&#39;X4X4X4X4&#39;,&#39;X5X5X5X5X5&#39;] . [&#39;X1&#39;, &#39;X2X2&#39;, &#39;X3X3X3&#39;, &#39;X4X4X4X4&#39;, &#39;X5X5X5X5X5&#39;] .",
            "url": "https://guebin.github.io/IP2022/2022/03/14/(2%EC%A3%BC%EC%B0%A8)-3%EC%9B%9414%EC%9D%BC.html",
            "relUrl": "/2022/03/14/(2%EC%A3%BC%EC%B0%A8)-3%EC%9B%9414%EC%9D%BC.html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post27": {
            "title": "(1주차) 3월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/8) 아나콘다 설치, 가상환경 생성 . - (2/8) 주피터랩 설치 및 실행 (1) . - (3/8) 주피터랩 설치 및 실행 (2) . - (4/8) 0차원자료형: int, float, bool, 명시적형변환 . - (5/8) 0차원자료형: 암묵적형변환 . - (6/8) string (1) . - (7/8) string (2) . - (8/8) 숙제설명, 코랩설명 . - appendix: 윈도우에 영어계정만들기 . &#54028;&#51060;&#50028; &#44368;&#51116; . - 전자교재 . https://docs.python.org/3.9/tutorial/index.html | https://wikidocs.net/book/1 | https://jakevdp.github.io/PythonDataScienceHandbook/ | . - 종이책 . 효율적 개발로 이끄는 파이썬 실천 기술 | Learning python: powerful object-oriented programming | 전문가를 위한 파이썬 : 파이썬3 버전 기준 | 간단하고, 명료하고, 효율적인 파이썬 프로그래밍 | . &#51452;&#54588;&#53552;&#45432;&#53944;&#48513;, &#51452;&#54588;&#53552;&#47017; . - interactive notebook이 아니다. . a=3 a . 3 . b=3 b . 3 . a+b . 5 . - 주피터랩: 주피터노트북의 확장버전 . 저는 주피터랩을 더 선호합니다. | 그런데 주피터노트북을 쓸 경우도 있음. | . - 마크다운모드(글쓰기모드), 코드모드(프로그래밍모드) . &#51088;&#47308;&#54805; . - 파이썬의 기본자료형은 int, float, bool, str, list, tuple, dict, set 등이 있다. . 0차원 자료형: int, float, bool | 1차원 자료형: str, list, tuple, dict, set | . int, float, bool . - int형 . a=100 . type(a) . int . - float형 . a=1.2*3 a . 3.5999999999999996 . type(a) . float . a? . Type: float String form: 3.5999999999999996 Docstring: Convert a string or number to a floating point number, if possible. . - bool형 . a=True ## 숫자1으로 생각할 수 있음 b=False ## 숫자0으로 생각할 수 있음 . type(a) . bool . type(b) . bool . a? . Type: bool String form: True Docstring: bool(x) -&gt; bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed. . b? . Type: bool String form: False Docstring: bool(x) -&gt; bool Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed. . - bool형의 연산 . a=True ## 1 b=False ## 0 . a+b . 1 . a*b . 0 . - complex형 . a=1+2j b=2-2j . type(a) . complex . type(b) . complex . a? . Type: complex String form: (1+2j) Docstring: Create a complex number from a real part and an optional imaginary part. This is equivalent to (real + imag*1j) where imag defaults to 0. . b? . Type: complex String form: (2-2j) Docstring: Create a complex number from a real part and an optional imaginary part. This is equivalent to (real + imag*1j) where imag defaults to 0. . c=a+b . c . (3+0j) . - 형태변환: float $ to$ int . (예시1) . a=3.0 type(a) . float . a=int(a) . type(a) . int . (예시2) 이경우는 정보의 손실이 발생 . a=3.14 int(a) . 3 . - 형태변환: int $ to$ float . a=3 type(a) . int . a=float(a) type(a) . float . - 형태변환: bool $ to$ int/float, int/float $ to$ bool . (예시1) . a=True type(a) . bool . int(a) . 1 . float(a) . 1.0 . (예시2) . a=1 bool(a) . True . a=0 bool(a) . False . (예시3) . a=1.0 bool(a) . True . a=0.0 bool(a) . False . - 이상한 형태변환도 가능하다. (이런것도 바꿔주나 싶은것도 바꿔줌) . bool(-3.14) . True . 저는 이런 코드를 의도적으로 사용하지 않아요.. | . int(3.14) . 3 . - 형태변환이 항상가능한것도 아님 . float(3+0j) # 사실상 3+0j=3 이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 변환불가능하다. . TypeError Traceback (most recent call last) Input In [78], in &lt;module&gt; -&gt; 1 float(3+0j) TypeError: can&#39;t convert complex to float . - 암묵적형변환 (implicit) . (예비학습) implicit의 의미 . 추운날씨 -&gt; 보일러좀 틀자! (explicit) / 오늘 날씨 좀 추운 것 같지 않아? (implicit) | 짜장면 먹을래? -&gt; 싫어! (explicit) / 난 어제 짜장면 먹었는데.. (implicit) | . (예제) . True * 1 # 1을 곱할건데 너 계속 True로 있을꺼야? . 1 . 1 * 1.0 # 1.0을 곱할건데 너 계속 int로 있을꺼야? . 1.0 . True+True # +연산을 할건데 계속 True로 있을꺼야? . 2 . str . - 선언 . a=&#39;guebin&#39; . a . &#39;guebin&#39; . &#50672;&#49328; . - 더하기(+)연산 . a=&#39;X&#39; b=&#39;2&#39; . c=a+b c . &#39;X2&#39; . - 빼기(-)연산 . a=&#39;X2&#39; b=&#39;2&#39; a-b . TypeError Traceback (most recent call last) Input In [92], in &lt;module&gt; 1 a=&#39;X2&#39; 2 b=&#39;2&#39; -&gt; 3 a-b TypeError: unsupported operand type(s) for -: &#39;str&#39; and &#39;str&#39; . 이런건 없다. | . - 곱하기(*)연산 . a=&#39;X&#39; . a+a+a . &#39;XXX&#39; . a*3 # a*3 = a+a+a = &#39;X&#39;+&#39;X+&#39;X&#39; . &#39;XXX&#39; . 아래도 가능하다. . 3*a . &#39;XXX&#39; . 그리고 아래도 가능하다. . a=&#39;X&#39; b=3 a*b . &#39;XXX&#39; . 대신에 의미상 맞지 않는 것은 수행되지 않고 에러가 난다. . a=&#39;X&#39; b=&#39;Y&#39; a+b . &#39;XY&#39; . a*b . TypeError Traceback (most recent call last) Input In [99], in &lt;module&gt; -&gt; 1 a*b TypeError: can&#39;t multiply sequence by non-int of type &#39;str&#39; . - 나눗셈(/)연산 . a=&#39;XX&#39; . a/2 . TypeError Traceback (most recent call last) Input In [101], in &lt;module&gt; -&gt; 1 a/2 TypeError: unsupported operand type(s) for /: &#39;str&#39; and &#39;int&#39; . 이런건 없다.. | . &#51064;&#45937;&#49905; . - str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하면 된다. . a=&#39;guebin&#39; . a . &#39;guebin&#39; . 6개의 칸에 글씨가 하나씩 들어가 있음. | . - 대괄호 []안에 숫자를 넣는 방식으로 벡터의 원소를 호출할 수 있다. (주의: 인덱스가 0부터 시작함) . a[0] #첫번째원소 . &#39;g&#39; . a[1] #두번째원소 . &#39;u&#39; . 마지막원소는 -1로 호출할 수도 있다. . a[-1] . &#39;n&#39; . 마지막에서 2번째 원소는 -2로 호출가능하다. . a[-2] . &#39;i&#39; . - 요약하면 아래와 같은 방식으로 호출가능함. . g u e b i n . 0 | 1 | 2 | 3 | 4 | 5 | . 0 | -5 | -4 | -3 | -2 | -1 | . a[4] . &#39;i&#39; . a[-2] . &#39;i&#39; . a[-4] . &#39;e&#39; . - :을 이용하여 여러개의 원소를 호출할 수 있음. . a=&#39;guebin&#39; . a[0:3] # a[0],a[1],a[2],a[3]이 아니라 a[0],a[1],a[2]까지만 뽑힌다. 즉 마지막의 3은 호출되지 않는다. . &#39;gue&#39; . a[1:3] # a[1], a[2] 만 호출 // start=1, stop=3 . &#39;ue&#39; . index=1부터 시작해서 마지막원소까지 호출하려면? . a[5] # guebin의 마지막원소 &#39;n&#39;이 출려 . &#39;n&#39; . a[1:5] # 5는 포함되지 않으므로 틀림 . &#39;uebi&#39; . a[1:6] # 정답 . &#39;uebin&#39; . 안 헷갈리는 방법은 없을까? . a[-1] . &#39;n&#39; . a[1:-1] # 이것은 결국 (a[1:5]와 같은 것임) . &#39;uebi&#39; . 해결책? 생략한다!! . a[1:] . &#39;uebin&#39; . - 생략의 응용1 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[2:5] . &#39;pop&#39; . a[2:] . &#39;pop&#39; . - 생략의 응용2 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[0:2] # a[0],a[1] . &#39;k-&#39; . a[:2] # a[0],a[1] . &#39;k-&#39; . - 생략의 응용3 . a=&#39;k-pop&#39; a . &#39;k-pop&#39; . a[0:5] # a[0],...,a[4] . &#39;k-pop&#39; . a[:] . &#39;k-pop&#39; . str &#53945;&#49688;&#44592;&#45733; . - 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다. . a=&#39;ABCD&#39; # a라는 변수는 &#39;ABCD&#39;라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다. a . &#39;ABCD&#39; . a.lower() # a.lower()를 쓰면 a의 모든 문자를 소문자로 바꾸는 기능을 제공, lower(a)라고 읽자! . &#39;abcd&#39; . 여기에서 lower()는 문자열에 특화된 기능임. 따라서 당연히 아래는 불가능 . a=3.14 a.lower() # lower(a) . AttributeError Traceback (most recent call last) Input In [194], in &lt;module&gt; 1 a=3.14 -&gt; 2 a.lower() AttributeError: &#39;float&#39; object has no attribute &#39;lower&#39; . - 자료형에 특화된 기능(=함수)을 확인하는 방법? a.+ tab 으로 목록 확인 가능 . a=&#39;guebin&#39; . a.upper? . Signature: a.upper() Docstring: Return a copy of the string converted to uppercase. Type: builtin_function_or_method . a.upper() # upper(a) . &#39;GUEBIN&#39; . a.capitalize() # capitalize(a) . &#39;Guebin&#39; . - 문자열에 대한 다른 내용들은 추후에 다루겠음. . - 마음의눈: a.f() 형태를 읽는 팁 . a.f()는 f(a)로 생각하면 편리함. | a.f(2)는 f(a,2)로 생각하면 편리함. | 이런점에서 R %&gt;% 연산자와 비슷하다고 생각할 수 있다. (약간 다르긴함) | . - 사실 .은 좀 더 다양한 상황에서 쓰일 수 있다. 변수이름.함수이름() 의 형태가 아니라 . 패지키이름.함수이름() | 패키지이름.변수이름 | 패키지이름.패키지이름.함수이름() | ... | . 와 같이 다양한 형태가 가능하다. 근본적인 공통점은 .을 기준으로 상위개념.하위개념 으로 이해하는 것이 좋다. . 0&#52264;&#50896; vs 1&#52264;&#50896; . - len함수 소개: 원소의 갯수를 알려주는 함수. . (0차원) len 함수가 동작하지 않음. . a=3.14 . len(a) . TypeError Traceback (most recent call last) Input In [197], in &lt;module&gt; -&gt; 1 len(a) TypeError: object of type &#39;float&#39; has no len() . b=True . len(b) . TypeError Traceback (most recent call last) Input In [201], in &lt;module&gt; -&gt; 1 len(b) TypeError: object of type &#39;bool&#39; has no len() . (1차원) len 함수가 잘 동작함. . a=&#39;3.14&#39; len(a) . 4 . b=[1,2,3] . len(b) . 3 . &#49689;&#51228; . 본인이름으로 str을 생성 $ to$ LMS에 스크린샷제출 . 성만 출력 | 이름만 출려 | . (예시) . a=&#39;GuebinChoi&#39; . a[:6] . &#39;Guebin&#39; . a[6:] . &#39;Choi&#39; .",
            "url": "https://guebin.github.io/IP2022/2022/03/07/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2022/03/07/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%947%EC%9D%BC.html",
            "date": " • Mar 7, 2022"
        }
        
    
  
    
        ,"post28": {
            "title": "(1주차) 3월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . .",
            "url": "https://guebin.github.io/IP2022/2022/03/02/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2022/03/02/(1%EC%A3%BC%EC%B0%A8)-3%EC%9B%942%EC%9D%BC.html",
            "date": " • Mar 2, 2022"
        }
        
    
  
    
        ,"post29": {
            "title": "(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기",
            "content": "About this doc . - 본 포스트는 2021년 1학기 Python 입문 강의내용중 일부를 업로드 하였음. . - Github, fastpages를 사용하여 블로그를 개설하고 관리하는 방법에 대한 설명임. . .",
            "url": "https://guebin.github.io/IP2022/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "relUrl": "/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "date": " • Aug 17, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "최규빈 . guebin@jbnu.ac.kr | 자연과학대학교 본관 205호 | 카카오톡 오픈채널 1 | . 2022년 1학기 종료후 폐쇄예정 &#8617; . |",
          "url": "https://guebin.github.io/IP2022/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/IP2022/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}